import { NestedStackResolver, } from './engine/nested_stack_resolver.js';
import { SingletonConstructContainer } from './engine/singleton_construct_container.js';
import { ToggleableImportPathVerifier } from './engine/validations/toggleable_import_path_verifier.js';
import { AttributionMetadataStorage, StackMetadataBackendOutputStorageStrategy, } from '@aws-amplify/backend-output-storage';
import { createDefaultStack } from './default_stack_factory.js';
import { getBackendIdentifier } from './backend_identifier.js';
import { platformOutputKey } from '@aws-amplify/backend-output-schemas';
import { fileURLToPath } from 'node:url';
import { AmplifyBranchLinkerConstruct } from './engine/branch-linker/branch_linker_construct.js';
import { ClientConfigVersionOption, } from '@aws-amplify/client-config';
import { CustomOutputsAccumulator } from './engine/custom_outputs_accumulator.js';
import { ObjectAccumulator } from '@aws-amplify/platform-core';
import { DefaultResourceNameValidator } from './engine/validations/default_resource_name_validator.js';
// Be very careful editing this value. It is the value used in the BI metrics to attribute stacks as Amplify root stacks
const rootStackTypeIdentifier = 'root';
// Client config version that is used by `backend.addOutput()`
const DEFAULT_CLIENT_CONFIG_VERSION_FOR_BACKEND_ADD_OUTPUT = ClientConfigVersionOption.V1;
/**
 * Factory that collects and instantiates all the Amplify backend constructs
 */
export class BackendFactory {
    /**
     * These are the resolved CDK constructs that are created by the inputs to the constructor
     * Used for overriding properties of underlying CDK constructs or to reference in custom CDK code
     */
    resources;
    stackResolver;
    customOutputsAccumulator;
    /**
     * Initialize an Amplify backend with the given construct factories and in the given CDK App.
     * If no CDK App is specified a new one is created
     */
    constructor(constructFactories, stack = createDefaultStack()) {
        new AttributionMetadataStorage().storeAttributionMetadata(stack, rootStackTypeIdentifier, fileURLToPath(new URL('../package.json', import.meta.url)));
        this.stackResolver = new NestedStackResolver(stack, new AttributionMetadataStorage());
        const constructContainer = new SingletonConstructContainer(this.stackResolver);
        const outputStorageStrategy = new StackMetadataBackendOutputStorageStrategy(stack);
        this.customOutputsAccumulator = new CustomOutputsAccumulator(outputStorageStrategy, new ObjectAccumulator({}));
        const backendId = getBackendIdentifier(stack);
        outputStorageStrategy.addBackendOutputEntry(platformOutputKey, {
            version: '1',
            payload: {
                deploymentType: backendId.type,
                region: stack.region,
            },
        });
        const shouldEnableBranchLinker = backendId.type === 'branch';
        if (shouldEnableBranchLinker) {
            new AmplifyBranchLinkerConstruct(stack, backendId);
        }
        const importPathVerifier = new ToggleableImportPathVerifier();
        const resourceNameValidator = new DefaultResourceNameValidator();
        // register providers but don't actually execute anything yet
        Object.values(constructFactories).forEach((factory) => {
            if (typeof factory.provides === 'string') {
                constructContainer.registerConstructFactory(factory.provides, factory);
            }
        });
        // now invoke all the factories and collect the constructs into this.resources
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.resources = {};
        Object.entries(constructFactories).forEach(([resourceName, constructFactory]) => {
            // The type inference on this.resources is not happy about this assignment because it doesn't know the exact type of .getInstance()
            // However, the assignment is okay because we are iterating over the entries of constructFactories and assigning the resource name to the corresponding instance
            this.resources[resourceName] = constructFactory.getInstance({
                constructContainer,
                outputStorageStrategy,
                importPathVerifier,
                resourceNameValidator,
            }
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            );
        });
    }
    /**
     * Returns a CDK stack within the Amplify project that can be used for creating custom resources.
     * If a stack has already been created with "name" then an error is thrown.
     */
    createStack = (name) => {
        return this.stackResolver.createCustomStack(name);
    };
    addOutput = (clientConfigPart) => {
        const { version } = clientConfigPart;
        if (!version) {
            clientConfigPart.version =
                DEFAULT_CLIENT_CONFIG_VERSION_FOR_BACKEND_ADD_OUTPUT;
        }
        this.customOutputsAccumulator.addOutput(clientConfigPart);
    };
}
/**
 * Creates a new Amplify backend instance and returns it
 * @param constructFactories - list of backend factories such as those created by `defineAuth` or `defineData`
 */
export const defineBackend = (constructFactories) => {
    const backend = new BackendFactory(constructFactories);
    return {
        ...backend.resources,
        createStack: backend.createStack,
        addOutput: backend.addOutput,
    };
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFja2VuZF9mYWN0b3J5LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2JhY2tlbmRfZmFjdG9yeS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFNQSxPQUFPLEVBQ0wsbUJBQW1CLEdBRXBCLE1BQU0sbUNBQW1DLENBQUM7QUFDM0MsT0FBTyxFQUFFLDJCQUEyQixFQUFFLE1BQU0sMkNBQTJDLENBQUM7QUFDeEYsT0FBTyxFQUFFLDRCQUE0QixFQUFFLE1BQU0seURBQXlELENBQUM7QUFDdkcsT0FBTyxFQUNMLDBCQUEwQixFQUMxQix5Q0FBeUMsR0FDMUMsTUFBTSxxQ0FBcUMsQ0FBQztBQUM3QyxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUNoRSxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUMvRCxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxxQ0FBcUMsQ0FBQztBQUN4RSxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sVUFBVSxDQUFDO0FBRXpDLE9BQU8sRUFBRSw0QkFBNEIsRUFBRSxNQUFNLG1EQUFtRCxDQUFDO0FBQ2pHLE9BQU8sRUFFTCx5QkFBeUIsR0FDMUIsTUFBTSw0QkFBNEIsQ0FBQztBQUNwQyxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSx3Q0FBd0MsQ0FBQztBQUNsRixPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUMvRCxPQUFPLEVBQUUsNEJBQTRCLEVBQUUsTUFBTSx5REFBeUQsQ0FBQztBQUV2Ryx3SEFBd0g7QUFDeEgsTUFBTSx1QkFBdUIsR0FBRyxNQUFNLENBQUM7QUFFdkMsOERBQThEO0FBQzlELE1BQU0sb0RBQW9ELEdBQ3hELHlCQUF5QixDQUFDLEVBQUUsQ0FBQztBQUUvQjs7R0FFRztBQUNILE1BQU0sT0FBTyxjQUFjO0lBR3pCOzs7T0FHRztJQUNNLFNBQVMsQ0FFaEI7SUFFZSxhQUFhLENBQWdCO0lB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O1FBQ0QsSUFBSSxDQUFDLHdCQUF3QixDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO0lBQzVELENBQUMsQ0FBQztDQUNIO0FBRUQ7OztHQUdHO0FBQ0gsTUFBTSxDQUFDLE1BQU0sYUFBYSxHQUFHLENBQzNCLGtCQUFxQixFQUNULEVBQUU7SUFDZCxNQUFNLE9BQU8sR0FBRyxJQUFJLGNBQWMsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0lBQ3ZELE9BQU87UUFDTCxHQUFHLE9BQU8sQ0FBQyxTQUFTO1FBQ3BCLFdBQVcsRUFBRSxPQUFPLENBQUMsV0FBVztRQUNoQyxTQUFTLEVBQUUsT0FBTyxDQUFDLFNBQVM7S0FDN0IsQ0FBQztBQUNKLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENvbnN0cnVjdEZhY3RvcnksXG4gIERlZXBQYXJ0aWFsQW1wbGlmeUdlbmVyYXRlZENvbmZpZ3MsXG4gIFJlc291cmNlUHJvdmlkZXIsXG59IGZyb20gJ0Bhd3MtYW1wbGlmeS9wbHVnaW4tdHlwZXMnO1xuaW1wb3J0IHsgU3RhY2sgfSBmcm9tICdhd3MtY2RrLWxpYic7XG5pbXBvcnQge1xuICBOZXN0ZWRTdGFja1Jlc29sdmVyLFxuICBTdGFja1Jlc29sdmVyLFxufSBmcm9tICcuL2VuZ2luZS9uZXN0ZWRfc3RhY2tfcmVzb2x2ZXIuanMnO1xuaW1wb3J0IHsgU2luZ2xldG9uQ29uc3RydWN0Q29udGFpbmVyIH0gZnJvbSAnLi9lbmdpbmUvc2luZ2xldG9uX2NvbnN0cnVjdF9jb250YWluZXIuanMnO1xuaW1wb3J0IHsgVG9nZ2xlYWJsZUltcG9ydFBhdGhWZXJpZmllciB9IGZyb20gJy4vZW5naW5lL3ZhbGlkYXRpb25zL3RvZ2dsZWFibGVfaW1wb3J0X3BhdGhfdmVyaWZpZXIuanMnO1xuaW1wb3J0IHtcbiAgQXR0cmlidXRpb25NZXRhZGF0YVN0b3JhZ2UsXG4gIFN0YWNrTWV0YWRhdGFCYWNrZW5kT3V0cHV0U3RvcmFnZVN0cmF0ZWd5LFxufSBmcm9tICdAYXdzLWFtcGxpZnkvYmFja2VuZC1vdXRwdXQtc3RvcmFnZSc7XG5pbXBvcnQgeyBjcmVhdGVEZWZhdWx0U3RhY2sgfSBmcm9tICcuL2RlZmF1bHRfc3RhY2tfZmFjdG9yeS5qcyc7XG5pbXBvcnQgeyBnZXRCYWNrZW5kSWRlbnRpZmllciB9IGZyb20gJy4vYmFja2VuZF9pZGVudGlmaWVyLmpzJztcbmltcG9ydCB7IHBsYXRmb3JtT3V0cHV0S2V5IH0gZnJvbSAnQGF3cy1hbXBsaWZ5L2JhY2tlbmQtb3V0cHV0LXNjaGVtYXMnO1xuaW1wb3J0IHsgZmlsZVVSTFRvUGF0aCB9IGZyb20gJ25vZGU6dXJsJztcbmltcG9ydCB7IEJhY2tlbmQsIERlZmluZUJhY2tlbmRQcm9wcyB9IGZyb20gJy4vYmFja2VuZC5qcyc7XG5pbXBvcnQgeyBBbXBsaWZ5QnJhbmNoTGlua2VyQ29uc3RydWN0IH0gZnJvbSAnLi9lbmdpbmUvYnJhbmNoLWxpbmtlci9icmFuY2hfbGlua2VyX2NvbnN0cnVjdC5qcyc7XG5pbXBvcnQge1xuICBDbGllbnRDb25maWcsXG4gIENsaWVudENvbmZpZ1ZlcnNpb25PcHRpb24sXG59IGZyb20gJ0Bhd3MtYW1wbGlmeS9jbGllbnQtY29uZmlnJztcbmltcG9ydCB7IEN1c3RvbU91dHB1dHNBY2N1bXVsYXRvciB9IGZyb20gJy4vZW5naW5lL2N1c3RvbV9vdXRwdXRzX2FjY3VtdWxhdG9yLmpzJztcbmltcG9ydCB7IE9iamVjdEFjY3VtdWxhdG9yIH0gZnJvbSAnQGF3cy1hbXBsaWZ5L3BsYXRmb3JtLWNvcmUnO1xuaW1wb3J0IHsgRGVmYXVsdFJlc291cmNlTmFtZVZhbGlkYXRvciB9IGZyb20gJy4vZW5naW5lL3ZhbGlkYXRpb25zL2RlZmF1bHRfcmVzb3VyY2VfbmFtZV92YWxpZGF0b3IuanMnO1xuXG4vLyBCZSB2ZXJ5IGNhcmVmdWwgZWRpdGluZyB0aGlzIHZhbHVlLiBJdCBpcyB0aGUgdmFsdWUgdXNlZCBpbiB0aGUgQkkgbWV0cmljcyB0byBhdHRyaWJ1dGUgc3RhY2tzIGFzIEFtcGxpZnkgcm9vdCBzdGFja3NcbmNvbnN0IHJvb3RTdGFja1R5cGVJZGVudGlmaWVyID0gJ3Jvb3QnO1xuXG4vLyBDbGllbnQgY29uZmlnIHZlcnNpb24gdGhhdCBpcyB1c2VkIGJ5IGBiYWNrZW5kLmFkZE91dHB1dCgpYFxuY29uc3QgREVGQVVMVF9DTElFTlRfQ09ORklHX1ZFUlNJT05fRk9SX0JBQ0tFTkRfQUREX09VVFBVVCA9XG4gIENsaWVudENvbmZpZ1ZlcnNpb25PcHRpb24uVjE7XG5cbi8qKlxuICogRmFjdG9yeSB0aGF0IGNvbGxlY3RzIGFuZCBpbnN0YW50aWF0ZXMgYWxsIHRoZSBBbXBsaWZ5IGJhY2tlbmQgY29uc3RydWN0c1xuICovXG5leHBvcnQgY2xhc3MgQmFja2VuZEZhY3Rvcnk8XG4gIFQgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBDb25zdHJ1Y3RGYWN0b3J5PFJlc291cmNlUHJvdmlkZXI+PlxuPiB7XG4gIC8qKlxuICAgKiBUaGVzZSBhcmUgdGhlIHJlc29sdmVkIENESyBjb25zdHJ1Y3RzIHRoYXQgYXJlIGNyZWF0ZWQgYnkgdGhlIGlucHV0cyB0byB0aGUgY29uc3RydWN0b3JcbiAgICogVXNlZCBmb3Igb3ZlcnJpZGluZyBwcm9wZXJ0aWVzIG9mIHVuZGVybHlpbmcgQ0RLIGNvbnN0cnVjdHMgb3IgdG8gcmVmZXJlbmNlIGluIGN1c3RvbSBDREsgY29kZVxuICAgKi9cbiAgcmVhZG9ubHkgcmVzb3VyY2VzOiB7XG4gICAgW0sgaW4ga2V5b2YgVF06IFJldHVyblR5cGU8VFtLXVsnZ2V0SW5zdGFuY2UnXT47XG4gIH07XG5cbiAgcHJpdmF0ZSByZWFkb25seSBzdGFja1Jlc29sdmVyOiBTdGFja1Jlc29sdmVyO1xuICBwcml2YXRlIHJlYWRvbmx5IGN1c3RvbU91dHB1dHNBY2N1bXVsYXRvcjogQ3VzdG9tT3V0cHV0c0FjY3VtdWxhdG9yO1xuICAvKipcbiAgICogSW5pdGlhbGl6ZSBhbiBBbXBsaWZ5IGJhY2tlbmQgd2l0aCB0aGUgZ2l2ZW4gY29uc3RydWN0IGZhY3RvcmllcyBhbmQgaW4gdGhlIGdpdmVuIENESyBBcHAuXG4gICAqIElmIG5vIENESyBBcHAgaXMgc3BlY2lmaWVkIGEgbmV3IG9uZSBpcyBjcmVhdGVkXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb25zdHJ1Y3RGYWN0b3JpZXM6IFQsIHN0YWNrOiBTdGFjayA9IGNyZWF0ZURlZmF1bHRTdGFjaygpKSB7XG4gICAgbmV3IEF0dHJpYnV0aW9uTWV0YWRhdGFTdG9yYWdlKCkuc3RvcmVBdHRyaWJ1dGlvbk1ldGFkYXRhKFxuICAgICAgc3RhY2ssXG4gICAgICByb290U3RhY2tUeXBlSWRlbnRpZmllcixcbiAgICAgIGZpbGVVUkxUb1BhdGgobmV3IFVSTCgnLi4vcGFja2FnZS5qc29uJywgaW1wb3J0Lm1ldGEudXJsKSlcbiAgICApO1xuICAgIHRoaXMuc3RhY2tSZXNvbHZlciA9IG5ldyBOZXN0ZWRTdGFja1Jlc29sdmVyKFxuICAgICAgc3RhY2ssXG4gICAgICBuZXcgQXR0cmlidXRpb25NZXRhZGF0YVN0b3JhZ2UoKVxuICAgICk7XG5cbiAgICBjb25zdCBjb25zdHJ1Y3RDb250YWluZXIgPSBuZXcgU2luZ2xldG9uQ29uc3RydWN0Q29udGFpbmVyKFxuICAgICAgdGhpcy5zdGFja1Jlc29sdmVyXG4gICAgKTtcblxuICAgIGNvbnN0IG91dHB1dFN0b3JhZ2VTdHJhdGVneSA9IG5ldyBTdGFja01ldGFkYXRhQmFja2VuZE91dHB1dFN0b3JhZ2VTdHJhdGVneShcbiAgICAgIHN0YWNrXG4gICAgKTtcblxuICAgIHRoaXMuY3VzdG9tT3V0cHV0c0FjY3VtdWxhdG9yID0gbmV3IEN1c3RvbU91dHB1dHNBY2N1bXVsYXRvcihcbiAgICAgIG91dHB1dFN0b3JhZ2VTdHJhdGVneSxcbiAgICAgIG5ldyBPYmplY3RBY2N1bXVsYXRvcjxDbGllbnRDb25maWc+KHt9KVxuICAgICk7XG5cbiAgICBjb25zdCBiYWNrZW5kSWQgPSBnZXRCYWNrZW5kSWRlbnRpZmllcihzdGFjayk7XG4gICAgb3V0cHV0U3RvcmFnZVN0cmF0ZWd5LmFkZEJhY2tlbmRPdXRwdXRFbnRyeShwbGF0Zm9ybU91dHB1dEtleSwge1xuICAgICAgdmVyc2lvbjogJzEnLFxuICAgICAgcGF5bG9hZDoge1xuICAgICAgICBkZXBsb3ltZW50VHlwZTogYmFja2VuZElkLnR5cGUsXG4gICAgICAgIHJlZ2lvbjogc3RhY2sucmVnaW9uLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGNvbnN0IHNob3VsZEVuYWJsZUJyYW5jaExpbmtlciA9IGJhY2tlbmRJZC50eXBlID09PSAnYnJhbmNoJztcblxuICAgIGlmIChzaG91bGRFbmFibGVCcmFuY2hMaW5rZXIpIHtcbiAgICAgIG5ldyBBbXBsaWZ5QnJhbmNoTGlua2VyQ29uc3RydWN0KHN0YWNrLCBiYWNrZW5kSWQpO1xuICAgIH1cblxuICAgIGNvbnN0IGltcG9ydFBhdGhWZXJpZmllciA9IG5ldyBUb2dnbGVhYmxlSW1wb3J0UGF0aFZlcmlmaWVyKCk7XG5cbiAgICBjb25zdCByZXNvdXJjZU5hbWVWYWxpZGF0b3IgPSBuZXcgRGVmYXVsdFJlc291cmNlTmFtZVZhbGlkYXRvcigpO1xuXG4gICAgLy8gcmVnaXN0ZXIgcHJvdmlkZXJzIGJ1dCBkb24ndCBhY3R1YWxseSBleGVjdXRlIGFueXRoaW5nIHlldFxuICAgIE9iamVjdC52YWx1ZXMoY29uc3RydWN0RmFjdG9yaWVzKS5mb3JFYWNoKChmYWN0b3J5KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGZhY3RvcnkucHJvdmlkZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0cnVjdENvbnRhaW5lci5yZWdpc3RlckNvbnN0cnVjdEZhY3RvcnkoZmFjdG9yeS5wcm92aWRlcywgZmFjdG9yeSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBub3cgaW52b2tlIGFsbCB0aGUgZmFjdG9yaWVzIGFuZCBjb2xsZWN0IHRoZSBjb25zdHJ1Y3RzIGludG8gdGhpcy5yZXNvdXJjZXNcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHRoaXMucmVzb3VyY2VzID0ge30gYXMgYW55O1xuICAgIE9iamVjdC5lbnRyaWVzKGNvbnN0cnVjdEZhY3RvcmllcykuZm9yRWFjaChcbiAgICAgIChbcmVzb3VyY2VOYW1lLCBjb25zdHJ1Y3RGYWN0b3J5XSkgPT4ge1xuICAgICAgICAvLyBUaGUgdHlwZSBpbmZlcmVuY2Ugb24gdGhpcy5yZXNvdXJjZXMgaXMgbm90IGhhcHB5IGFib3V0IHRoaXMgYXNzaWdubWVudCBiZWNhdXNlIGl0IGRvZXNuJ3Qga25vdyB0aGUgZXhhY3QgdHlwZSBvZiAuZ2V0SW5zdGFuY2UoKVxuICAgICAgICAvLyBIb3dldmVyLCB0aGUgYXNzaWdubWVudCBpcyBva2F5IGJlY2F1c2Ugd2UgYXJlIGl0ZXJhdGluZyBvdmVyIHRoZSBlbnRyaWVzIG9mIGNvbnN0cnVjdEZhY3RvcmllcyBhbmQgYXNzaWduaW5nIHRoZSByZXNvdXJjZSBuYW1lIHRvIHRoZSBjb3JyZXNwb25kaW5nIGluc3RhbmNlXG4gICAgICAgIHRoaXMucmVzb3VyY2VzW3Jlc291cmNlTmFtZSBhcyBrZXlvZiBUXSA9IGNvbnN0cnVjdEZhY3RvcnkuZ2V0SW5zdGFuY2UoXG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3RydWN0Q29udGFpbmVyLFxuICAgICAgICAgICAgb3V0cHV0U3RvcmFnZVN0cmF0ZWd5LFxuICAgICAgICAgICAgaW1wb3J0UGF0aFZlcmlmaWVyLFxuICAgICAgICAgICAgcmVzb3VyY2VOYW1lVmFsaWRhdG9yLFxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICApIGFzIGFueTtcbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBDREsgc3RhY2sgd2l0aGluIHRoZSBBbXBsaWZ5IHByb2plY3QgdGhhdCBjYW4gYmUgdXNlZCBmb3IgY3JlYXRpbmcgY3VzdG9tIHJlc291cmNlcy5cbiAgICogSWYgYSBzdGFjayBoYXMgYWxyZWFkeSBiZWVuIGNyZWF0ZWQgd2l0aCBcIm5hbWVcIiB0aGVuIGFuIGVycm9yIGlzIHRocm93bi5cbiAgICovXG4gIGNyZWF0ZVN0YWNrID0gKG5hbWU6IHN0cmluZyk6IFN0YWNrID0+IHtcbiAgICByZXR1cm4gdGhpcy5zdGFja1Jlc29sdmVyLmNyZWF0ZUN1c3RvbVN0YWNrKG5hbWUpO1xuICB9O1xuXG4gIGFkZE91dHB1dCA9IChcbiAgICBjbGllbnRDb25maWdQYXJ0OiBEZWVwUGFydGlhbEFtcGxpZnlHZW5lcmF0ZWRDb25maWdzPENsaWVudENvbmZpZz5cbiAgKSA9PiB7XG4gICAgY29uc3QgeyB2ZXJzaW9uIH0gPSBjbGllbnRDb25maWdQYXJ0O1xuICAgIGlmICghdmVyc2lvbikge1xuICAgICAgY2xpZW50Q29uZmlnUGFydC52ZXJzaW9uID1cbiAgICAgICAgREVGQVVMVF9DTElFTlRfQ09ORklHX1ZFUlNJT05fRk9SX0JBQ0tFTkRfQUREX09VVFBVVDtcbiAgICB9XG4gICAgdGhpcy5jdXN0b21PdXRwdXRzQWNjdW11bGF0b3IuYWRkT3V0cHV0KGNsaWVudENvbmZpZ1BhcnQpO1xuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgQW1wbGlmeSBiYWNrZW5kIGluc3RhbmNlIGFuZCByZXR1cm5zIGl0XG4gKiBAcGFyYW0gY29uc3RydWN0RmFjdG9yaWVzIC0gbGlzdCBvZiBiYWNrZW5kIGZhY3RvcmllcyBzdWNoIGFzIHRob3NlIGNyZWF0ZWQgYnkgYGRlZmluZUF1dGhgIG9yIGBkZWZpbmVEYXRhYFxuICovXG5leHBvcnQgY29uc3QgZGVmaW5lQmFja2VuZCA9IDxUIGV4dGVuZHMgRGVmaW5lQmFja2VuZFByb3BzPihcbiAgY29uc3RydWN0RmFjdG9yaWVzOiBUXG4pOiBCYWNrZW5kPFQ+ID0+IHtcbiAgY29uc3QgYmFja2VuZCA9IG5ldyBCYWNrZW5kRmFjdG9yeShjb25zdHJ1Y3RGYWN0b3JpZXMpO1xuICByZXR1cm4ge1xuICAgIC4uLmJhY2tlbmQucmVzb3VyY2VzLFxuICAgIGNyZWF0ZVN0YWNrOiBiYWNrZW5kLmNyZWF0ZVN0YWNrLFxuICAgIGFkZE91dHB1dDogYmFja2VuZC5hZGRPdXRwdXQsXG4gIH07XG59O1xuIl19