"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObjectAccumulator = exports.ObjectAccumulatorVersionMismatchError = exports.ObjectAccumulatorPropertyAlreadyExistsError = void 0;
const lodash_mergewith_1 = __importDefault(require("lodash.mergewith"));
/**
 * This error is thrown when there's a collision in the object keys
 */
class ObjectAccumulatorPropertyAlreadyExistsError extends Error {
    key;
    existingValue;
    incomingValue;
    /**
     * Creates property already exists error.
     */
    constructor(key, existingValue, incomingValue) {
        super(`Property ${key} already exists`);
        this.key = key;
        this.existingValue = existingValue;
        this.incomingValue = incomingValue;
    }
}
exports.ObjectAccumulatorPropertyAlreadyExistsError = ObjectAccumulatorPropertyAlreadyExistsError;
/**
 * This error is thrown when partial objects with different versions are being accumulated
 */
class ObjectAccumulatorVersionMismatchError extends Error {
    existingVersion;
    newVersion;
    /**
     * Creates property already exists error.
     */
    constructor(existingVersion, newVersion) {
        super(`Version mismatch: Cannot accumulate new objects with version ${newVersion} with existing accumulated object with version ${existingVersion}`);
        this.existingVersion = existingVersion;
        this.newVersion = newVersion;
    }
}
exports.ObjectAccumulatorVersionMismatchError = ObjectAccumulatorVersionMismatchError;
/**
 * A class that can accumulate (squash merge) objects into single instance.
 */
class ObjectAccumulator {
    accumulator;
    versionKey;
    /**
     * creates object accumulator.
     */
    constructor(accumulator, versionKey = 'version') {
        this.accumulator = accumulator;
        this.versionKey = versionKey;
    }
    /**
     * Accumulate a new object part with accumulator.
     * This method throws if there is any intersection between the object parts
     * except for the versionKey, which should be the same across all object parts (nested objects included)
     * @param part a new object part to accumulate
     * @returns the accumulator object for easy chaining
     */
    accumulate = (part) => {
        (0, lodash_mergewith_1.default)(this.accumulator, part, (existingValue, incomingValue, key) => {
            if (Array.isArray(existingValue)) {
                return existingValue.concat(incomingValue);
            }
            if (existingValue && typeof existingValue !== 'object') {
                if (key === this.versionKey && existingValue !== incomingValue) {
                    throw new ObjectAccumulatorVersionMismatchError(existingValue, incomingValue);
                }
                else if (key !== this.versionKey) {
                    throw new ObjectAccumulatorPropertyAlreadyExistsError(key, existingValue, incomingValue);
                }
            }
            // returning undefined falls back to default merge algorithm
            return undefined;
        });
        return this;
    };
    getAccumulatedObject = () => {
        return this.accumulator;
    };
}
exports.ObjectAccumulator = ObjectAccumulator;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib2JqZWN0X2FjY3VtdWxhdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL29iamVjdF9hY2N1bXVsYXRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFDQSx3RUFBeUM7QUFFekM7O0dBRUc7QUFDSCxNQUFhLDJDQUE0QyxTQUFRLEtBQUs7SUFLekQ7SUFDQTtJQUNBO0lBTlg7O09BRUc7SUFDSCxZQUNXLEdBQVcsRUFDWCxhQUFzQixFQUN0QixhQUFzQjtRQUUvQixLQUFLLENBQUMsWUFBWSxHQUFHLGlCQUFpQixDQUFDLENBQUM7UUFKL0IsUUFBRyxHQUFILEdBQUcsQ0FBUTtRQUNYLGtCQUFhLEdBQWIsYUFBYSxDQUFTO1FBQ3RCLGtCQUFhLEdBQWIsYUFBYSxDQUFTO0lBR2pDLENBQUM7Q0FDRjtBQVhELGtHQVdDO0FBRUQ7O0dBRUc7QUFDSCxNQUFhLHFDQUFzQyxTQUFRLEtBQUs7SUFJekM7SUFBa0M7SUFIdkQ7O09BRUc7SUFDSCxZQUFxQixlQUF1QixFQUFXLFVBQWtCO1FBQ3ZFLEtBQUssQ0FDSCxnRUFBZ0UsVUFBVSxrREFBa0QsZUFBZSxFQUFFLENBQzlJLENBQUM7UUFIaUIsb0JBQWUsR0FBZixlQUFlLENBQVE7UUFBVyxlQUFVLEdBQVYsVUFBVSxDQUFRO0lBSXpFLENBQUM7Q0FDRjtBQVRELHNGQVNDO0FBRUQ7O0dBRUc7QUFDSCxNQUFhLGlCQUFpQjtJQUtUO0lBQ0E7SUFMbkI7O09BRUc7SUFDSCxZQUNtQixXQUFrRCxFQUNsRCxhQUFhLFNBQVM7UUFEdEIsZ0JBQVcsR0FBWCxXQUFXLENBQXVDO1FBQ2xELGVBQVUsR0FBVixVQUFVLENBQVk7SUFDdEMsQ0FBQztJQUVKOzs7Ozs7T0FNRztJQUNILFVBQVUsR0FBRyxDQUNYLElBQTJDLEVBQ3JCLEVBQUU7UUFDeEIsSUFBQSwwQkFBUyxFQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsSUFBSSxFQUFFLENBQUMsYUFBYSxFQUFFLGFBQWEsRUFBRSxHQUFHLEVBQUUsRUFBRTtZQUN0RSxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLEVBQUU7Z0JBQ2hDLE9BQU8sYUFBYSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsQ0FBQzthQUM1QztZQUNELElBQUksYUFBYSxJQUFJLE9BQU8sYUFBYSxLQUFLLFFBQVEsRUFBRTtnQkFDdEQsSUFBSSxHQUFHLEtBQUssSUFBSSxDQUFDLFVBQVUsSUFBSSxhQUFhLEtBQUssYUFBYSxFQUFFO29CQUM5RCxNQUFNLElBQUkscUNBQXFDLENBQzdDLGFBQWEsRUFDYixhQUFhLENBQ2QsQ0FBQztpQkFDSDtxQkFBTSxJQUFJLEdBQUcsS0FBSyxJQUFJLENBQUMsVUFBVSxFQUFFO29CQUNsQyxNQUFNLElBQUksMkNBQTJDLENBQ25ELEdBQUcsRUFDSCxhQUFhLEVBQ2IsYUFBYSxDQUNkLENBQUM7aUJBQ0g7YUFDRjtZQUVELDREQUE0RDtZQUM1RCxPQUFPLFNBQVMsQ0FBQztRQUNuQixDQUFDLENBQUMsQ0FBQztRQUNILE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQyxDQUFDO0lBRUYsb0JBQW9CLEdBQUcsR0FBRyxFQUFFO1FBQzFCLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQztJQUMxQixDQUFDLENBQUM7Q0FDSDtBQS9DRCw4Q0ErQ0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEZWVwUGFydGlhbEFtcGxpZnlHZW5lcmF0ZWRDb25maWdzIH0gZnJvbSAnQGF3cy1hbXBsaWZ5L3BsdWdpbi10eXBlcyc7XG5pbXBvcnQgbWVyZ2VXaXRoIGZyb20gJ2xvZGFzaC5tZXJnZXdpdGgnO1xuXG4vKipcbiAqIFRoaXMgZXJyb3IgaXMgdGhyb3duIHdoZW4gdGhlcmUncyBhIGNvbGxpc2lvbiBpbiB0aGUgb2JqZWN0IGtleXNcbiAqL1xuZXhwb3J0IGNsYXNzIE9iamVjdEFjY3VtdWxhdG9yUHJvcGVydHlBbHJlYWR5RXhpc3RzRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIHByb3BlcnR5IGFscmVhZHkgZXhpc3RzIGVycm9yLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcmVhZG9ubHkga2V5OiBzdHJpbmcsXG4gICAgcmVhZG9ubHkgZXhpc3RpbmdWYWx1ZTogdW5rbm93bixcbiAgICByZWFkb25seSBpbmNvbWluZ1ZhbHVlOiB1bmtub3duXG4gICkge1xuICAgIHN1cGVyKGBQcm9wZXJ0eSAke2tleX0gYWxyZWFkeSBleGlzdHNgKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZXJyb3IgaXMgdGhyb3duIHdoZW4gcGFydGlhbCBvYmplY3RzIHdpdGggZGlmZmVyZW50IHZlcnNpb25zIGFyZSBiZWluZyBhY2N1bXVsYXRlZFxuICovXG5leHBvcnQgY2xhc3MgT2JqZWN0QWNjdW11bGF0b3JWZXJzaW9uTWlzbWF0Y2hFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgcHJvcGVydHkgYWxyZWFkeSBleGlzdHMgZXJyb3IuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZWFkb25seSBleGlzdGluZ1ZlcnNpb246IHN0cmluZywgcmVhZG9ubHkgbmV3VmVyc2lvbjogc3RyaW5nKSB7XG4gICAgc3VwZXIoXG4gICAgICBgVmVyc2lvbiBtaXNtYXRjaDogQ2Fubm90IGFjY3VtdWxhdGUgbmV3IG9iamVjdHMgd2l0aCB2ZXJzaW9uICR7bmV3VmVyc2lvbn0gd2l0aCBleGlzdGluZyBhY2N1bXVsYXRlZCBvYmplY3Qgd2l0aCB2ZXJzaW9uICR7ZXhpc3RpbmdWZXJzaW9ufWBcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogQSBjbGFzcyB0aGF0IGNhbiBhY2N1bXVsYXRlIChzcXVhc2ggbWVyZ2UpIG9iamVjdHMgaW50byBzaW5nbGUgaW5zdGFuY2UuXG4gKi9cbmV4cG9ydCBjbGFzcyBPYmplY3RBY2N1bXVsYXRvcjxUPiB7XG4gIC8qKlxuICAgKiBjcmVhdGVzIG9iamVjdCBhY2N1bXVsYXRvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgYWNjdW11bGF0b3I6IERlZXBQYXJ0aWFsQW1wbGlmeUdlbmVyYXRlZENvbmZpZ3M8VD4sXG4gICAgcHJpdmF0ZSByZWFkb25seSB2ZXJzaW9uS2V5ID0gJ3ZlcnNpb24nXG4gICkge31cblxuICAvKipcbiAgICogQWNjdW11bGF0ZSBhIG5ldyBvYmplY3QgcGFydCB3aXRoIGFjY3VtdWxhdG9yLlxuICAgKiBUaGlzIG1ldGhvZCB0aHJvd3MgaWYgdGhlcmUgaXMgYW55IGludGVyc2VjdGlvbiBiZXR3ZWVuIHRoZSBvYmplY3QgcGFydHNcbiAgICogZXhjZXB0IGZvciB0aGUgdmVyc2lvbktleSwgd2hpY2ggc2hvdWxkIGJlIHRoZSBzYW1lIGFjcm9zcyBhbGwgb2JqZWN0IHBhcnRzIChuZXN0ZWQgb2JqZWN0cyBpbmNsdWRlZClcbiAgICogQHBhcmFtIHBhcnQgYSBuZXcgb2JqZWN0IHBhcnQgdG8gYWNjdW11bGF0ZVxuICAgKiBAcmV0dXJucyB0aGUgYWNjdW11bGF0b3Igb2JqZWN0IGZvciBlYXN5IGNoYWluaW5nXG4gICAqL1xuICBhY2N1bXVsYXRlID0gKFxuICAgIHBhcnQ6IERlZXBQYXJ0aWFsQW1wbGlmeUdlbmVyYXRlZENvbmZpZ3M8VD5cbiAgKTogT2JqZWN0QWNjdW11bGF0b3I8VD4gPT4ge1xuICAgIG1lcmdlV2l0aCh0aGlzLmFjY3VtdWxhdG9yLCBwYXJ0LCAoZXhpc3RpbmdWYWx1ZSwgaW5jb21pbmdWYWx1ZSwga2V5KSA9PiB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShleGlzdGluZ1ZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZXhpc3RpbmdWYWx1ZS5jb25jYXQoaW5jb21pbmdWYWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoZXhpc3RpbmdWYWx1ZSAmJiB0eXBlb2YgZXhpc3RpbmdWYWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gdGhpcy52ZXJzaW9uS2V5ICYmIGV4aXN0aW5nVmFsdWUgIT09IGluY29taW5nVmFsdWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgT2JqZWN0QWNjdW11bGF0b3JWZXJzaW9uTWlzbWF0Y2hFcnJvcihcbiAgICAgICAgICAgIGV4aXN0aW5nVmFsdWUsXG4gICAgICAgICAgICBpbmNvbWluZ1ZhbHVlXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgIT09IHRoaXMudmVyc2lvbktleSkge1xuICAgICAgICAgIHRocm93IG5ldyBPYmplY3RBY2N1bXVsYXRvclByb3BlcnR5QWxyZWFkeUV4aXN0c0Vycm9yKFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgZXhpc3RpbmdWYWx1ZSxcbiAgICAgICAgICAgIGluY29taW5nVmFsdWVcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHJldHVybmluZyB1bmRlZmluZWQgZmFsbHMgYmFjayB0byBkZWZhdWx0IG1lcmdlIGFsZ29yaXRobVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBnZXRBY2N1bXVsYXRlZE9iamVjdCA9ICgpID0+IHtcbiAgICByZXR1cm4gdGhpcy5hY2N1bXVsYXRvcjtcbiAgfTtcbn1cbiJdfQ==