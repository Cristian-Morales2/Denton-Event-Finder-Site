"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BackendIdentifierConversions = void 0;
const crypto_1 = require("crypto");
const STACK_NAME_LENGTH_LIMIT = 128;
const AMPLIFY_PREFIX = 'amplify';
const HASH_LENGTH = 10;
const NUM_DASHES = 4;
/**
 * Provides static methods for converting BackendIdentifier to/from a stack name string
 */
class BackendIdentifierConversions {
    /**
     * Convert a stack name to a BackendIdentifier
     *
     * If the stack name is ambiguous, undefined is returned
     */
    static fromStackName(stackName) {
        if (!stackName) {
            return;
        }
        const parts = stackName.split('-');
        if (parts.length !== 5) {
            return;
        }
        const [prefix, namespace, instance, type, hash] = parts;
        if (prefix !== AMPLIFY_PREFIX) {
            return;
        }
        if (type !== 'sandbox' && type !== 'branch') {
            return;
        }
        return {
            namespace,
            name: instance,
            type: type,
            hash,
        };
    }
    /**
     * Convert a BackendIdentifier to a stack name.
     *
     * !!!DANGER!!!
     * !!!DO NOT CHANGE THIS UNLESS YOU ARE 100% SURE YOU UNDERSTAND THE CONSEQUENCES!!!
     *
     * Changing this method will change how stack names are generated which could be a massive breaking change for existing Amplify stacks.
     */
    static toStackName(backendId) {
        const hash = getHash(backendId);
        // only take the first 50 chars here to make sure there is room in the stack name for the namespace as well
        const name = sanitizeChars(backendId.name).slice(0, 50);
        const namespaceMaxLength = STACK_NAME_LENGTH_LIMIT -
            AMPLIFY_PREFIX.length -
            backendId.type.length -
            name.length -
            NUM_DASHES -
            HASH_LENGTH;
        const namespace = sanitizeChars(backendId.namespace).slice(0, namespaceMaxLength - 1);
        return ['amplify', namespace, name, backendId.type, hash].join('-');
    }
}
exports.BackendIdentifierConversions = BackendIdentifierConversions;
/**
 * Gets a stable hash from the namespace and name in the backendId.
 *
 * If the backendId already includes a hash, this hash is returned as-is.
 *
 * !!!DANGER!!!
 * !!!DO NOT CHANGE THIS UNLESS YOU ARE 100% SURE YOU UNDERSTAND THE CONSEQUENCES!!!
 *
 * Changing this hash algorithm will change how stack names are generated which would be a massive breaking change for existing Amplify stacks.
 */
const getHash = (backendId) => backendId.hash ??
    // md5 would be sufficient here because this hash does not need to be cryptographically secure, but this ensures that we don't get unnecessarily flagged by some security scanner
    (0, crypto_1.createHash)('sha512')
        .update(backendId.namespace)
        .update(backendId.name)
        .digest('hex')
        .slice(0, HASH_LENGTH);
/**
 * Remove all non-alphanumeric characters from the input string
 */
const sanitizeChars = (str) => {
    return str.replace(/[^A-Za-z0-9]/g, '');
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFja2VuZF9pZGVudGlmaWVyX2NvbnZlcnNpb25zLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2JhY2tlbmRfaWRlbnRpZmllcl9jb252ZXJzaW9ucy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFDQSxtQ0FBb0M7QUFFcEMsTUFBTSx1QkFBdUIsR0FBRyxHQUFHLENBQUM7QUFDcEMsTUFBTSxjQUFjLEdBQUcsU0FBUyxDQUFDO0FBQ2pDLE1BQU0sV0FBVyxHQUFHLEVBQUUsQ0FBQztBQUN2QixNQUFNLFVBQVUsR0FBRyxDQUFDLENBQUM7QUFFckI7O0dBRUc7QUFDSCxNQUFhLDRCQUE0QjtJQUN2Qzs7OztPQUlHO0lBQ0gsTUFBTSxDQUFDLGFBQWEsQ0FBQyxTQUFrQjtRQUNyQyxJQUFJLENBQUMsU0FBUyxFQUFFO1lBQ2QsT0FBTztTQUNSO1FBQ0QsTUFBTSxLQUFLLEdBQUcsU0FBUyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNuQyxJQUFJLEtBQUssQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQ3RCLE9BQU87U0FDUjtRQUNELE1BQU0sQ0FBQyxNQUFNLEVBQUUsU0FBUyxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDO1FBQ3hELElBQUksTUFBTSxLQUFLLGNBQWMsRUFBRTtZQUM3QixPQUFPO1NBQ1I7UUFDRCxJQUFJLElBQUksS0FBSyxTQUFTLElBQUksSUFBSSxLQUFLLFFBQVEsRUFBRTtZQUMzQyxPQUFPO1NBQ1I7UUFFRCxPQUFPO1lBQ0wsU0FBUztZQUNULElBQUksRUFBRSxRQUFRO1lBQ2QsSUFBSSxFQUFFLElBQTRCO1lBQ2xDLElBQUk7U0FDTCxDQUFDO0lBQ0osQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSCxNQUFNLENBQUMsV0FBVyxDQUFDLFNBQTRCO1FBQzdDLE1BQU0sSUFBSSxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUVoQywyR0FBMkc7UUFDM0csTUFBTSxJQUFJLEdBQUcsYUFBYSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBRXhELE1BQU0sa0JBQWtCLEdBQ3RCLHVCQUF1QjtZQUN2QixjQUFjLENBQUMsTUFBTTtZQUNyQixTQUFTLENBQUMsSUFBSSxDQUFDLE1BQU07WUFDckIsSUFBSSxDQUFDLE1BQU07WUFDWCxVQUFVO1lBQ1YsV0FBVyxDQUFDO1FBRWQsTUFBTSxTQUFTLEdBQUcsYUFBYSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxLQUFLLENBQ3hELENBQUMsRUFDRCxrQkFBa0IsR0FBRyxDQUFDLENBQ3ZCLENBQUM7UUFFRixPQUFPLENBQUMsU0FBUyxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsU0FBUyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDdEUsQ0FBQztDQUNGO0FBM0RELG9FQTJEQztBQUVEOzs7Ozs7Ozs7R0FTRztBQUNILE1BQU0sT0FBTyxHQUFHLENBQUMsU0FBNEIsRUFBVSxFQUFFLENBQ3ZELFNBQVMsQ0FBQyxJQUFJO0lBQ2QsaUxBQWlMO0lBQ2pMLElBQUEsbUJBQVUsRUFBQyxRQUFRLENBQUM7U0FDakIsTUFBTSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUM7U0FDM0IsTUFBTSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUM7U0FDdEIsTUFBTSxDQUFDLEtBQUssQ0FBQztTQUNiLEtBQUssQ0FBQyxDQUFDLEVBQUUsV0FBVyxDQUFDLENBQUM7QUFFM0I7O0dBRUc7QUFDSCxNQUFNLGFBQWEsR0FBRyxDQUFDLEdBQVcsRUFBVSxFQUFFO0lBQzVDLE9BQU8sR0FBRyxDQUFDLE9BQU8sQ0FBQyxlQUFlLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFDMUMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFja2VuZElkZW50aWZpZXIgfSBmcm9tICdAYXdzLWFtcGxpZnkvcGx1Z2luLXR5cGVzJztcbmltcG9ydCB7IGNyZWF0ZUhhc2ggfSBmcm9tICdjcnlwdG8nO1xuXG5jb25zdCBTVEFDS19OQU1FX0xFTkdUSF9MSU1JVCA9IDEyODtcbmNvbnN0IEFNUExJRllfUFJFRklYID0gJ2FtcGxpZnknO1xuY29uc3QgSEFTSF9MRU5HVEggPSAxMDtcbmNvbnN0IE5VTV9EQVNIRVMgPSA0O1xuXG4vKipcbiAqIFByb3ZpZGVzIHN0YXRpYyBtZXRob2RzIGZvciBjb252ZXJ0aW5nIEJhY2tlbmRJZGVudGlmaWVyIHRvL2Zyb20gYSBzdGFjayBuYW1lIHN0cmluZ1xuICovXG5leHBvcnQgY2xhc3MgQmFja2VuZElkZW50aWZpZXJDb252ZXJzaW9ucyB7XG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgc3RhY2sgbmFtZSB0byBhIEJhY2tlbmRJZGVudGlmaWVyXG4gICAqXG4gICAqIElmIHRoZSBzdGFjayBuYW1lIGlzIGFtYmlndW91cywgdW5kZWZpbmVkIGlzIHJldHVybmVkXG4gICAqL1xuICBzdGF0aWMgZnJvbVN0YWNrTmFtZShzdGFja05hbWU/OiBzdHJpbmcpOiBCYWNrZW5kSWRlbnRpZmllciB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKCFzdGFja05hbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcGFydHMgPSBzdGFja05hbWUuc3BsaXQoJy0nKTtcbiAgICBpZiAocGFydHMubGVuZ3RoICE9PSA1KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IFtwcmVmaXgsIG5hbWVzcGFjZSwgaW5zdGFuY2UsIHR5cGUsIGhhc2hdID0gcGFydHM7XG4gICAgaWYgKHByZWZpeCAhPT0gQU1QTElGWV9QUkVGSVgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGUgIT09ICdzYW5kYm94JyAmJiB0eXBlICE9PSAnYnJhbmNoJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBuYW1lc3BhY2UsXG4gICAgICBuYW1lOiBpbnN0YW5jZSxcbiAgICAgIHR5cGU6IHR5cGUgYXMgJ3NhbmRib3gnIHwgJ2JyYW5jaCcsXG4gICAgICBoYXNoLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBhIEJhY2tlbmRJZGVudGlmaWVyIHRvIGEgc3RhY2sgbmFtZS5cbiAgICpcbiAgICogISEhREFOR0VSISEhXG4gICAqICEhIURPIE5PVCBDSEFOR0UgVEhJUyBVTkxFU1MgWU9VIEFSRSAxMDAlIFNVUkUgWU9VIFVOREVSU1RBTkQgVEhFIENPTlNFUVVFTkNFUyEhIVxuICAgKlxuICAgKiBDaGFuZ2luZyB0aGlzIG1ldGhvZCB3aWxsIGNoYW5nZSBob3cgc3RhY2sgbmFtZXMgYXJlIGdlbmVyYXRlZCB3aGljaCBjb3VsZCBiZSBhIG1hc3NpdmUgYnJlYWtpbmcgY2hhbmdlIGZvciBleGlzdGluZyBBbXBsaWZ5IHN0YWNrcy5cbiAgICovXG4gIHN0YXRpYyB0b1N0YWNrTmFtZShiYWNrZW5kSWQ6IEJhY2tlbmRJZGVudGlmaWVyKTogc3RyaW5nIHtcbiAgICBjb25zdCBoYXNoID0gZ2V0SGFzaChiYWNrZW5kSWQpO1xuXG4gICAgLy8gb25seSB0YWtlIHRoZSBmaXJzdCA1MCBjaGFycyBoZXJlIHRvIG1ha2Ugc3VyZSB0aGVyZSBpcyByb29tIGluIHRoZSBzdGFjayBuYW1lIGZvciB0aGUgbmFtZXNwYWNlIGFzIHdlbGxcbiAgICBjb25zdCBuYW1lID0gc2FuaXRpemVDaGFycyhiYWNrZW5kSWQubmFtZSkuc2xpY2UoMCwgNTApO1xuXG4gICAgY29uc3QgbmFtZXNwYWNlTWF4TGVuZ3RoID1cbiAgICAgIFNUQUNLX05BTUVfTEVOR1RIX0xJTUlUIC1cbiAgICAgIEFNUExJRllfUFJFRklYLmxlbmd0aCAtXG4gICAgICBiYWNrZW5kSWQudHlwZS5sZW5ndGggLVxuICAgICAgbmFtZS5sZW5ndGggLVxuICAgICAgTlVNX0RBU0hFUyAtXG4gICAgICBIQVNIX0xFTkdUSDtcblxuICAgIGNvbnN0IG5hbWVzcGFjZSA9IHNhbml0aXplQ2hhcnMoYmFja2VuZElkLm5hbWVzcGFjZSkuc2xpY2UoXG4gICAgICAwLFxuICAgICAgbmFtZXNwYWNlTWF4TGVuZ3RoIC0gMVxuICAgICk7XG5cbiAgICByZXR1cm4gWydhbXBsaWZ5JywgbmFtZXNwYWNlLCBuYW1lLCBiYWNrZW5kSWQudHlwZSwgaGFzaF0uam9pbignLScpO1xuICB9XG59XG5cbi8qKlxuICogR2V0cyBhIHN0YWJsZSBoYXNoIGZyb20gdGhlIG5hbWVzcGFjZSBhbmQgbmFtZSBpbiB0aGUgYmFja2VuZElkLlxuICpcbiAqIElmIHRoZSBiYWNrZW5kSWQgYWxyZWFkeSBpbmNsdWRlcyBhIGhhc2gsIHRoaXMgaGFzaCBpcyByZXR1cm5lZCBhcy1pcy5cbiAqXG4gKiAhISFEQU5HRVIhISFcbiAqICEhIURPIE5PVCBDSEFOR0UgVEhJUyBVTkxFU1MgWU9VIEFSRSAxMDAlIFNVUkUgWU9VIFVOREVSU1RBTkQgVEhFIENPTlNFUVVFTkNFUyEhIVxuICpcbiAqIENoYW5naW5nIHRoaXMgaGFzaCBhbGdvcml0aG0gd2lsbCBjaGFuZ2UgaG93IHN0YWNrIG5hbWVzIGFyZSBnZW5lcmF0ZWQgd2hpY2ggd291bGQgYmUgYSBtYXNzaXZlIGJyZWFraW5nIGNoYW5nZSBmb3IgZXhpc3RpbmcgQW1wbGlmeSBzdGFja3MuXG4gKi9cbmNvbnN0IGdldEhhc2ggPSAoYmFja2VuZElkOiBCYWNrZW5kSWRlbnRpZmllcik6IHN0cmluZyA9PlxuICBiYWNrZW5kSWQuaGFzaCA/P1xuICAvLyBtZDUgd291bGQgYmUgc3VmZmljaWVudCBoZXJlIGJlY2F1c2UgdGhpcyBoYXNoIGRvZXMgbm90IG5lZWQgdG8gYmUgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlLCBidXQgdGhpcyBlbnN1cmVzIHRoYXQgd2UgZG9uJ3QgZ2V0IHVubmVjZXNzYXJpbHkgZmxhZ2dlZCBieSBzb21lIHNlY3VyaXR5IHNjYW5uZXJcbiAgY3JlYXRlSGFzaCgnc2hhNTEyJylcbiAgICAudXBkYXRlKGJhY2tlbmRJZC5uYW1lc3BhY2UpXG4gICAgLnVwZGF0ZShiYWNrZW5kSWQubmFtZSlcbiAgICAuZGlnZXN0KCdoZXgnKVxuICAgIC5zbGljZSgwLCBIQVNIX0xFTkdUSCk7XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBub24tYWxwaGFudW1lcmljIGNoYXJhY3RlcnMgZnJvbSB0aGUgaW5wdXQgc3RyaW5nXG4gKi9cbmNvbnN0IHNhbml0aXplQ2hhcnMgPSAoc3RyOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1teQS1aYS16MC05XS9nLCAnJyk7XG59O1xuIl19