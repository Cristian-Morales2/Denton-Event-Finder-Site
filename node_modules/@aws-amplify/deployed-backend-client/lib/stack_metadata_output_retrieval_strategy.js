import { DescribeStacksCommand, GetTemplateSummaryCommand, } from '@aws-sdk/client-cloudformation';
import { backendOutputStackMetadataSchema } from '@aws-amplify/backend-output-schemas';
import { BackendOutputClientError, BackendOutputClientErrorType, } from './index.js';
/**
 * Gets Amplify backend outputs from stack metadata and outputs
 */
export class StackMetadataBackendOutputRetrievalStrategy {
    cfnClient;
    stackNameResolver;
    /**
     * Instantiate with a CloudFormationClient and a StackNameResolver
     */
    constructor(cfnClient, stackNameResolver) {
        this.cfnClient = cfnClient;
        this.stackNameResolver = stackNameResolver;
    }
    /**
     * Resolves the stackName, then queries CFN for the stack metadata and outputs
     *
     * It combines the metadata and outputs to reconstruct the data object that was provided by the Amplify constructs when writing the output.
     * Except now the data contains the resolved values of the deployed resources rather than CFN references
     */
    fetchBackendOutput = async () => {
        const stackName = await this.stackNameResolver.resolveMainStackName();
        // GetTemplateSummary includes the template metadata as a string
        const templateSummary = await this.cfnClient.send(new GetTemplateSummaryCommand({ StackName: stackName }));
        if (typeof templateSummary.Metadata !== 'string') {
            throw new BackendOutputClientError(BackendOutputClientErrorType.METADATA_RETRIEVAL_ERROR, 'Stack template metadata is not a string');
        }
        const metadataObject = JSON.parse(templateSummary.Metadata);
        // parse and validate the metadata object
        const backendOutputMetadata = backendOutputStackMetadataSchema.parse(metadataObject);
        // DescribeStacks includes the template output
        const stackDescription = await this.cfnClient.send(new DescribeStacksCommand({ StackName: stackName }));
        const outputs = stackDescription?.Stacks?.[0]?.Outputs;
        if (stackDescription.Stacks?.[0].StackStatus?.endsWith('_IN_PROGRESS')) {
            const deploymentType = stackDescription.Stacks?.[0].Tags?.find((tag) => tag.Key === 'amplify:deployment-type')?.Value ?? 'sandbox';
            throw new BackendOutputClientError(BackendOutputClientErrorType.METADATA_RETRIEVAL_ERROR, `This ${deploymentType} deployment is in progress. Re-run this command once the deployment completes.`);
        }
        if (outputs === undefined) {
            throw new BackendOutputClientError(BackendOutputClientErrorType.METADATA_RETRIEVAL_ERROR, 'Stack outputs are undefined');
        }
        // outputs is a list of output entries. here we turn that into a Record<name, value> object
        const stackOutputRecord = outputs
            .filter((output) => !!output.OutputValue && !!output.OutputKey)
            .reduce((accumulator, outputEntry) => ({
            ...accumulator,
            // it's safe to disable this rule because we've already filtered out potentially undefined outputs
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            [outputEntry.OutputKey]: outputEntry.OutputValue,
        }), {});
        // now we iterate over the metadata entries and reconstruct the data object based on the stackOutputs that each construct package set
        const result = {};
        Object.entries(backendOutputMetadata).forEach(([outputKeyName, entry]) => {
            const outputData = entry.stackOutputs.reduce((accumulator, outputName) => {
                if (stackOutputRecord[outputName] === undefined ||
                    stackOutputRecord[outputName] === '') {
                    return accumulator;
                }
                return {
                    ...accumulator,
                    [outputName]: stackOutputRecord[outputName],
                };
            }, {});
            result[outputKeyName] = {
                version: entry.version,
                payload: outputData,
            };
        });
        return result;
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhY2tfbWV0YWRhdGFfb3V0cHV0X3JldHJpZXZhbF9zdHJhdGVneS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9zdGFja19tZXRhZGF0YV9vdXRwdXRfcmV0cmlldmFsX3N0cmF0ZWd5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFFTCxxQkFBcUIsRUFDckIseUJBQXlCLEdBQzFCLE1BQU0sZ0NBQWdDLENBQUM7QUFNeEMsT0FBTyxFQUFFLGdDQUFnQyxFQUFFLE1BQU0scUNBQXFDLENBQUM7QUFDdkYsT0FBTyxFQUNMLHdCQUF3QixFQUN4Qiw0QkFBNEIsR0FDN0IsTUFBTSxZQUFZLENBQUM7QUFFcEI7O0dBRUc7QUFDSCxNQUFNLE9BQU8sMkNBQTJDO0lBT25DO0lBQ0E7SUFMbkI7O09BRUc7SUFDSCxZQUNtQixTQUErQixFQUMvQixpQkFBd0M7UUFEeEMsY0FBUyxHQUFULFNBQVMsQ0FBc0I7UUFDL0Isc0JBQWlCLEdBQWpCLGlCQUFpQixDQUF1QjtJQUN4RCxDQUFDO0lBRUo7Ozs7O09BS0c7SUFDSCxrQkFBa0IsR0FBRyxLQUFLLElBQTRCLEVBQUU7UUFDdEQsTUFBTSxTQUFTLEdBQUcsTUFBTSxJQUFJLENBQUMsaUJBQWlCLENBQUMsb0JBQW9CLEVBQUUsQ0FBQztRQUV0RSxnRUFBZ0U7UUFDaEUsTUFBTSxlQUFlLEdBQUcsTUFBTSxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FDL0MsSUFBSSx5QkFBeUIsQ0FBQyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsQ0FBQyxDQUN4RCxDQUFDO1FBQ0YsSUFBSSxPQUFPLGVBQWUsQ0FBQyxRQUFRLEtBQUssUUFBUSxFQUFFO1lBQ2hELE1BQU0sSUFBSSx3QkFBd0IsQ0FDaEMsNEJBQTRCLENBQUMsd0JBQXdCLEVBQ3JELHlDQUF5QyxDQUMxQyxDQUFDO1NBQ0g7UUFFRCxNQUFNLGNBQWMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLGVBQWUsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUU1RCx5Q0FBeUM7UUFDekMsTUFBTSxxQkFBcUIsR0FDekIsZ0NBQWdDLENBQUMsS0FBSyxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBRXpELDhDQUE4QztRQUM5QyxNQUFNLGdCQUFnQixHQUFHLE1BQU0sSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQ2hELElBQUkscUJBQXFCLENBQUMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLENBQUMsQ0FDcEQsQ0FBQztRQUVGLE1BQU0sT0FBTyxHQUFHLGdCQUFnQixFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQztRQUN2RCxJQUFJLGdCQUFnQixDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxRQUFRLENBQUMsY0FBYyxDQUFDLEVBQUU7WUFDdEUsTUFBTSxjQUFjLEdBQ2xCLGdCQUFnQixDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxJQUFJLENBQ3JDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsR0FBRyxLQUFLLHlCQUF5QixDQUMvQyxFQUFFLEtBQUssSUFBSSxTQUFTLENBQUM7WUFDeEIsTUFBTSxJQUFJLHdCQUF3QixDQUNoQyw0QkFBNEIsQ0FBQyx3QkFBd0IsRUFDckQsUUFBUSxjQUFjLGdGQUFnRixDQUN2RyxDQUFDO1NBQ0g7UUFDRCxJQUFJLE9BQU8sS0FBSyxTQUFTLEVBQUU7WUFDekIsTUFBTSxJQUFJLHdCQUF3QixDQUNoQyw0QkFBNEIsQ0FBQyx3QkFBd0IsRUFDckQsNkJBQTZCLENBQzlCLENBQUM7U0FDSDtRQUVELDJGQUEyRjtRQUMzRixNQUFNLGlCQUFpQixHQUFHLE9BQU87YUFDOUIsTUFBTSxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFdBQVcsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQzthQUM5RCxNQUFNLENBQ0wsQ0FBQyxXQUFXLEVBQUUsV0FBVyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBQzdCLEdBQUcsV0FBVztZQUNkLGtHQUFrRztZQUNsRyxvRUFBb0U7WUFDcEUsQ0FBQyxXQUFXLENBQUMsU0FBVSxDQUFDLEVBQUUsV0FBVyxDQUFDLFdBQVk7U0FDbkQsQ0FBQyxFQUNGLEVBQTRCLENBQzdCLENBQUM7UUFFSixxSUFBcUk7UUFDckksTUFBTSxNQUFNLEdBQWtCLEVBQUUsQ0FBQztRQUNqQyxNQUFNLENBQUMsT0FBTyxDQUFDLHFCQUFxQixDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxhQUFhLEVBQUUsS0FBSyxDQUFDLEVBQUUsRUFBRTtZQUN2RSxNQUFNLFVBQVUsR0FBRyxLQUFLLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FDMUMsQ0FBQyxXQUFXLEVBQUUsVUFBVSxFQUFFLEVBQUU7Z0JBQzFCLElBQ0UsaUJBQWlCLENBQUMsVUFBVSxDQUFDLEtBQUssU0FBUztvQkFDM0MsaUJBQWlCLENBQUMsVUFBVSxDQUFDLEtBQUssRUFBRSxFQUNwQztvQkFDQSxPQUFPLFdBQVcsQ0FBQztpQkFDcEI7Z0JBQ0QsT0FBTztvQkFDTCxHQUFHLFdBQVc7b0JBQ2QsQ0FBQyxVQUFVLENBQUMsRUFBRSxpQkFBaUIsQ0FBQyxVQUFVLENBQUM7aUJBQzVDLENBQUM7WUFDSixDQUFDLEVBQ0QsRUFBNEIsQ0FDN0IsQ0FBQztZQUNGLE1BQU0sQ0FBQyxhQUFhLENBQUMsR0FBRztnQkFDdEIsT0FBTyxFQUFFLEtBQUssQ0FBQyxPQUFPO2dCQUN0QixPQUFPLEVBQUUsVUFBVTthQUNwQixDQUFDO1FBQ0osQ0FBQyxDQUFDLENBQUM7UUFDSCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDLENBQUM7Q0FDSCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENsb3VkRm9ybWF0aW9uQ2xpZW50LFxuICBEZXNjcmliZVN0YWNrc0NvbW1hbmQsXG4gIEdldFRlbXBsYXRlU3VtbWFyeUNvbW1hbmQsXG59IGZyb20gJ0Bhd3Mtc2RrL2NsaWVudC1jbG91ZGZvcm1hdGlvbic7XG5pbXBvcnQge1xuICBCYWNrZW5kT3V0cHV0LFxuICBCYWNrZW5kT3V0cHV0UmV0cmlldmFsU3RyYXRlZ3ksXG4gIE1haW5TdGFja05hbWVSZXNvbHZlcixcbn0gZnJvbSAnQGF3cy1hbXBsaWZ5L3BsdWdpbi10eXBlcyc7XG5pbXBvcnQgeyBiYWNrZW5kT3V0cHV0U3RhY2tNZXRhZGF0YVNjaGVtYSB9IGZyb20gJ0Bhd3MtYW1wbGlmeS9iYWNrZW5kLW91dHB1dC1zY2hlbWFzJztcbmltcG9ydCB7XG4gIEJhY2tlbmRPdXRwdXRDbGllbnRFcnJvcixcbiAgQmFja2VuZE91dHB1dENsaWVudEVycm9yVHlwZSxcbn0gZnJvbSAnLi9pbmRleC5qcyc7XG5cbi8qKlxuICogR2V0cyBBbXBsaWZ5IGJhY2tlbmQgb3V0cHV0cyBmcm9tIHN0YWNrIG1ldGFkYXRhIGFuZCBvdXRwdXRzXG4gKi9cbmV4cG9ydCBjbGFzcyBTdGFja01ldGFkYXRhQmFja2VuZE91dHB1dFJldHJpZXZhbFN0cmF0ZWd5XG4gIGltcGxlbWVudHMgQmFja2VuZE91dHB1dFJldHJpZXZhbFN0cmF0ZWd5XG57XG4gIC8qKlxuICAgKiBJbnN0YW50aWF0ZSB3aXRoIGEgQ2xvdWRGb3JtYXRpb25DbGllbnQgYW5kIGEgU3RhY2tOYW1lUmVzb2x2ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgY2ZuQ2xpZW50OiBDbG91ZEZvcm1hdGlvbkNsaWVudCxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHN0YWNrTmFtZVJlc29sdmVyOiBNYWluU3RhY2tOYW1lUmVzb2x2ZXJcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlcyB0aGUgc3RhY2tOYW1lLCB0aGVuIHF1ZXJpZXMgQ0ZOIGZvciB0aGUgc3RhY2sgbWV0YWRhdGEgYW5kIG91dHB1dHNcbiAgICpcbiAgICogSXQgY29tYmluZXMgdGhlIG1ldGFkYXRhIGFuZCBvdXRwdXRzIHRvIHJlY29uc3RydWN0IHRoZSBkYXRhIG9iamVjdCB0aGF0IHdhcyBwcm92aWRlZCBieSB0aGUgQW1wbGlmeSBjb25zdHJ1Y3RzIHdoZW4gd3JpdGluZyB0aGUgb3V0cHV0LlxuICAgKiBFeGNlcHQgbm93IHRoZSBkYXRhIGNvbnRhaW5zIHRoZSByZXNvbHZlZCB2YWx1ZXMgb2YgdGhlIGRlcGxveWVkIHJlc291cmNlcyByYXRoZXIgdGhhbiBDRk4gcmVmZXJlbmNlc1xuICAgKi9cbiAgZmV0Y2hCYWNrZW5kT3V0cHV0ID0gYXN5bmMgKCk6IFByb21pc2U8QmFja2VuZE91dHB1dD4gPT4ge1xuICAgIGNvbnN0IHN0YWNrTmFtZSA9IGF3YWl0IHRoaXMuc3RhY2tOYW1lUmVzb2x2ZXIucmVzb2x2ZU1haW5TdGFja05hbWUoKTtcblxuICAgIC8vIEdldFRlbXBsYXRlU3VtbWFyeSBpbmNsdWRlcyB0aGUgdGVtcGxhdGUgbWV0YWRhdGEgYXMgYSBzdHJpbmdcbiAgICBjb25zdCB0ZW1wbGF0ZVN1bW1hcnkgPSBhd2FpdCB0aGlzLmNmbkNsaWVudC5zZW5kKFxuICAgICAgbmV3IEdldFRlbXBsYXRlU3VtbWFyeUNvbW1hbmQoeyBTdGFja05hbWU6IHN0YWNrTmFtZSB9KVxuICAgICk7XG4gICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZVN1bW1hcnkuTWV0YWRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgQmFja2VuZE91dHB1dENsaWVudEVycm9yKFxuICAgICAgICBCYWNrZW5kT3V0cHV0Q2xpZW50RXJyb3JUeXBlLk1FVEFEQVRBX1JFVFJJRVZBTF9FUlJPUixcbiAgICAgICAgJ1N0YWNrIHRlbXBsYXRlIG1ldGFkYXRhIGlzIG5vdCBhIHN0cmluZydcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgbWV0YWRhdGFPYmplY3QgPSBKU09OLnBhcnNlKHRlbXBsYXRlU3VtbWFyeS5NZXRhZGF0YSk7XG5cbiAgICAvLyBwYXJzZSBhbmQgdmFsaWRhdGUgdGhlIG1ldGFkYXRhIG9iamVjdFxuICAgIGNvbnN0IGJhY2tlbmRPdXRwdXRNZXRhZGF0YSA9XG4gICAgICBiYWNrZW5kT3V0cHV0U3RhY2tNZXRhZGF0YVNjaGVtYS5wYXJzZShtZXRhZGF0YU9iamVjdCk7XG5cbiAgICAvLyBEZXNjcmliZVN0YWNrcyBpbmNsdWRlcyB0aGUgdGVtcGxhdGUgb3V0cHV0XG4gICAgY29uc3Qgc3RhY2tEZXNjcmlwdGlvbiA9IGF3YWl0IHRoaXMuY2ZuQ2xpZW50LnNlbmQoXG4gICAgICBuZXcgRGVzY3JpYmVTdGFja3NDb21tYW5kKHsgU3RhY2tOYW1lOiBzdGFja05hbWUgfSlcbiAgICApO1xuXG4gICAgY29uc3Qgb3V0cHV0cyA9IHN0YWNrRGVzY3JpcHRpb24/LlN0YWNrcz8uWzBdPy5PdXRwdXRzO1xuICAgIGlmIChzdGFja0Rlc2NyaXB0aW9uLlN0YWNrcz8uWzBdLlN0YWNrU3RhdHVzPy5lbmRzV2l0aCgnX0lOX1BST0dSRVNTJykpIHtcbiAgICAgIGNvbnN0IGRlcGxveW1lbnRUeXBlID1cbiAgICAgICAgc3RhY2tEZXNjcmlwdGlvbi5TdGFja3M/LlswXS5UYWdzPy5maW5kKFxuICAgICAgICAgICh0YWcpID0+IHRhZy5LZXkgPT09ICdhbXBsaWZ5OmRlcGxveW1lbnQtdHlwZSdcbiAgICAgICAgKT8uVmFsdWUgPz8gJ3NhbmRib3gnO1xuICAgICAgdGhyb3cgbmV3IEJhY2tlbmRPdXRwdXRDbGllbnRFcnJvcihcbiAgICAgICAgQmFja2VuZE91dHB1dENsaWVudEVycm9yVHlwZS5NRVRBREFUQV9SRVRSSUVWQUxfRVJST1IsXG4gICAgICAgIGBUaGlzICR7ZGVwbG95bWVudFR5cGV9IGRlcGxveW1lbnQgaXMgaW4gcHJvZ3Jlc3MuIFJlLXJ1biB0aGlzIGNvbW1hbmQgb25jZSB0aGUgZGVwbG95bWVudCBjb21wbGV0ZXMuYFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKG91dHB1dHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEJhY2tlbmRPdXRwdXRDbGllbnRFcnJvcihcbiAgICAgICAgQmFja2VuZE91dHB1dENsaWVudEVycm9yVHlwZS5NRVRBREFUQV9SRVRSSUVWQUxfRVJST1IsXG4gICAgICAgICdTdGFjayBvdXRwdXRzIGFyZSB1bmRlZmluZWQnXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIG91dHB1dHMgaXMgYSBsaXN0IG9mIG91dHB1dCBlbnRyaWVzLiBoZXJlIHdlIHR1cm4gdGhhdCBpbnRvIGEgUmVjb3JkPG5hbWUsIHZhbHVlPiBvYmplY3RcbiAgICBjb25zdCBzdGFja091dHB1dFJlY29yZCA9IG91dHB1dHNcbiAgICAgIC5maWx0ZXIoKG91dHB1dCkgPT4gISFvdXRwdXQuT3V0cHV0VmFsdWUgJiYgISFvdXRwdXQuT3V0cHV0S2V5KVxuICAgICAgLnJlZHVjZShcbiAgICAgICAgKGFjY3VtdWxhdG9yLCBvdXRwdXRFbnRyeSkgPT4gKHtcbiAgICAgICAgICAuLi5hY2N1bXVsYXRvcixcbiAgICAgICAgICAvLyBpdCdzIHNhZmUgdG8gZGlzYWJsZSB0aGlzIHJ1bGUgYmVjYXVzZSB3ZSd2ZSBhbHJlYWR5IGZpbHRlcmVkIG91dCBwb3RlbnRpYWxseSB1bmRlZmluZWQgb3V0cHV0c1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgW291dHB1dEVudHJ5Lk91dHB1dEtleSFdOiBvdXRwdXRFbnRyeS5PdXRwdXRWYWx1ZSEsXG4gICAgICAgIH0pLFxuICAgICAgICB7fSBhcyBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4gICAgICApO1xuXG4gICAgLy8gbm93IHdlIGl0ZXJhdGUgb3ZlciB0aGUgbWV0YWRhdGEgZW50cmllcyBhbmQgcmVjb25zdHJ1Y3QgdGhlIGRhdGEgb2JqZWN0IGJhc2VkIG9uIHRoZSBzdGFja091dHB1dHMgdGhhdCBlYWNoIGNvbnN0cnVjdCBwYWNrYWdlIHNldFxuICAgIGNvbnN0IHJlc3VsdDogQmFja2VuZE91dHB1dCA9IHt9O1xuICAgIE9iamVjdC5lbnRyaWVzKGJhY2tlbmRPdXRwdXRNZXRhZGF0YSkuZm9yRWFjaCgoW291dHB1dEtleU5hbWUsIGVudHJ5XSkgPT4ge1xuICAgICAgY29uc3Qgb3V0cHV0RGF0YSA9IGVudHJ5LnN0YWNrT3V0cHV0cy5yZWR1Y2UoXG4gICAgICAgIChhY2N1bXVsYXRvciwgb3V0cHV0TmFtZSkgPT4ge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHN0YWNrT3V0cHV0UmVjb3JkW291dHB1dE5hbWVdID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIHN0YWNrT3V0cHV0UmVjb3JkW291dHB1dE5hbWVdID09PSAnJ1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uYWNjdW11bGF0b3IsXG4gICAgICAgICAgICBbb3V0cHV0TmFtZV06IHN0YWNrT3V0cHV0UmVjb3JkW291dHB1dE5hbWVdLFxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIHt9IGFzIFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgICAgICk7XG4gICAgICByZXN1bHRbb3V0cHV0S2V5TmFtZV0gPSB7XG4gICAgICAgIHZlcnNpb246IGVudHJ5LnZlcnNpb24sXG4gICAgICAgIHBheWxvYWQ6IG91dHB1dERhdGEsXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG4iXX0=