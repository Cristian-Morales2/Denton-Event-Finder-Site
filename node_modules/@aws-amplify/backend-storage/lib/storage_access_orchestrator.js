import { entityIdPathToken } from './constants.js';
import { validateStorageAccessPaths as _validateStorageAccessPaths } from './validate_storage_access_paths.js';
import { roleAccessBuilder as _roleAccessBuilder } from './access_builder.js';
import { AmplifyUserError } from '@aws-amplify/platform-core';
/**
 * Orchestrates the process of converting customer-defined storage access rules into corresponding IAM policies
 * and attaching those policies to the corresponding IAM roles
 */
export class StorageAccessOrchestrator {
    storageAccessGenerator;
    getInstanceProps;
    ssmEnvironmentEntries;
    policyFactory;
    validateStorageAccessPaths;
    roleAccessBuilder;
    /**
     * Maintains a mapping from a resource access acceptor to all of the access grants it has been configured with
     * Each entry of this map is fed into the policy generator to create a single policy for each acceptor
     */
    acceptorAccessMap = new Map();
    /**
     * Maintains pointers to the "deny" StoragePath Set for each access entry in the map above
     * This map is used during a final pass over all the StoragePaths to deny access on any paths where explicit allow rules were not specified
     */
    prefixDenyMap = new Map();
    /**
     * Instantiate with the access generator and other dependencies necessary for evaluating and constructing access policies
     * @param storageAccessGenerator The access callback defined by the customer
     * @param getInstanceProps props for fetching construct instances from the construct container
     * @param ssmEnvironmentEntries SSM context that should be passed to the ResourceAccessAcceptors when configuring access
     * @param policyFactory factory that generates IAM policies for various access control definitions
     * @param validateStorageAccessPaths validator function for checking access definition paths
     * @param roleAccessBuilder builder instance that is injected into the storageAccessGenerator to evaluate the rules
     */
    constructor(storageAccessGenerator, getInstanceProps, ssmEnvironmentEntries, policyFactory, validateStorageAccessPaths = _validateStorageAccessPaths, roleAccessBuilder = _roleAccessBuilder) {
        this.storageAccessGenerator = storageAccessGenerator;
        this.getInstanceProps = getInstanceProps;
        this.ssmEnvironmentEntries = ssmEnvironmentEntries;
        this.policyFactory = policyFactory;
        this.validateStorageAccessPaths = validateStorageAccessPaths;
        this.roleAccessBuilder = roleAccessBuilder;
    }
    /**
     * Orchestrates the process of translating the customer-provided storage access rules into IAM policies and attaching those policies to the appropriate roles.
     *
     * The high level steps are:
     * 1. Invokes the storageAccessGenerator to produce a storageAccessDefinition
     * 2. Validates the paths in the storageAccessDefinition
     * 3. Organizes the storageAccessDefinition into internally managed maps to facilitate translation into allow / deny rules on IAM policies
     * 4. Invokes the policy generator to produce a policy with appropriate allow / deny rules
     * 5. Invokes the resourceAccessAcceptors for each entry in the storageAccessDefinition to accept the corresponding IAM policy
     */
    orchestrateStorageAccess = () => {
        // storageAccessGenerator is the access callback defined by the customer
        // here we inject the roleAccessBuilder into the callback and run it
        // this produces the access definition that will be used to create the storage policies
        const storageAccessDefinition = this.storageAccessGenerator(this.roleAccessBuilder);
        // verify that the paths in the access definition are valid
        this.validateStorageAccessPaths(Object.keys(storageAccessDefinition));
        // iterate over the access definition and group permissions by ResourceAccessAcceptor
        Object.entries(storageAccessDefinition).forEach(([s3Prefix, accessPermissions]) => {
            const uniqueDefinitionIdSet = new Set();
            // iterate over all of the access definitions for a given prefix
            accessPermissions.forEach((permission) => {
                // iterate over all uniqueDefinitionIdValidations and ensure uniqueness within this path prefix
                permission.uniqueDefinitionIdValidations.forEach(({ uniqueDefinitionId, validationErrorOptions }) => {
                    if (uniqueDefinitionIdSet.has(uniqueDefinitionId)) {
                        throw new AmplifyUserError('InvalidStorageAccessDefinition', validationErrorOptions);
                    }
                    else {
                        uniqueDefinitionIdSet.add(uniqueDefinitionId);
                    }
                });
                // make the owner placeholder substitution in the s3 prefix
                const prefix = s3Prefix.replaceAll(entityIdPathToken, permission.idSubstitution);
                // replace "read" with "get" and "list" in actions
                const replaceReadWithGetAndList = permission.actions.flatMap((action) => (action === 'read' ? ['get', 'list'] : [action]));
                // ensure the actions list has no duplicates
                const noDuplicateActions = Array.from(new Set(replaceReadWithGetAndList));
                // set an entry that maps this permission to each resource acceptor
                permission.getResourceAccessAcceptors.forEach((getResourceAccessAcceptor) => {
                    this.addAccessDefinition(getResourceAccessAcceptor(this.getInstanceProps), noDuplicateActions, prefix);
                });
            });
        });
        // iterate over the access map entries and invoke each ResourceAccessAcceptor to accept the permissions
        this.attachPolicies(this.ssmEnvironmentEntries);
    };
    /**
     * Add an entry to the internal acceptorAccessMap and prefixDenyMap.
     * This entry defines a set of actions on a single s3 prefix that should be attached to a given ResourceAccessAcceptor
     */
    addAccessDefinition = (resourceAccessAcceptor, actions, s3Prefix) => {
        const acceptorToken = resourceAccessAcceptor.identifier;
        // if we haven't seen this token before, add it to the map
        if (!this.acceptorAccessMap.has(acceptorToken)) {
            this.acceptorAccessMap.set(acceptorToken, {
                accessMap: new Map(),
                acceptor: resourceAccessAcceptor,
            });
        }
        const accessMap = this.acceptorAccessMap.get(acceptorToken).accessMap;
        // add each action to the accessMap for this acceptorToken
        actions.forEach((action) => {
            if (!accessMap.has(action)) {
                // if we haven't seen this action for this acceptorToken before, add it to the map
                const allowSet = new Set([s3Prefix]);
                const denySet = new Set();
                accessMap.set(action, { allow: allowSet, deny: denySet });
                // this is where we create the reverse mapping that allows us to add entries to the denySet later by looking up the prefix
                this.setPrefixDenyMapEntry(s3Prefix, allowSet, denySet);
            }
            else {
                // otherwise add the prefix to the existing allow set
                const { allow: allowSet, deny: denySet } = accessMap.get(action);
                allowSet.add(s3Prefix);
                // add an entry in the prefixDenyMap for the existing allow and deny set
                this.setPrefixDenyMapEntry(s3Prefix, allowSet, denySet);
            }
        });
    };
    /**
     * Iterates over all of the access definitions that have been added to the orchestrator,
     * generates a policy for each accessMap,
     * and attaches the policy to the corresponding ResourceAccessAcceptor
     *
     * After this method is called, the existing access definition state is cleared.
     * This prevents multiple calls to this method from producing duplicate policies.
     * The class can continue to be used to build up state for a new set of policies if desired.
     * @param ssmEnvironmentEntries Additional SSM context that is passed to each ResourceAccessAcceptor
     */
    attachPolicies = (ssmEnvironmentEntries) => {
        const allPaths = Array.from(this.prefixDenyMap.keys());
        allPaths.forEach((storagePath) => {
            const parent = findParent(storagePath, allPaths);
            if (!parent) {
                return;
            }
            // if a parent path is defined, invoke the denyByDefault callback on this subpath for all policies that exist on the parent path
            this.prefixDenyMap
                .get(parent)
                ?.forEach((denyByDefaultCallback) => denyByDefaultCallback(storagePath));
        });
        this.acceptorAccessMap.forEach(({ acceptor, accessMap }) => {
            // removing subpaths from the allow set prevents unnecessary paths from being added to the policy
            // for example, if there are allow read rules for /foo/* and /foo/bar/* we only need to add /foo/* to the policy because that includes /foo/bar/*
            accessMap.forEach(({ allow }) => {
                removeSubPathsFromSet(allow);
            });
            acceptor.acceptResourceAccess(this.policyFactory.createPolicy(accessMap), ssmEnvironmentEntries);
        });
        this.acceptorAccessMap.clear();
        this.prefixDenyMap.clear();
    };
    setPrefixDenyMapEntry = (storagePath, allowPathSet, denyPathSet) => {
        // function that will add the denyPath to the denyPathSet unless the allowPathSet explicitly allows the path
        const setDenyByDefault = (denyPath) => {
            if (!allowPathSet.has(denyPath)) {
                denyPathSet.add(denyPath);
            }
        };
        if (!this.prefixDenyMap.has(storagePath)) {
            this.prefixDenyMap.set(storagePath, [setDenyByDefault]);
        }
        else {
            this.prefixDenyMap.get(storagePath)?.push(setDenyByDefault);
        }
    };
}
/**
 * This factory is really only necessary for allowing us to mock the StorageAccessOrchestrator in tests
 */
export class StorageAccessOrchestratorFactory {
    getInstance = (storageAccessGenerator, getInstanceProps, ssmEnvironmentEntries, policyFactory) => new StorageAccessOrchestrator(storageAccessGenerator, getInstanceProps, ssmEnvironmentEntries, policyFactory);
}
/**
 * Returns the element in paths that is a prefix of path, if any
 * Note that there can only be one at this point because of upstream validation
 */
const findParent = (path, paths) => paths.find((p) => path !== p && path.startsWith(p.replaceAll('*', '')));
const removeSubPathsFromSet = (paths) => {
    paths.forEach((path) => {
        if (findParent(path, Array.from(paths))) {
            paths.delete(path);
        }
    });
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RvcmFnZV9hY2Nlc3Nfb3JjaGVzdHJhdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL3N0b3JhZ2VfYWNjZXNzX29yY2hlc3RyYXRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFVQSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUVuRCxPQUFPLEVBQUUsMEJBQTBCLElBQUksMkJBQTJCLEVBQUUsTUFBTSxvQ0FBb0MsQ0FBQztBQUMvRyxPQUFPLEVBQUUsaUJBQWlCLElBQUksa0JBQWtCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUU5RSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQVU5RDs7O0dBR0c7QUFDSCxNQUFNLE9BQU8seUJBQXlCO0lBZ0NqQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFwQ25COzs7T0FHRztJQUNLLGlCQUFpQixHQUFHLElBQUksR0FBRyxFQVNoQyxDQUFDO0lBRUo7OztPQUdHO0lBQ0ssYUFBYSxHQUFHLElBQUksR0FBRyxFQUFtQyxDQUFDO0lBRW5FOzs7Ozs7OztPQVFHO0lBQ0gsWUFDbUIsc0JBQThDLEVBQzlDLGdCQUFrRCxFQUNsRCxxQkFBNEMsRUFDNUMsYUFBeUMsRUFDekMsNkJBQTZCLDJCQUEyQixFQUN4RCxvQkFBMEMsa0JBQWtCO1FBTDVELDJCQUFzQixHQUF0QixzQkFBc0IsQ0FBd0I7UUFDOUMscUJBQWdCLEdBQWhCLGdCQUFnQixDQUFrQztRQUNsRCwwQkFBcUIsR0FBckIscUJBQXFCLENBQXVCO1FBQzVDLGtCQUFhLEdBQWIsYUFBYSxDQUE0QjtRQUN6QywrQkFBMEIsR0FBMUIsMEJBQTBCLENBQThCO1FBQ3hELHNCQUFpQixHQUFqQixpQkFBaUIsQ0FBMkM7SUFDNUUsQ0FBQztJQUVKOzs7Ozs7Ozs7T0FTRztJQUNILHdCQUF3QixHQUFHLEdBQUcsRUFBRTtRQUM5Qix3RUFBd0U7UUFDeEUsb0VBQW9FO1FB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dEluc3RhbmNlUHJvcHMsXG4gIFJlc291cmNlQWNjZXNzQWNjZXB0b3IsXG4gIFNzbUVudmlyb25tZW50RW50cnksXG59IGZyb20gJ0Bhd3MtYW1wbGlmeS9wbHVnaW4tdHlwZXMnO1xuaW1wb3J0IHtcbiAgU3RvcmFnZUFjY2Vzc0J1aWxkZXIsXG4gIFN0b3JhZ2VBY2Nlc3NHZW5lcmF0b3IsXG4gIFN0b3JhZ2VQYXRoLFxufSBmcm9tICcuL3R5cGVzLmpzJztcbmltcG9ydCB7IGVudGl0eUlkUGF0aFRva2VuIH0gZnJvbSAnLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgU3RvcmFnZUFjY2Vzc1BvbGljeUZhY3RvcnkgfSBmcm9tICcuL3N0b3JhZ2VfYWNjZXNzX3BvbGljeV9mYWN0b3J5LmpzJztcbmltcG9ydCB7IHZhbGlkYXRlU3RvcmFnZUFjY2Vzc1BhdGhzIGFzIF92YWxpZGF0ZVN0b3JhZ2VBY2Nlc3NQYXRocyB9IGZyb20gJy4vdmFsaWRhdGVfc3RvcmFnZV9hY2Nlc3NfcGF0aHMuanMnO1xuaW1wb3J0IHsgcm9sZUFjY2Vzc0J1aWxkZXIgYXMgX3JvbGVBY2Nlc3NCdWlsZGVyIH0gZnJvbSAnLi9hY2Nlc3NfYnVpbGRlci5qcyc7XG5pbXBvcnQgeyBJbnRlcm5hbFN0b3JhZ2VBY3Rpb24sIFN0b3JhZ2VFcnJvciB9IGZyb20gJy4vcHJpdmF0ZV90eXBlcy5qcyc7XG5pbXBvcnQgeyBBbXBsaWZ5VXNlckVycm9yIH0gZnJvbSAnQGF3cy1hbXBsaWZ5L3BsYXRmb3JtLWNvcmUnO1xuXG4vKiBzb21lIHR5cGVzIGludGVybmFsIHRvIHRoaXMgZmlsZSB0byBpbXByb3ZlIHJlYWRhYmlsaXR5ICovXG5cbi8vIEFsaWFzIHR5cGUgZm9yIGEgc3RyaW5nIHRoYXQgaXMgYSBSZXNvdXJjZUFjY2Vzc0FjY2VwdG9yIHRva2VuXG50eXBlIEFjY2VwdG9yVG9rZW4gPSBzdHJpbmc7XG5cbi8vIENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgcGxhY2VzIHN0b3JhZ2VQYXRoIGluIHRoZSBkZW55IGxpc3QgZm9yIGFuIGFjdGlvbiBpZiBpdCBpcyBub3QgZXhwbGljaXRseSBhbGxvd2VkIGJ5IGFub3RoZXIgcnVsZVxudHlwZSBTZXREZW55QnlEZWZhdWx0ID0gKHN0b3JhZ2VQYXRoOiBTdG9yYWdlUGF0aCkgPT4gdm9pZDtcblxuLyoqXG4gKiBPcmNoZXN0cmF0ZXMgdGhlIHByb2Nlc3Mgb2YgY29udmVydGluZyBjdXN0b21lci1kZWZpbmVkIHN0b3JhZ2UgYWNjZXNzIHJ1bGVzIGludG8gY29ycmVzcG9uZGluZyBJQU0gcG9saWNpZXNcbiAqIGFuZCBhdHRhY2hpbmcgdGhvc2UgcG9saWNpZXMgdG8gdGhlIGNvcnJlc3BvbmRpbmcgSUFNIHJvbGVzXG4gKi9cbmV4cG9ydCBjbGFzcyBTdG9yYWdlQWNjZXNzT3JjaGVzdHJhdG9yIHtcbiAgLyoqXG4gICAqIE1haW50YWlucyBhIG1hcHBpbmcgZnJvbSBhIHJlc291cmNlIGFjY2VzcyBhY2NlcHRvciB0byBhbGwgb2YgdGhlIGFjY2VzcyBncmFudHMgaXQgaGFzIGJlZW4gY29uZmlndXJlZCB3aXRoXG4gICAqIEVhY2ggZW50cnkgb2YgdGhpcyBtYXAgaXMgZmVkIGludG8gdGhlIHBvbGljeSBnZW5lcmF0b3IgdG8gY3JlYXRlIGEgc2luZ2xlIHBvbGljeSBmb3IgZWFjaCBhY2NlcHRvclxuICAgKi9cbiAgcHJpdmF0ZSBhY2NlcHRvckFjY2Vzc01hcCA9IG5ldyBNYXA8XG4gICAgQWNjZXB0b3JUb2tlbixcbiAgICB7XG4gICAgICBhY2NlcHRvcjogUmVzb3VyY2VBY2Nlc3NBY2NlcHRvcjtcbiAgICAgIGFjY2Vzc01hcDogTWFwPFxuICAgICAgICBJbnRlcm5hbFN0b3JhZ2VBY3Rpb24sXG4gICAgICAgIHsgYWxsb3c6IFNldDxTdG9yYWdlUGF0aD47IGRlbnk6IFNldDxTdG9yYWdlUGF0aD4gfVxuICAgICAgPjtcbiAgICB9XG4gID4oKTtcblxuICAvKipcbiAgICogTWFpbnRhaW5zIHBvaW50ZXJzIHRvIHRoZSBcImRlbnlcIiBTdG9yYWdlUGF0aCBTZXQgZm9yIGVhY2ggYWNjZXNzIGVudHJ5IGluIHRoZSBtYXAgYWJvdmVcbiAgICogVGhpcyBtYXAgaXMgdXNlZCBkdXJpbmcgYSBmaW5hbCBwYXNzIG92ZXIgYWxsIHRoZSBTdG9yYWdlUGF0aHMgdG8gZGVueSBhY2Nlc3Mgb24gYW55IHBhdGhzIHdoZXJlIGV4cGxpY2l0IGFsbG93IHJ1bGVzIHdlcmUgbm90IHNwZWNpZmllZFxuICAgKi9cbiAgcHJpdmF0ZSBwcmVmaXhEZW55TWFwID0gbmV3IE1hcDxTdG9yYWdlUGF0aCwgU2V0RGVueUJ5RGVmYXVsdFtdPigpO1xuXG4gIC8qKlxuICAgKiBJbnN0YW50aWF0ZSB3aXRoIHRoZSBhY2Nlc3MgZ2VuZXJhdG9yIGFuZCBvdGhlciBkZXBlbmRlbmNpZXMgbmVjZXNzYXJ5IGZvciBldmFsdWF0aW5nIGFuZCBjb25zdHJ1Y3RpbmcgYWNjZXNzIHBvbGljaWVzXG4gICAqIEBwYXJhbSBzdG9yYWdlQWNjZXNzR2VuZXJhdG9yIFRoZSBhY2Nlc3MgY2FsbGJhY2sgZGVmaW5lZCBieSB0aGUgY3VzdG9tZXJcbiAgICogQHBhcmFtIGdldEluc3RhbmNlUHJvcHMgcHJvcHMgZm9yIGZldGNoaW5nIGNvbnN0cnVjdCBpbnN0YW5jZXMgZnJvbSB0aGUgY29uc3RydWN0IGNvbnRhaW5lclxuICAgKiBAcGFyYW0gc3NtRW52aXJvbm1lbnRFbnRyaWVzIFNTTSBjb250ZXh0IHRoYXQgc2hvdWxkIGJlIHBhc3NlZCB0byB0aGUgUmVzb3VyY2VBY2Nlc3NBY2NlcHRvcnMgd2hlbiBjb25maWd1cmluZyBhY2Nlc3NcbiAgICogQHBhcmFtIHBvbGljeUZhY3RvcnkgZmFjdG9yeSB0aGF0IGdlbmVyYXRlcyBJQU0gcG9saWNpZXMgZm9yIHZhcmlvdXMgYWNjZXNzIGNvbnRyb2wgZGVmaW5pdGlvbnNcbiAgICogQHBhcmFtIHZhbGlkYXRlU3RvcmFnZUFjY2Vzc1BhdGhzIHZhbGlkYXRvciBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgYWNjZXNzIGRlZmluaXRpb24gcGF0aHNcbiAgICogQHBhcmFtIHJvbGVBY2Nlc3NCdWlsZGVyIGJ1aWxkZXIgaW5zdGFuY2UgdGhhdCBpcyBpbmplY3RlZCBpbnRvIHRoZSBzdG9yYWdlQWNjZXNzR2VuZXJhdG9yIHRvIGV2YWx1YXRlIHRoZSBydWxlc1xuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBzdG9yYWdlQWNjZXNzR2VuZXJhdG9yOiBTdG9yYWdlQWNjZXNzR2VuZXJhdG9yLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZ2V0SW5zdGFuY2VQcm9wczogQ29uc3RydWN0RmFjdG9yeUdldEluc3RhbmNlUHJvcHMsXG4gICAgcHJpdmF0ZSByZWFkb25seSBzc21FbnZpcm9ubWVudEVudHJpZXM6IFNzbUVudmlyb25tZW50RW50cnlbXSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHBvbGljeUZhY3Rvcnk6IFN0b3JhZ2VBY2Nlc3NQb2xpY3lGYWN0b3J5LFxuICAgIHByaXZhdGUgcmVhZG9ubHkgdmFsaWRhdGVTdG9yYWdlQWNjZXNzUGF0aHMgPSBfdmFsaWRhdGVTdG9yYWdlQWNjZXNzUGF0aHMsXG4gICAgcHJpdmF0ZSByZWFkb25seSByb2xlQWNjZXNzQnVpbGRlcjogU3RvcmFnZUFjY2Vzc0J1aWxkZXIgPSBfcm9sZUFjY2Vzc0J1aWxkZXJcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBPcmNoZXN0cmF0ZXMgdGhlIHByb2Nlc3Mgb2YgdHJhbnNsYXRpbmcgdGhlIGN1c3RvbWVyLXByb3ZpZGVkIHN0b3JhZ2UgYWNjZXNzIHJ1bGVzIGludG8gSUFNIHBvbGljaWVzIGFuZCBhdHRhY2hpbmcgdGhvc2UgcG9saWNpZXMgdG8gdGhlIGFwcHJvcHJpYXRlIHJvbGVzLlxuICAgKlxuICAgKiBUaGUgaGlnaCBsZXZlbCBzdGVwcyBhcmU6XG4gICAqIDEuIEludm9rZXMgdGhlIHN0b3JhZ2VBY2Nlc3NHZW5lcmF0b3IgdG8gcHJvZHVjZSBhIHN0b3JhZ2VBY2Nlc3NEZWZpbml0aW9uXG4gICAqIDIuIFZhbGlkYXRlcyB0aGUgcGF0aHMgaW4gdGhlIHN0b3JhZ2VBY2Nlc3NEZWZpbml0aW9uXG4gICAqIDMuIE9yZ2FuaXplcyB0aGUgc3RvcmFnZUFjY2Vzc0RlZmluaXRpb24gaW50byBpbnRlcm5hbGx5IG1hbmFnZWQgbWFwcyB0byBmYWNpbGl0YXRlIHRyYW5zbGF0aW9uIGludG8gYWxsb3cgLyBkZW55IHJ1bGVzIG9uIElBTSBwb2xpY2llc1xuICAgKiA0LiBJbnZva2VzIHRoZSBwb2xpY3kgZ2VuZXJhdG9yIHRvIHByb2R1Y2UgYSBwb2xpY3kgd2l0aCBhcHByb3ByaWF0ZSBhbGxvdyAvIGRlbnkgcnVsZXNcbiAgICogNS4gSW52b2tlcyB0aGUgcmVzb3VyY2VBY2Nlc3NBY2NlcHRvcnMgZm9yIGVhY2ggZW50cnkgaW4gdGhlIHN0b3JhZ2VBY2Nlc3NEZWZpbml0aW9uIHRvIGFjY2VwdCB0aGUgY29ycmVzcG9uZGluZyBJQU0gcG9saWN5XG4gICAqL1xuICBvcmNoZXN0cmF0ZVN0b3JhZ2VBY2Nlc3MgPSAoKSA9PiB7XG4gICAgLy8gc3RvcmFnZUFjY2Vzc0dlbmVyYXRvciBpcyB0aGUgYWNjZXNzIGNhbGxiYWNrIGRlZmluZWQgYnkgdGhlIGN1c3RvbWVyXG4gICAgLy8gaGVyZSB3ZSBpbmplY3QgdGhlIHJvbGVBY2Nlc3NCdWlsZGVyIGludG8gdGhlIGNhbGxiYWNrIGFuZCBydW4gaXRcbiAgICAvLyB0aGlzIHByb2R1Y2VzIHRoZSBhY2Nlc3MgZGVmaW5pdGlvbiB0aGF0IHdpbGwgYmUgdXNlZCB0byBjcmVhdGUgdGhlIHN0b3JhZ2UgcG9saWNpZXNcbiAgICBjb25zdCBzdG9yYWdlQWNjZXNzRGVmaW5pdGlvbiA9IHRoaXMuc3RvcmFnZUFjY2Vzc0dlbmVyYXRvcihcbiAgICAgIHRoaXMucm9sZUFjY2Vzc0J1aWxkZXJcbiAgICApO1xuXG4gICAgLy8gdmVyaWZ5IHRoYXQgdGhlIHBhdGhzIGluIHRoZSBhY2Nlc3MgZGVmaW5pdGlvbiBhcmUgdmFsaWRcbiAgICB0aGlzLnZhbGlkYXRlU3RvcmFnZUFjY2Vzc1BhdGhzKE9iamVjdC5rZXlzKHN0b3JhZ2VBY2Nlc3NEZWZpbml0aW9uKSk7XG5cbiAgICAvLyBpdGVyYXRlIG92ZXIgdGhlIGFjY2VzcyBkZWZpbml0aW9uIGFuZCBncm91cCBwZXJtaXNzaW9ucyBieSBSZXNvdXJjZUFjY2Vzc0FjY2VwdG9yXG4gICAgT2JqZWN0LmVudHJpZXMoc3RvcmFnZUFjY2Vzc0RlZmluaXRpb24pLmZvckVhY2goXG4gICAgICAoW3MzUHJlZml4LCBhY2Nlc3NQZXJtaXNzaW9uc10pID0+IHtcbiAgICAgICAgY29uc3QgdW5pcXVlRGVmaW5pdGlvbklkU2V0ID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gICAgICAgIC8vIGl0ZXJhdGUgb3ZlciBhbGwgb2YgdGhlIGFjY2VzcyBkZWZpbml0aW9ucyBmb3IgYSBnaXZlbiBwcmVmaXhcbiAgICAgICAgYWNjZXNzUGVybWlzc2lvbnMuZm9yRWFjaCgocGVybWlzc2lvbikgPT4ge1xuICAgICAgICAgIC8vIGl0ZXJhdGUgb3ZlciBhbGwgdW5pcXVlRGVmaW5pdGlvbklkVmFsaWRhdGlvbnMgYW5kIGVuc3VyZSB1bmlxdWVuZXNzIHdpdGhpbiB0aGlzIHBhdGggcHJlZml4XG4gICAgICAgICAgcGVybWlzc2lvbi51bmlxdWVEZWZpbml0aW9uSWRWYWxpZGF0aW9ucy5mb3JFYWNoKFxuICAgICAgICAgICAgKHsgdW5pcXVlRGVmaW5pdGlvbklkLCB2YWxpZGF0aW9uRXJyb3JPcHRpb25zIH0pID0+IHtcbiAgICAgICAgICAgICAgaWYgKHVuaXF1ZURlZmluaXRpb25JZFNldC5oYXModW5pcXVlRGVmaW5pdGlvbklkKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBbXBsaWZ5VXNlckVycm9yPFN0b3JhZ2VFcnJvcj4oXG4gICAgICAgICAgICAgICAgICAnSW52YWxpZFN0b3JhZ2VBY2Nlc3NEZWZpbml0aW9uJyxcbiAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25FcnJvck9wdGlvbnNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVuaXF1ZURlZmluaXRpb25JZFNldC5hZGQodW5pcXVlRGVmaW5pdGlvbklkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgICAgLy8gbWFrZSB0aGUgb3duZXIgcGxhY2Vob2xkZXIgc3Vic3RpdHV0aW9uIGluIHRoZSBzMyBwcmVmaXhcbiAgICAgICAgICBjb25zdCBwcmVmaXggPSBzM1ByZWZpeC5yZXBsYWNlQWxsKFxuICAgICAgICAgICAgZW50aXR5SWRQYXRoVG9rZW4sXG4gICAgICAgICAgICBwZXJtaXNzaW9uLmlkU3Vic3RpdHV0aW9uXG4gICAgICAgICAgKSBhcyBTdG9yYWdlUGF0aDtcblxuICAgICAgICAgIC8vIHJlcGxhY2UgXCJyZWFkXCIgd2l0aCBcImdldFwiIGFuZCBcImxpc3RcIiBpbiBhY3Rpb25zXG4gICAgICAgICAgY29uc3QgcmVwbGFjZVJlYWRXaXRoR2V0QW5kTGlzdCA9IHBlcm1pc3Npb24uYWN0aW9ucy5mbGF0TWFwKFxuICAgICAgICAgICAgKGFjdGlvbikgPT4gKGFjdGlvbiA9PT0gJ3JlYWQnID8gWydnZXQnLCAnbGlzdCddIDogW2FjdGlvbl0pXG4gICAgICAgICAgKSBhcyBJbnRlcm5hbFN0b3JhZ2VBY3Rpb25bXTtcblxuICAgICAgICAgIC8vIGVuc3VyZSB0aGUgYWN0aW9ucyBsaXN0IGhhcyBubyBkdXBsaWNhdGVzXG4gICAgICAgICAgY29uc3Qgbm9EdXBsaWNhdGVBY3Rpb25zID0gQXJyYXkuZnJvbShcbiAgICAgICAgICAgIG5ldyBTZXQocmVwbGFjZVJlYWRXaXRoR2V0QW5kTGlzdClcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgLy8gc2V0IGFuIGVudHJ5IHRoYXQgbWFwcyB0aGlzIHBlcm1pc3Npb24gdG8gZWFjaCByZXNvdXJjZSBhY2NlcHRvclxuICAgICAgICAgIHBlcm1pc3Npb24uZ2V0UmVzb3VyY2VBY2Nlc3NBY2NlcHRvcnMuZm9yRWFjaChcbiAgICAgICAgICAgIChnZXRSZXNvdXJjZUFjY2Vzc0FjY2VwdG9yKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuYWRkQWNjZXNzRGVmaW5pdGlvbihcbiAgICAgICAgICAgICAgICBnZXRSZXNvdXJjZUFjY2Vzc0FjY2VwdG9yKHRoaXMuZ2V0SW5zdGFuY2VQcm9wcyksXG4gICAgICAgICAgICAgICAgbm9EdXBsaWNhdGVBY3Rpb25zLFxuICAgICAgICAgICAgICAgIHByZWZpeFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICk7XG5cbiAgICAvLyBpdGVyYXRlIG92ZXIgdGhlIGFjY2VzcyBtYXAgZW50cmllcyBhbmQgaW52b2tlIGVhY2ggUmVzb3VyY2VBY2Nlc3NBY2NlcHRvciB0byBhY2NlcHQgdGhlIHBlcm1pc3Npb25zXG4gICAgdGhpcy5hdHRhY2hQb2xpY2llcyh0aGlzLnNzbUVudmlyb25tZW50RW50cmllcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBlbnRyeSB0byB0aGUgaW50ZXJuYWwgYWNjZXB0b3JBY2Nlc3NNYXAgYW5kIHByZWZpeERlbnlNYXAuXG4gICAqIFRoaXMgZW50cnkgZGVmaW5lcyBhIHNldCBvZiBhY3Rpb25zIG9uIGEgc2luZ2xlIHMzIHByZWZpeCB0aGF0IHNob3VsZCBiZSBhdHRhY2hlZCB0byBhIGdpdmVuIFJlc291cmNlQWNjZXNzQWNjZXB0b3JcbiAgICovXG4gIHByaXZhdGUgYWRkQWNjZXNzRGVmaW5pdGlvbiA9IChcbiAgICByZXNvdXJjZUFjY2Vzc0FjY2VwdG9yOiBSZXNvdXJjZUFjY2Vzc0FjY2VwdG9yLFxuICAgIGFjdGlvbnM6IEludGVybmFsU3RvcmFnZUFjdGlvbltdLFxuICAgIHMzUHJlZml4OiBTdG9yYWdlUGF0aFxuICApID0+IHtcbiAgICBjb25zdCBhY2NlcHRvclRva2VuID0gcmVzb3VyY2VBY2Nlc3NBY2NlcHRvci5pZGVudGlmaWVyO1xuXG4gICAgLy8gaWYgd2UgaGF2ZW4ndCBzZWVuIHRoaXMgdG9rZW4gYmVmb3JlLCBhZGQgaXQgdG8gdGhlIG1hcFxuICAgIGlmICghdGhpcy5hY2NlcHRvckFjY2Vzc01hcC5oYXMoYWNjZXB0b3JUb2tlbikpIHtcbiAgICAgIHRoaXMuYWNjZXB0b3JBY2Nlc3NNYXAuc2V0KGFjY2VwdG9yVG9rZW4sIHtcbiAgICAgICAgYWNjZXNzTWFwOiBuZXcgTWFwKCksXG4gICAgICAgIGFjY2VwdG9yOiByZXNvdXJjZUFjY2Vzc0FjY2VwdG9yLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGFjY2Vzc01hcCA9IHRoaXMuYWNjZXB0b3JBY2Nlc3NNYXAuZ2V0KGFjY2VwdG9yVG9rZW4pIS5hY2Nlc3NNYXA7XG4gICAgLy8gYWRkIGVhY2ggYWN0aW9uIHRvIHRoZSBhY2Nlc3NNYXAgZm9yIHRoaXMgYWNjZXB0b3JUb2tlblxuICAgIGFjdGlvbnMuZm9yRWFjaCgoYWN0aW9uKSA9PiB7XG4gICAgICBpZiAoIWFjY2Vzc01hcC5oYXMoYWN0aW9uKSkge1xuICAgICAgICAvLyBpZiB3ZSBoYXZlbid0IHNlZW4gdGhpcyBhY3Rpb24gZm9yIHRoaXMgYWNjZXB0b3JUb2tlbiBiZWZvcmUsIGFkZCBpdCB0byB0aGUgbWFwXG4gICAgICAgIGNvbnN0IGFsbG93U2V0ID0gbmV3IFNldDxTdG9yYWdlUGF0aD4oW3MzUHJlZml4XSk7XG4gICAgICAgIGNvbnN0IGRlbnlTZXQgPSBuZXcgU2V0PFN0b3JhZ2VQYXRoPigpO1xuICAgICAgICBhY2Nlc3NNYXAuc2V0KGFjdGlvbiwgeyBhbGxvdzogYWxsb3dTZXQsIGRlbnk6IGRlbnlTZXQgfSk7XG5cbiAgICAgICAgLy8gdGhpcyBpcyB3aGVyZSB3ZSBjcmVhdGUgdGhlIHJldmVyc2UgbWFwcGluZyB0aGF0IGFsbG93cyB1cyB0byBhZGQgZW50cmllcyB0byB0aGUgZGVueVNldCBsYXRlciBieSBsb29raW5nIHVwIHRoZSBwcmVmaXhcbiAgICAgICAgdGhpcy5zZXRQcmVmaXhEZW55TWFwRW50cnkoczNQcmVmaXgsIGFsbG93U2V0LCBkZW55U2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG90aGVyd2lzZSBhZGQgdGhlIHByZWZpeCB0byB0aGUgZXhpc3RpbmcgYWxsb3cgc2V0XG4gICAgICAgIGNvbnN0IHsgYWxsb3c6IGFsbG93U2V0LCBkZW55OiBkZW55U2V0IH0gPSBhY2Nlc3NNYXAuZ2V0KGFjdGlvbikhO1xuICAgICAgICBhbGxvd1NldC5hZGQoczNQcmVmaXgpO1xuXG4gICAgICAgIC8vIGFkZCBhbiBlbnRyeSBpbiB0aGUgcHJlZml4RGVueU1hcCBmb3IgdGhlIGV4aXN0aW5nIGFsbG93IGFuZCBkZW55IHNldFxuICAgICAgICB0aGlzLnNldFByZWZpeERlbnlNYXBFbnRyeShzM1ByZWZpeCwgYWxsb3dTZXQsIGRlbnlTZXQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJdGVyYXRlcyBvdmVyIGFsbCBvZiB0aGUgYWNjZXNzIGRlZmluaXRpb25zIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIHRvIHRoZSBvcmNoZXN0cmF0b3IsXG4gICAqIGdlbmVyYXRlcyBhIHBvbGljeSBmb3IgZWFjaCBhY2Nlc3NNYXAsXG4gICAqIGFuZCBhdHRhY2hlcyB0aGUgcG9saWN5IHRvIHRoZSBjb3JyZXNwb25kaW5nIFJlc291cmNlQWNjZXNzQWNjZXB0b3JcbiAgICpcbiAgICogQWZ0ZXIgdGhpcyBtZXRob2QgaXMgY2FsbGVkLCB0aGUgZXhpc3RpbmcgYWNjZXNzIGRlZmluaXRpb24gc3RhdGUgaXMgY2xlYXJlZC5cbiAgICogVGhpcyBwcmV2ZW50cyBtdWx0aXBsZSBjYWxscyB0byB0aGlzIG1ldGhvZCBmcm9tIHByb2R1Y2luZyBkdXBsaWNhdGUgcG9saWNpZXMuXG4gICAqIFRoZSBjbGFzcyBjYW4gY29udGludWUgdG8gYmUgdXNlZCB0byBidWlsZCB1cCBzdGF0ZSBmb3IgYSBuZXcgc2V0IG9mIHBvbGljaWVzIGlmIGRlc2lyZWQuXG4gICAqIEBwYXJhbSBzc21FbnZpcm9ubWVudEVudHJpZXMgQWRkaXRpb25hbCBTU00gY29udGV4dCB0aGF0IGlzIHBhc3NlZCB0byBlYWNoIFJlc291cmNlQWNjZXNzQWNjZXB0b3JcbiAgICovXG4gIHByaXZhdGUgYXR0YWNoUG9saWNpZXMgPSAoc3NtRW52aXJvbm1lbnRFbnRyaWVzOiBTc21FbnZpcm9ubWVudEVudHJ5W10pID0+IHtcbiAgICBjb25zdCBhbGxQYXRocyA9IEFycmF5LmZyb20odGhpcy5wcmVmaXhEZW55TWFwLmtleXMoKSk7XG4gICAgYWxsUGF0aHMuZm9yRWFjaCgoc3RvcmFnZVBhdGgpID0+IHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IGZpbmRQYXJlbnQoc3RvcmFnZVBhdGgsIGFsbFBhdGhzKTtcbiAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIGlmIGEgcGFyZW50IHBhdGggaXMgZGVmaW5lZCwgaW52b2tlIHRoZSBkZW55QnlEZWZhdWx0IGNhbGxiYWNrIG9uIHRoaXMgc3VicGF0aCBmb3IgYWxsIHBvbGljaWVzIHRoYXQgZXhpc3Qgb24gdGhlIHBhcmVudCBwYXRoXG4gICAgICB0aGlzLnByZWZpeERlbnlNYXBcbiAgICAgICAgLmdldChwYXJlbnQpXG4gICAgICAgID8uZm9yRWFjaCgoZGVueUJ5RGVmYXVsdENhbGxiYWNrKSA9PlxuICAgICAgICAgIGRlbnlCeURlZmF1bHRDYWxsYmFjayhzdG9yYWdlUGF0aClcbiAgICAgICAgKTtcbiAgICB9KTtcblxuICAgIHRoaXMuYWNjZXB0b3JBY2Nlc3NNYXAuZm9yRWFjaCgoeyBhY2NlcHRvciwgYWNjZXNzTWFwIH0pID0+IHtcbiAgICAgIC8vIHJlbW92aW5nIHN1YnBhdGhzIGZyb20gdGhlIGFsbG93IHNldCBwcmV2ZW50cyB1bm5lY2Vzc2FyeSBwYXRocyBmcm9tIGJlaW5nIGFkZGVkIHRvIHRoZSBwb2xpY3lcbiAgICAgIC8vIGZvciBleGFtcGxlLCBpZiB0aGVyZSBhcmUgYWxsb3cgcmVhZCBydWxlcyBmb3IgL2Zvby8qIGFuZCAvZm9vL2Jhci8qIHdlIG9ubHkgbmVlZCB0byBhZGQgL2Zvby8qIHRvIHRoZSBwb2xpY3kgYmVjYXVzZSB0aGF0IGluY2x1ZGVzIC9mb28vYmFyLypcbiAgICAgIGFjY2Vzc01hcC5mb3JFYWNoKCh7IGFsbG93IH0pID0+IHtcbiAgICAgICAgcmVtb3ZlU3ViUGF0aHNGcm9tU2V0KGFsbG93KTtcbiAgICAgIH0pO1xuICAgICAgYWNjZXB0b3IuYWNjZXB0UmVzb3VyY2VBY2Nlc3MoXG4gICAgICAgIHRoaXMucG9saWN5RmFjdG9yeS5jcmVhdGVQb2xpY3koYWNjZXNzTWFwKSxcbiAgICAgICAgc3NtRW52aXJvbm1lbnRFbnRyaWVzXG4gICAgICApO1xuICAgIH0pO1xuICAgIHRoaXMuYWNjZXB0b3JBY2Nlc3NNYXAuY2xlYXIoKTtcbiAgICB0aGlzLnByZWZpeERlbnlNYXAuY2xlYXIoKTtcbiAgfTtcblxuICBwcml2YXRlIHNldFByZWZpeERlbnlNYXBFbnRyeSA9IChcbiAgICBzdG9yYWdlUGF0aDogU3RvcmFnZVBhdGgsXG4gICAgYWxsb3dQYXRoU2V0OiBTZXQ8U3RvcmFnZVBhdGg+LFxuICAgIGRlbnlQYXRoU2V0OiBTZXQ8U3RvcmFnZVBhdGg+XG4gICkgPT4ge1xuICAgIC8vIGZ1bmN0aW9uIHRoYXQgd2lsbCBhZGQgdGhlIGRlbnlQYXRoIHRvIHRoZSBkZW55UGF0aFNldCB1bmxlc3MgdGhlIGFsbG93UGF0aFNldCBleHBsaWNpdGx5IGFsbG93cyB0aGUgcGF0aFxuICAgIGNvbnN0IHNldERlbnlCeURlZmF1bHQgPSAoZGVueVBhdGg6IFN0b3JhZ2VQYXRoKSA9PiB7XG4gICAgICBpZiAoIWFsbG93UGF0aFNldC5oYXMoZGVueVBhdGgpKSB7XG4gICAgICAgIGRlbnlQYXRoU2V0LmFkZChkZW55UGF0aCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoIXRoaXMucHJlZml4RGVueU1hcC5oYXMoc3RvcmFnZVBhdGgpKSB7XG4gICAgICB0aGlzLnByZWZpeERlbnlNYXAuc2V0KHN0b3JhZ2VQYXRoLCBbc2V0RGVueUJ5RGVmYXVsdF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByZWZpeERlbnlNYXAuZ2V0KHN0b3JhZ2VQYXRoKT8ucHVzaChzZXREZW55QnlEZWZhdWx0KTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBmYWN0b3J5IGlzIHJlYWxseSBvbmx5IG5lY2Vzc2FyeSBmb3IgYWxsb3dpbmcgdXMgdG8gbW9jayB0aGUgU3RvcmFnZUFjY2Vzc09yY2hlc3RyYXRvciBpbiB0ZXN0c1xuICovXG5leHBvcnQgY2xhc3MgU3RvcmFnZUFjY2Vzc09yY2hlc3RyYXRvckZhY3Rvcnkge1xuICBnZXRJbnN0YW5jZSA9IChcbiAgICBzdG9yYWdlQWNjZXNzR2VuZXJhdG9yOiBTdG9yYWdlQWNjZXNzR2VuZXJhdG9yLFxuICAgIGdldEluc3RhbmNlUHJvcHM6IENvbnN0cnVjdEZhY3RvcnlHZXRJbnN0YW5jZVByb3BzLFxuICAgIHNzbUVudmlyb25tZW50RW50cmllczogU3NtRW52aXJvbm1lbnRFbnRyeVtdLFxuICAgIHBvbGljeUZhY3Rvcnk6IFN0b3JhZ2VBY2Nlc3NQb2xpY3lGYWN0b3J5XG4gICkgPT5cbiAgICBuZXcgU3RvcmFnZUFjY2Vzc09yY2hlc3RyYXRvcihcbiAgICAgIHN0b3JhZ2VBY2Nlc3NHZW5lcmF0b3IsXG4gICAgICBnZXRJbnN0YW5jZVByb3BzLFxuICAgICAgc3NtRW52aXJvbm1lbnRFbnRyaWVzLFxuICAgICAgcG9saWN5RmFjdG9yeVxuICAgICk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZWxlbWVudCBpbiBwYXRocyB0aGF0IGlzIGEgcHJlZml4IG9mIHBhdGgsIGlmIGFueVxuICogTm90ZSB0aGF0IHRoZXJlIGNhbiBvbmx5IGJlIG9uZSBhdCB0aGlzIHBvaW50IGJlY2F1c2Ugb2YgdXBzdHJlYW0gdmFsaWRhdGlvblxuICovXG5jb25zdCBmaW5kUGFyZW50ID0gKHBhdGg6IHN0cmluZywgcGF0aHM6IHN0cmluZ1tdKSA9PlxuICBwYXRocy5maW5kKChwKSA9PiBwYXRoICE9PSBwICYmIHBhdGguc3RhcnRzV2l0aChwLnJlcGxhY2VBbGwoJyonLCAnJykpKSBhc1xuICAgIHwgU3RvcmFnZVBhdGhcbiAgICB8IHVuZGVmaW5lZDtcblxuY29uc3QgcmVtb3ZlU3ViUGF0aHNGcm9tU2V0ID0gKHBhdGhzOiBTZXQ8U3RvcmFnZVBhdGg+KSA9PiB7XG4gIHBhdGhzLmZvckVhY2goKHBhdGgpID0+IHtcbiAgICBpZiAoZmluZFBhcmVudChwYXRoLCBBcnJheS5mcm9tKHBhdGhzKSkpIHtcbiAgICAgIHBhdGhzLmRlbGV0ZShwYXRoKTtcbiAgICB9XG4gIH0pO1xufTtcbiJdfQ==