import debounce from 'debounce-promise';
import parcelWatcher from '@parcel/watcher';
import parseGitIgnore from 'parse-gitignore';
import path from 'path';
import fs from 'fs';
import _open from 'open';
// EventEmitter is a class name and expected to have PascalCase
// eslint-disable-next-line @typescript-eslint/naming-convention
import EventEmitter from 'events';
import { GetParameterCommand, ParameterNotFound, } from '@aws-sdk/client-ssm';
import { AmplifyPrompter, LogLevel, format, } from '@aws-amplify/cli-core';
import { createFilesChangesTracker, } from './files_changes_tracker.js';
import { AmplifyError, AmplifyUserError, BackendIdentifierConversions, } from '@aws-amplify/platform-core';
/**
 * CDK stores bootstrap version in parameter store. Example parameter name looks like /cdk-bootstrap/<qualifier>/version.
 * The default value for qualifier is hnb659fds, i.e. default parameter path is /cdk-bootstrap/hnb659fds/version.
 * The default qualifier is hardcoded value without any significance.
 * Ability to provide custom qualifier is intended for name isolation between automated tests of the CDK itself.
 * In order to use custom qualifier all stack synthesizers must be programmatically configured to use it.
 * That makes bootstraps with custom qualifier incompatible with Amplify Backend and we treat that setup as
 * not bootstrapped.
 * See: https://docs.aws.amazon.com/cdk/v2/guide/bootstrapping.html
 */
export const CDK_DEFAULT_BOOTSTRAP_VERSION_PARAMETER_NAME = 
// suppress spell checker, it is triggered by qualifier value.
// eslint-disable-next-line spellcheck/spell-checker
'/cdk-bootstrap/hnb659fds/version';
export const CDK_MIN_BOOTSTRAP_VERSION = 6;
/**
 * Constructs Amplify Console bootstrap URL for a given region
 * @param region AWS region
 * @returns Amplify Console bootstrap URL
 */
export const getBootstrapUrl = (region) => `https://${region}.console.aws.amazon.com/amplify/create/bootstrap?region=${region}`;
/**
 * Runs a file watcher and deploys
 */
export class FileWatchingSandbox extends EventEmitter {
    backendIdSandboxResolver;
    executor;
    ssmClient;
    printer;
    open;
    watcherSubscription;
    outputFilesExcludedFromWatch = ['.amplify'];
    filesChangesTracker;
    /**
     * Creates a watcher process for this instance
     */
    constructor(backendIdSandboxResolver, executor, ssmClient, printer, open = _open) {
        process.once('SIGINT', () => void this.stop());
        process.once('SIGTERM', () => void this.stop());
        super();
        this.backendIdSandboxResolver = backendIdSandboxResolver;
        this.executor = executor;
        this.ssmClient = ssmClient;
        this.printer = printer;
        this.open = open;
    }
    /**
     * @inheritdoc
     */
    emit(eventName, ...args) {
        return super.emit(eventName, ...args);
    }
    /**
     * @inheritdoc
     */
    on(eventName, listener) {
        return super.on(eventName, listener);
    }
    /**
     * @inheritdoc
     */
    start = async (options) => {
        const watchDir = options.dir ?? './amplify';
        const watchForChanges = options.watchForChanges ?? true;
        if (!fs.existsSync(watchDir)) {
            throw new AmplifyUserError('PathNotFoundError', {
                message: `${watchDir} does not exist.`,
                resolution: 'Make sure you are running this command from your project root directory.',
            });
        }
        this.filesChangesTracker = await createFilesChangesTracker(watchDir);
        const bootstrapped = await this.isBootstrapped();
        if (!bootstrapped) {
            this.printer.log('The given region has not been bootstrapped. Sign in to console as a Root user or Admin to complete the bootstrap process, then restart the sandbox.');
            // get region from an available sdk client;
            const region = await this.ssmClient.config.region();
            await this.open(getBootstrapUrl(region));
            return;
        }
        const ignoredPaths = this.getGitIgnoredPaths();
        this.outputFilesExcludedFromWatch =
            this.outputFilesExcludedFromWatch.concat(...ignoredPaths);
        await this.printSandboxNameInfo(options.identifier);
        // Since 'cdk deploy' is a relatively slow operation for a 'watch' process,
        // introduce a concurrency latch that tracks the state.
        // This way, if file change events arrive when a 'cdk deploy' is still executing,
        // we will batch them, and trigger another 'cdk deploy' after the current one finishes,
        // making sure 'cdk deploy's  always execute one at a time.
        // Here's a diagram showing the state transitions:
        // --------    file changed     --------------    file changed     --------------  file changed
        // |      | ------------------> |            | ------------------> |            | --------------|
        // | open |                     | deploying  |                     |   queued   |               |
        // |      | <------------------ |            | <------------------ |            | <-------------|
        // --------  'cdk deploy' done  --------------  'cdk deploy' done  --------------
        let latch = 'open';
        const deployAndWatch = debounce(async () => {
            latch = 'deploying';
            await this.deploy(options);
            // If latch is still 'deploying' after the 'await', that's fine,
            // but if it's 'queued', that means we need to deploy again
            while (latch === 'queued') {
                // TypeScript doesn't realize latch can change between 'awaits' ¯\_(ツ)_/¯,
                // and thinks the above 'while' condition is always 'false' without the cast
                latch = 'deploying';
                this.printer.log("[Sandbox] Detected file changes while previous deployment was in progress. Invoking 'sandbox' again");
                await this.deploy(options);
            }
            latch = 'open';
            this.emitWatching();
        });
        if (watchForChanges) {
            this.watcherSubscription = await parcelWatcher.subscribe(watchDir, async (_, events) => {
                // Log and track file changes.
                await Promise.all(events.map(({ type: eventName, path }) => {
                    this.filesChangesTracker.trackFileChange(path);
                    this.printer.log(`[Sandbox] Triggered due to a file ${eventName} event: ${path}`);
                }));
                if (latch === 'open') {
                    await deployAndWatch();
                }
                else {
                    // this means latch is either 'deploying' or 'queued'
                    latch = 'queued';
                    this.printer.log('[Sandbox] Previous deployment is still in progress. ' +
                        'Will queue for another deployment after this one finishes');
                }
            }, {
                ignore: this.outputFilesExcludedFromWatch.concat(...(options.exclude ?? [])),
            });
            // Start the first full deployment without waiting for a file change
            await deployAndWatch();
        }
        else {
            await this.deploy(options);
        }
    };
    /**
     * @inheritdoc
     */
    stop = async () => {
        this.printer.log(`[Sandbox] Shutting down`, LogLevel.DEBUG);
        // can be undefined if command exits before subscription
        await this.watcherSubscription?.unsubscribe();
    };
    /**
     * @inheritdoc
     */
    delete = async (options) => {
        this.printer.log('[Sandbox] Deleting all the resources in the sandbox environment...');
        await this.executor.destroy(await this.backendIdSandboxResolver(options.identifier));
        this.emit('successfulDeletion');
        this.printer.log('[Sandbox] Finished deleting.');
    };
    shouldValidateAppSources = () => {
        const snapshot = this.filesChangesTracker.getAndResetSnapshot();
        // if zero files changed this indicates initial deployment
        const shouldValidateOnColdStart = snapshot.hadTypeScriptFilesAtStart &&
            !snapshot.didAnyFileChangeSinceStart;
        return (shouldValidateOnColdStart ||
            snapshot.didAnyTypeScriptFileChangeSinceLastSnapshot);
    };
    deploy = async (options) => {
        try {
            const deployResult = await this.executor.deploy(await this.backendIdSandboxResolver(options.identifier), 
            // It's important to pass this as callback so that debounce does
            // not reset tracker prematurely
            this.shouldValidateAppSources);
            this.printer.log('[Sandbox] Deployment successful', LogLevel.DEBUG);
            this.emit('successfulDeployment', deployResult);
        }
        catch (error) {
            // Print a meaningful message
            this.printer.print(format.error(this.getErrorMessage(error)));
            this.emit('failedDeployment', error);
            // If the error is because of a non-allowed destructive change such as
            // https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cognito-userpool.html#cfn-cognito-userpool-aliasattributes
            // offer to recreate the sandbox or revert the change
            if (error instanceof AmplifyError &&
                error.name === 'CFNUpdateNotSupportedError') {
                await this.handleUnsupportedDestructiveChanges(options);
            }
            // else do not propagate and let the sandbox continue to run
        }
    };
    reset = async (options) => {
        await this.delete({ identifier: options.identifier });
        await this.start(options);
    };
    /**
     * Just a shorthand console log to indicate whenever watcher is going idle
     */
    emitWatching = () => {
        this.printer.log(`[Sandbox] Watching for file changes...`);
    };
    /**
     * Reads and parses .gitignore file and returns the list of paths
     */
    getGitIgnoredPaths = () => {
        const gitIgnoreFilePath = path.join(process.cwd(), '.gitignore');
        if (fs.existsSync(gitIgnoreFilePath)) {
            return parseGitIgnore
                .parse(gitIgnoreFilePath)
                .patterns.map((pattern) => pattern.startsWith('/') ? pattern.substring(1) : pattern)
                .filter((pattern) => {
                if (pattern.startsWith('!')) {
                    this.printer.log(`[Sandbox] Pattern ${pattern} found in .gitignore. "${pattern.substring(1)}" will not be watched if other patterns in .gitignore are excluding it.`);
                    return false;
                }
                return true;
            });
        }
        return [];
    };
    /**
     * Checks if a given region has been bootstrapped with >= min version using CDK bootstrap version parameter
     * stored in parameter store.
     * @returns A Boolean that represents if region has been bootstrapped.
     */
    isBootstrapped = async () => {
        try {
            const { Parameter: parameter } = await this.ssmClient.send(new GetParameterCommand({
                Name: CDK_DEFAULT_BOOTSTRAP_VERSION_PARAMETER_NAME,
            }));
            const bootstrapVersion = parameter?.Value;
            if (!bootstrapVersion ||
                Number(bootstrapVersion) < CDK_MIN_BOOTSTRAP_VERSION) {
                return false;
            }
            return true;
        }
        catch (e) {
            if (e instanceof ParameterNotFound) {
                return false;
            }
            // If we are unable to retrieve bootstrap version parameter due to other reasons(AccessDenied), we fail fast.
            throw e;
        }
    };
    /**
     * Generates a printable error message from the thrown error
     */
    getErrorMessage = (error) => {
        let message;
        if (error instanceof Error) {
            message = error.message;
            // Add the downstream exception
            if (error.cause && error.cause instanceof Error && error.cause.message) {
                message = `${message}\nCaused By: ${error.cause.message}\n`;
            }
            if (error instanceof AmplifyError && error.resolution) {
                message = `${message}\nResolution: ${error.resolution}\n`;
            }
        }
        else
            message = String(error);
        return message;
    };
    handleUnsupportedDestructiveChanges = async (options) => {
        this.printer.print(format.error('[Sandbox] We cannot deploy your new changes. You can either revert them or recreate your sandbox with the new changes (deleting all user data)'));
        // offer to recreate the sandbox with new properties
        const answer = await AmplifyPrompter.yesOrNo({
            message: 'Would you like to recreate your sandbox (deleting all user data)?',
            defaultValue: false,
        });
        if (answer) {
            await this.stop();
            await this.reset(options);
        }
        // else let the sandbox continue so customers can revert their changes
    };
    printSandboxNameInfo = async (sandboxIdentifier) => {
        const sandboxBackendId = await this.backendIdSandboxResolver(sandboxIdentifier);
        const stackName = BackendIdentifierConversions.toStackName(sandboxBackendId);
        this.printer.log(format.indent(format.highlight(format.bold('\nAmplify Sandbox\n'))));
        this.printer.log(format.indent(`${format.bold('Identifier:')} \t${sandboxBackendId.name}`));
        this.printer.log(format.indent(`${format.bold('Stack:')} \t${stackName}`));
        if (!sandboxIdentifier) {
            this.printer.log(`${format.indent(format.dim('\nTo specify a different sandbox identifier, use '))}${format.bold('--identifier')}`);
        }
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsZV93YXRjaGluZ19zYW5kYm94LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2ZpbGVfd2F0Y2hpbmdfc2FuZGJveC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLFFBQVEsTUFBTSxrQkFBa0IsQ0FBQztBQUN4QyxPQUFPLGFBQTRCLE1BQU0saUJBQWlCLENBQUM7QUFTM0QsT0FBTyxjQUFjLE1BQU0saUJBQWlCLENBQUM7QUFDN0MsT0FBTyxJQUFJLE1BQU0sTUFBTSxDQUFDO0FBQ3hCLE9BQU8sRUFBRSxNQUFNLElBQUksQ0FBQztBQUNwQixPQUFPLEtBQUssTUFBTSxNQUFNLENBQUM7QUFDekIsK0RBQStEO0FBQy9ELGdFQUFnRTtBQUNoRSxPQUFPLFlBQVksTUFBTSxRQUFRLENBQUM7QUFDbEMsT0FBTyxFQUNMLG1CQUFtQixFQUNuQixpQkFBaUIsR0FFbEIsTUFBTSxxQkFBcUIsQ0FBQztBQUM3QixPQUFPLEVBQ0wsZUFBZSxFQUNmLFFBQVEsRUFFUixNQUFNLEdBQ1AsTUFBTSx1QkFBdUIsQ0FBQztBQUMvQixPQUFPLEVBRUwseUJBQXlCLEdBQzFCLE1BQU0sNEJBQTRCLENBQUM7QUFDcEMsT0FBTyxFQUNMLFlBQVksRUFDWixnQkFBZ0IsRUFDaEIsNEJBQTRCLEdBQzdCLE1BQU0sNEJBQTRCLENBQUM7QUFFcEM7Ozs7Ozs7OztHQVNHO0FBQ0gsTUFBTSxDQUFDLE1BQU0sNENBQTRDO0FBQ3ZELDhEQUE4RDtBQUM5RCxvREFBb0Q7QUFDcEQsa0NBQWtDLENBQUM7QUFDckMsTUFBTSxDQUFDLE1BQU0seUJBQXlCLEdBQUcsQ0FBQyxDQUFDO0FBRTNDOzs7O0dBSUc7QUFDSCxNQUFNLENBQUMsTUFBTSxlQUFlLEdBQUcsQ0FBQyxNQUFjLEVBQUUsRUFBRSxDQUNoRCxXQUFXLE1BQU0sMkRBQTJELE1BQU0sRUFBRSxDQUFDO0FBRXZGOztHQUVHO0FBQ0gsTUFBTSxPQUFPLG1CQUFvQixTQUFRLFlBQVk7SUFT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Q0FBQyxNQUFNLGdCQUFnQixDQUFDLElBQUksRUFBRSxDQUFDLENBQzFFLENBQUM7UUFDRixJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxTQUFTLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDM0UsSUFBSSxDQUFDLGlCQUFpQixFQUFFO1lBQ3RCLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUNkLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FDZCxNQUFNLENBQUMsR0FBRyxDQUFDLG1EQUFtRCxDQUFDLENBQ2hFLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsRUFBRSxDQUNsQyxDQUFDO1NBQ0g7SUFDSCxDQUFDLENBQUM7Q0FDSCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBkZWJvdW5jZSBmcm9tICdkZWJvdW5jZS1wcm9taXNlJztcbmltcG9ydCBwYXJjZWxXYXRjaGVyLCB7IHN1YnNjcmliZSB9IGZyb20gJ0BwYXJjZWwvd2F0Y2hlcic7XG5pbXBvcnQgeyBBbXBsaWZ5U2FuZGJveEV4ZWN1dG9yIH0gZnJvbSAnLi9zYW5kYm94X2V4ZWN1dG9yLmpzJztcbmltcG9ydCB7XG4gIEJhY2tlbmRJZFNhbmRib3hSZXNvbHZlcixcbiAgU2FuZGJveCxcbiAgU2FuZGJveERlbGV0ZU9wdGlvbnMsXG4gIFNhbmRib3hFdmVudHMsXG4gIFNhbmRib3hPcHRpb25zLFxufSBmcm9tICcuL3NhbmRib3guanMnO1xuaW1wb3J0IHBhcnNlR2l0SWdub3JlIGZyb20gJ3BhcnNlLWdpdGlnbm9yZSc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCBmcyBmcm9tICdmcyc7XG5pbXBvcnQgX29wZW4gZnJvbSAnb3Blbic7XG4vLyBFdmVudEVtaXR0ZXIgaXMgYSBjbGFzcyBuYW1lIGFuZCBleHBlY3RlZCB0byBoYXZlIFBhc2NhbENhc2Vcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRzJztcbmltcG9ydCB7XG4gIEdldFBhcmFtZXRlckNvbW1hbmQsXG4gIFBhcmFtZXRlck5vdEZvdW5kLFxuICBTU01DbGllbnQsXG59IGZyb20gJ0Bhd3Mtc2RrL2NsaWVudC1zc20nO1xuaW1wb3J0IHtcbiAgQW1wbGlmeVByb21wdGVyLFxuICBMb2dMZXZlbCxcbiAgUHJpbnRlcixcbiAgZm9ybWF0LFxufSBmcm9tICdAYXdzLWFtcGxpZnkvY2xpLWNvcmUnO1xuaW1wb3J0IHtcbiAgRmlsZXNDaGFuZ2VzVHJhY2tlcixcbiAgY3JlYXRlRmlsZXNDaGFuZ2VzVHJhY2tlcixcbn0gZnJvbSAnLi9maWxlc19jaGFuZ2VzX3RyYWNrZXIuanMnO1xuaW1wb3J0IHtcbiAgQW1wbGlmeUVycm9yLFxuICBBbXBsaWZ5VXNlckVycm9yLFxuICBCYWNrZW5kSWRlbnRpZmllckNvbnZlcnNpb25zLFxufSBmcm9tICdAYXdzLWFtcGxpZnkvcGxhdGZvcm0tY29yZSc7XG5cbi8qKlxuICogQ0RLIHN0b3JlcyBib290c3RyYXAgdmVyc2lvbiBpbiBwYXJhbWV0ZXIgc3RvcmUuIEV4YW1wbGUgcGFyYW1ldGVyIG5hbWUgbG9va3MgbGlrZSAvY2RrLWJvb3RzdHJhcC88cXVhbGlmaWVyPi92ZXJzaW9uLlxuICogVGhlIGRlZmF1bHQgdmFsdWUgZm9yIHF1YWxpZmllciBpcyBobmI2NTlmZHMsIGkuZS4gZGVmYXVsdCBwYXJhbWV0ZXIgcGF0aCBpcyAvY2RrLWJvb3RzdHJhcC9obmI2NTlmZHMvdmVyc2lvbi5cbiAqIFRoZSBkZWZhdWx0IHF1YWxpZmllciBpcyBoYXJkY29kZWQgdmFsdWUgd2l0aG91dCBhbnkgc2lnbmlmaWNhbmNlLlxuICogQWJpbGl0eSB0byBwcm92aWRlIGN1c3RvbSBxdWFsaWZpZXIgaXMgaW50ZW5kZWQgZm9yIG5hbWUgaXNvbGF0aW9uIGJldHdlZW4gYXV0b21hdGVkIHRlc3RzIG9mIHRoZSBDREsgaXRzZWxmLlxuICogSW4gb3JkZXIgdG8gdXNlIGN1c3RvbSBxdWFsaWZpZXIgYWxsIHN0YWNrIHN5bnRoZXNpemVycyBtdXN0IGJlIHByb2dyYW1tYXRpY2FsbHkgY29uZmlndXJlZCB0byB1c2UgaXQuXG4gKiBUaGF0IG1ha2VzIGJvb3RzdHJhcHMgd2l0aCBjdXN0b20gcXVhbGlmaWVyIGluY29tcGF0aWJsZSB3aXRoIEFtcGxpZnkgQmFja2VuZCBhbmQgd2UgdHJlYXQgdGhhdCBzZXR1cCBhc1xuICogbm90IGJvb3RzdHJhcHBlZC5cbiAqIFNlZTogaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2Nkay92Mi9ndWlkZS9ib290c3RyYXBwaW5nLmh0bWxcbiAqL1xuZXhwb3J0IGNvbnN0IENES19ERUZBVUxUX0JPT1RTVFJBUF9WRVJTSU9OX1BBUkFNRVRFUl9OQU1FID1cbiAgLy8gc3VwcHJlc3Mgc3BlbGwgY2hlY2tlciwgaXQgaXMgdHJpZ2dlcmVkIGJ5IHF1YWxpZmllciB2YWx1ZS5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHNwZWxsY2hlY2svc3BlbGwtY2hlY2tlclxuICAnL2Nkay1ib290c3RyYXAvaG5iNjU5ZmRzL3ZlcnNpb24nO1xuZXhwb3J0IGNvbnN0IENES19NSU5fQk9PVFNUUkFQX1ZFUlNJT04gPSA2O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgQW1wbGlmeSBDb25zb2xlIGJvb3RzdHJhcCBVUkwgZm9yIGEgZ2l2ZW4gcmVnaW9uXG4gKiBAcGFyYW0gcmVnaW9uIEFXUyByZWdpb25cbiAqIEByZXR1cm5zIEFtcGxpZnkgQ29uc29sZSBib290c3RyYXAgVVJMXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRCb290c3RyYXBVcmwgPSAocmVnaW9uOiBzdHJpbmcpID0+XG4gIGBodHRwczovLyR7cmVnaW9ufS5jb25zb2xlLmF3cy5hbWF6b24uY29tL2FtcGxpZnkvY3JlYXRlL2Jvb3RzdHJhcD9yZWdpb249JHtyZWdpb259YDtcblxuLyoqXG4gKiBSdW5zIGEgZmlsZSB3YXRjaGVyIGFuZCBkZXBsb3lzXG4gKi9cbmV4cG9ydCBjbGFzcyBGaWxlV2F0Y2hpbmdTYW5kYm94IGV4dGVuZHMgRXZlbnRFbWl0dGVyIGltcGxlbWVudHMgU2FuZGJveCB7XG4gIHByaXZhdGUgd2F0Y2hlclN1YnNjcmlwdGlvbjogQXdhaXRlZDxSZXR1cm5UeXBlPHR5cGVvZiBzdWJzY3JpYmU+PjtcbiAgcHJpdmF0ZSBvdXRwdXRGaWxlc0V4Y2x1ZGVkRnJvbVdhdGNoID0gWycuYW1wbGlmeSddO1xuICBwcml2YXRlIGZpbGVzQ2hhbmdlc1RyYWNrZXI6IEZpbGVzQ2hhbmdlc1RyYWNrZXI7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB3YXRjaGVyIHByb2Nlc3MgZm9yIHRoaXMgaW5zdGFuY2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgYmFja2VuZElkU2FuZGJveFJlc29sdmVyOiBCYWNrZW5kSWRTYW5kYm94UmVzb2x2ZXIsXG4gICAgcHJpdmF0ZSByZWFkb25seSBleGVjdXRvcjogQW1wbGlmeVNhbmRib3hFeGVjdXRvcixcbiAgICBwcml2YXRlIHJlYWRvbmx5IHNzbUNsaWVudDogU1NNQ2xpZW50LFxuICAgIHByaXZhdGUgcmVhZG9ubHkgcHJpbnRlcjogUHJpbnRlcixcbiAgICBwcml2YXRlIHJlYWRvbmx5IG9wZW4gPSBfb3BlblxuICApIHtcbiAgICBwcm9jZXNzLm9uY2UoJ1NJR0lOVCcsICgpID0+IHZvaWQgdGhpcy5zdG9wKCkpO1xuICAgIHByb2Nlc3Mub25jZSgnU0lHVEVSTScsICgpID0+IHZvaWQgdGhpcy5zdG9wKCkpO1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXRkb2NcbiAgICovXG4gIG92ZXJyaWRlIGVtaXQoZXZlbnROYW1lOiBTYW5kYm94RXZlbnRzLCAuLi5hcmdzOiB1bmtub3duW10pOiBib29sZWFuIHtcbiAgICByZXR1cm4gc3VwZXIuZW1pdChldmVudE5hbWUsIC4uLmFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0ZG9jXG4gICAqL1xuICBvdmVycmlkZSBvbihcbiAgICBldmVudE5hbWU6IFNhbmRib3hFdmVudHMsXG4gICAgbGlzdGVuZXI6ICguLi5hcmdzOiB1bmtub3duW10pID0+IHZvaWRcbiAgKTogdGhpcyB7XG4gICAgcmV0dXJuIHN1cGVyLm9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0ZG9jXG4gICAqL1xuICBzdGFydCA9IGFzeW5jIChvcHRpb25zOiBTYW5kYm94T3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IHdhdGNoRGlyID0gb3B0aW9ucy5kaXIgPz8gJy4vYW1wbGlmeSc7XG4gICAgY29uc3Qgd2F0Y2hGb3JDaGFuZ2VzID0gb3B0aW9ucy53YXRjaEZvckNoYW5nZXMgPz8gdHJ1ZTtcblxuICAgIGlmICghZnMuZXhpc3RzU3luYyh3YXRjaERpcikpIHtcbiAgICAgIHRocm93IG5ldyBBbXBsaWZ5VXNlckVycm9yKCdQYXRoTm90Rm91bmRFcnJvcicsIHtcbiAgICAgICAgbWVzc2FnZTogYCR7d2F0Y2hEaXJ9IGRvZXMgbm90IGV4aXN0LmAsXG4gICAgICAgIHJlc29sdXRpb246XG4gICAgICAgICAgJ01ha2Ugc3VyZSB5b3UgYXJlIHJ1bm5pbmcgdGhpcyBjb21tYW5kIGZyb20geW91ciBwcm9qZWN0IHJvb3QgZGlyZWN0b3J5LicsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmZpbGVzQ2hhbmdlc1RyYWNrZXIgPSBhd2FpdCBjcmVhdGVGaWxlc0NoYW5nZXNUcmFja2VyKHdhdGNoRGlyKTtcbiAgICBjb25zdCBib290c3RyYXBwZWQgPSBhd2FpdCB0aGlzLmlzQm9vdHN0cmFwcGVkKCk7XG4gICAgaWYgKCFib290c3RyYXBwZWQpIHtcbiAgICAgIHRoaXMucHJpbnRlci5sb2coXG4gICAgICAgICdUaGUgZ2l2ZW4gcmVnaW9uIGhhcyBub3QgYmVlbiBib290c3RyYXBwZWQuIFNpZ24gaW4gdG8gY29uc29sZSBhcyBhIFJvb3QgdXNlciBvciBBZG1pbiB0byBjb21wbGV0ZSB0aGUgYm9vdHN0cmFwIHByb2Nlc3MsIHRoZW4gcmVzdGFydCB0aGUgc2FuZGJveC4nXG4gICAgICApO1xuICAgICAgLy8gZ2V0IHJlZ2lvbiBmcm9tIGFuIGF2YWlsYWJsZSBzZGsgY2xpZW50O1xuICAgICAgY29uc3QgcmVnaW9uID0gYXdhaXQgdGhpcy5zc21DbGllbnQuY29uZmlnLnJlZ2lvbigpO1xuICAgICAgYXdhaXQgdGhpcy5vcGVuKGdldEJvb3RzdHJhcFVybChyZWdpb24pKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBpZ25vcmVkUGF0aHMgPSB0aGlzLmdldEdpdElnbm9yZWRQYXRocygpO1xuICAgIHRoaXMub3V0cHV0RmlsZXNFeGNsdWRlZEZyb21XYXRjaCA9XG4gICAgICB0aGlzLm91dHB1dEZpbGVzRXhjbHVkZWRGcm9tV2F0Y2guY29uY2F0KC4uLmlnbm9yZWRQYXRocyk7XG5cbiAgICBhd2FpdCB0aGlzLnByaW50U2FuZGJveE5hbWVJbmZvKG9wdGlvbnMuaWRlbnRpZmllcik7XG5cbiAgICAvLyBTaW5jZSAnY2RrIGRlcGxveScgaXMgYSByZWxhdGl2ZWx5IHNsb3cgb3BlcmF0aW9uIGZvciBhICd3YXRjaCcgcHJvY2VzcyxcbiAgICAvLyBpbnRyb2R1Y2UgYSBjb25jdXJyZW5jeSBsYXRjaCB0aGF0IHRyYWNrcyB0aGUgc3RhdGUuXG4gICAgLy8gVGhpcyB3YXksIGlmIGZpbGUgY2hhbmdlIGV2ZW50cyBhcnJpdmUgd2hlbiBhICdjZGsgZGVwbG95JyBpcyBzdGlsbCBleGVjdXRpbmcsXG4gICAgLy8gd2Ugd2lsbCBiYXRjaCB0aGVtLCBhbmQgdHJpZ2dlciBhbm90aGVyICdjZGsgZGVwbG95JyBhZnRlciB0aGUgY3VycmVudCBvbmUgZmluaXNoZXMsXG4gICAgLy8gbWFraW5nIHN1cmUgJ2NkayBkZXBsb3kncyAgYWx3YXlzIGV4ZWN1dGUgb25lIGF0IGEgdGltZS5cbiAgICAvLyBIZXJlJ3MgYSBkaWFncmFtIHNob3dpbmcgdGhlIHN0YXRlIHRyYW5zaXRpb25zOlxuXG4gICAgLy8gLS0tLS0tLS0gICAgZmlsZSBjaGFuZ2VkICAgICAtLS0tLS0tLS0tLS0tLSAgICBmaWxlIGNoYW5nZWQgICAgIC0tLS0tLS0tLS0tLS0tICBmaWxlIGNoYW5nZWRcbiAgICAvLyB8ICAgICAgfCAtLS0tLS0tLS0tLS0tLS0tLS0+IHwgICAgICAgICAgICB8IC0tLS0tLS0tLS0tLS0tLS0tLT4gfCAgICAgICAgICAgIHwgLS0tLS0tLS0tLS0tLS18XG4gICAgLy8gfCBvcGVuIHwgICAgICAgICAgICAgICAgICAgICB8IGRlcGxveWluZyAgfCAgICAgICAgICAgICAgICAgICAgIHwgICBxdWV1ZWQgICB8ICAgICAgICAgICAgICAgfFxuICAgIC8vIHwgICAgICB8IDwtLS0tLS0tLS0tLS0tLS0tLS0gfCAgICAgICAgICAgIHwgPC0tLS0tLS0tLS0tLS0tLS0tLSB8ICAgICAgICAgICAgfCA8LS0tLS0tLS0tLS0tLXxcbiAgICAvLyAtLS0tLS0tLSAgJ2NkayBkZXBsb3knIGRvbmUgIC0tLS0tLS0tLS0tLS0tICAnY2RrIGRlcGxveScgZG9uZSAgLS0tLS0tLS0tLS0tLS1cblxuICAgIGxldCBsYXRjaDogJ29wZW4nIHwgJ2RlcGxveWluZycgfCAncXVldWVkJyA9ICdvcGVuJztcblxuICAgIGNvbnN0IGRlcGxveUFuZFdhdGNoID0gZGVib3VuY2UoYXN5bmMgKCkgPT4ge1xuICAgICAgbGF0Y2ggPSAnZGVwbG95aW5nJztcbiAgICAgIGF3YWl0IHRoaXMuZGVwbG95KG9wdGlvbnMpO1xuXG4gICAgICAvLyBJZiBsYXRjaCBpcyBzdGlsbCAnZGVwbG95aW5nJyBhZnRlciB0aGUgJ2F3YWl0JywgdGhhdCdzIGZpbmUsXG4gICAgICAvLyBidXQgaWYgaXQncyAncXVldWVkJywgdGhhdCBtZWFucyB3ZSBuZWVkIHRvIGRlcGxveSBhZ2FpblxuICAgICAgd2hpbGUgKChsYXRjaCBhcyAnZGVwbG95aW5nJyB8ICdxdWV1ZWQnKSA9PT0gJ3F1ZXVlZCcpIHtcbiAgICAgICAgLy8gVHlwZVNjcmlwdCBkb2Vzbid0IHJlYWxpemUgbGF0Y2ggY2FuIGNoYW5nZSBiZXR3ZWVuICdhd2FpdHMnIMKvXFxfKOODhClfL8KvLFxuICAgICAgICAvLyBhbmQgdGhpbmtzIHRoZSBhYm92ZSAnd2hpbGUnIGNvbmRpdGlvbiBpcyBhbHdheXMgJ2ZhbHNlJyB3aXRob3V0IHRoZSBjYXN0XG4gICAgICAgIGxhdGNoID0gJ2RlcGxveWluZyc7XG4gICAgICAgIHRoaXMucHJpbnRlci5sb2coXG4gICAgICAgICAgXCJbU2FuZGJveF0gRGV0ZWN0ZWQgZmlsZSBjaGFuZ2VzIHdoaWxlIHByZXZpb3VzIGRlcGxveW1lbnQgd2FzIGluIHByb2dyZXNzLiBJbnZva2luZyAnc2FuZGJveCcgYWdhaW5cIlxuICAgICAgICApO1xuICAgICAgICBhd2FpdCB0aGlzLmRlcGxveShvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGxhdGNoID0gJ29wZW4nO1xuICAgICAgdGhpcy5lbWl0V2F0Y2hpbmcoKTtcbiAgICB9KTtcblxuICAgIGlmICh3YXRjaEZvckNoYW5nZXMpIHtcbiAgICAgIHRoaXMud2F0Y2hlclN1YnNjcmlwdGlvbiA9IGF3YWl0IHBhcmNlbFdhdGNoZXIuc3Vic2NyaWJlKFxuICAgICAgICB3YXRjaERpcixcbiAgICAgICAgYXN5bmMgKF8sIGV2ZW50cykgPT4ge1xuICAgICAgICAgIC8vIExvZyBhbmQgdHJhY2sgZmlsZSBjaGFuZ2VzLlxuICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgICAgZXZlbnRzLm1hcCgoeyB0eXBlOiBldmVudE5hbWUsIHBhdGggfSkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLmZpbGVzQ2hhbmdlc1RyYWNrZXIudHJhY2tGaWxlQ2hhbmdlKHBhdGgpO1xuICAgICAgICAgICAgICB0aGlzLnByaW50ZXIubG9nKFxuICAgICAgICAgICAgICAgIGBbU2FuZGJveF0gVHJpZ2dlcmVkIGR1ZSB0byBhIGZpbGUgJHtldmVudE5hbWV9IGV2ZW50OiAke3BhdGh9YFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChsYXRjaCA9PT0gJ29wZW4nKSB7XG4gICAgICAgICAgICBhd2FpdCBkZXBsb3lBbmRXYXRjaCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGlzIG1lYW5zIGxhdGNoIGlzIGVpdGhlciAnZGVwbG95aW5nJyBvciAncXVldWVkJ1xuICAgICAgICAgICAgbGF0Y2ggPSAncXVldWVkJztcbiAgICAgICAgICAgIHRoaXMucHJpbnRlci5sb2coXG4gICAgICAgICAgICAgICdbU2FuZGJveF0gUHJldmlvdXMgZGVwbG95bWVudCBpcyBzdGlsbCBpbiBwcm9ncmVzcy4gJyArXG4gICAgICAgICAgICAgICAgJ1dpbGwgcXVldWUgZm9yIGFub3RoZXIgZGVwbG95bWVudCBhZnRlciB0aGlzIG9uZSBmaW5pc2hlcydcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgaWdub3JlOiB0aGlzLm91dHB1dEZpbGVzRXhjbHVkZWRGcm9tV2F0Y2guY29uY2F0KFxuICAgICAgICAgICAgLi4uKG9wdGlvbnMuZXhjbHVkZSA/PyBbXSlcbiAgICAgICAgICApLFxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgLy8gU3RhcnQgdGhlIGZpcnN0IGZ1bGwgZGVwbG95bWVudCB3aXRob3V0IHdhaXRpbmcgZm9yIGEgZmlsZSBjaGFuZ2VcbiAgICAgIGF3YWl0IGRlcGxveUFuZFdhdGNoKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF3YWl0IHRoaXMuZGVwbG95KG9wdGlvbnMpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXRkb2NcbiAgICovXG4gIHN0b3AgPSBhc3luYyAoKSA9PiB7XG4gICAgdGhpcy5wcmludGVyLmxvZyhgW1NhbmRib3hdIFNodXR0aW5nIGRvd25gLCBMb2dMZXZlbC5ERUJVRyk7XG4gICAgLy8gY2FuIGJlIHVuZGVmaW5lZCBpZiBjb21tYW5kIGV4aXRzIGJlZm9yZSBzdWJzY3JpcHRpb25cbiAgICBhd2FpdCB0aGlzLndhdGNoZXJTdWJzY3JpcHRpb24/LnVuc3Vic2NyaWJlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0ZG9jXG4gICAqL1xuICBkZWxldGUgPSBhc3luYyAob3B0aW9uczogU2FuZGJveERlbGV0ZU9wdGlvbnMpID0+IHtcbiAgICB0aGlzLnByaW50ZXIubG9nKFxuICAgICAgJ1tTYW5kYm94XSBEZWxldGluZyBhbGwgdGhlIHJlc291cmNlcyBpbiB0aGUgc2FuZGJveCBlbnZpcm9ubWVudC4uLidcbiAgICApO1xuICAgIGF3YWl0IHRoaXMuZXhlY3V0b3IuZGVzdHJveShcbiAgICAgIGF3YWl0IHRoaXMuYmFja2VuZElkU2FuZGJveFJlc29sdmVyKG9wdGlvbnMuaWRlbnRpZmllcilcbiAgICApO1xuICAgIHRoaXMuZW1pdCgnc3VjY2Vzc2Z1bERlbGV0aW9uJyk7XG4gICAgdGhpcy5wcmludGVyLmxvZygnW1NhbmRib3hdIEZpbmlzaGVkIGRlbGV0aW5nLicpO1xuICB9O1xuXG4gIHByaXZhdGUgc2hvdWxkVmFsaWRhdGVBcHBTb3VyY2VzID0gKCk6IGJvb2xlYW4gPT4ge1xuICAgIGNvbnN0IHNuYXBzaG90ID0gdGhpcy5maWxlc0NoYW5nZXNUcmFja2VyLmdldEFuZFJlc2V0U25hcHNob3QoKTtcbiAgICAvLyBpZiB6ZXJvIGZpbGVzIGNoYW5nZWQgdGhpcyBpbmRpY2F0ZXMgaW5pdGlhbCBkZXBsb3ltZW50XG4gICAgY29uc3Qgc2hvdWxkVmFsaWRhdGVPbkNvbGRTdGFydCA9XG4gICAgICBzbmFwc2hvdC5oYWRUeXBlU2NyaXB0RmlsZXNBdFN0YXJ0ICYmXG4gICAgICAhc25hcHNob3QuZGlkQW55RmlsZUNoYW5nZVNpbmNlU3RhcnQ7XG4gICAgcmV0dXJuIChcbiAgICAgIHNob3VsZFZhbGlkYXRlT25Db2xkU3RhcnQgfHxcbiAgICAgIHNuYXBzaG90LmRpZEFueVR5cGVTY3JpcHRGaWxlQ2hhbmdlU2luY2VMYXN0U25hcHNob3RcbiAgICApO1xuICB9O1xuXG4gIHByaXZhdGUgZGVwbG95ID0gYXN5bmMgKG9wdGlvbnM6IFNhbmRib3hPcHRpb25zKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRlcGxveVJlc3VsdCA9IGF3YWl0IHRoaXMuZXhlY3V0b3IuZGVwbG95KFxuICAgICAgICBhd2FpdCB0aGlzLmJhY2tlbmRJZFNhbmRib3hSZXNvbHZlcihvcHRpb25zLmlkZW50aWZpZXIpLFxuICAgICAgICAvLyBJdCdzIGltcG9ydGFudCB0byBwYXNzIHRoaXMgYXMgY2FsbGJhY2sgc28gdGhhdCBkZWJvdW5jZSBkb2VzXG4gICAgICAgIC8vIG5vdCByZXNldCB0cmFja2VyIHByZW1hdHVyZWx5XG4gICAgICAgIHRoaXMuc2hvdWxkVmFsaWRhdGVBcHBTb3VyY2VzXG4gICAgICApO1xuICAgICAgdGhpcy5wcmludGVyLmxvZygnW1NhbmRib3hdIERlcGxveW1lbnQgc3VjY2Vzc2Z1bCcsIExvZ0xldmVsLkRFQlVHKTtcbiAgICAgIHRoaXMuZW1pdCgnc3VjY2Vzc2Z1bERlcGxveW1lbnQnLCBkZXBsb3lSZXN1bHQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBQcmludCBhIG1lYW5pbmdmdWwgbWVzc2FnZVxuICAgICAgdGhpcy5wcmludGVyLnByaW50KGZvcm1hdC5lcnJvcih0aGlzLmdldEVycm9yTWVzc2FnZShlcnJvcikpKTtcbiAgICAgIHRoaXMuZW1pdCgnZmFpbGVkRGVwbG95bWVudCcsIGVycm9yKTtcblxuICAgICAgLy8gSWYgdGhlIGVycm9yIGlzIGJlY2F1c2Ugb2YgYSBub24tYWxsb3dlZCBkZXN0cnVjdGl2ZSBjaGFuZ2Ugc3VjaCBhc1xuICAgICAgLy8gaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FXU0Nsb3VkRm9ybWF0aW9uL2xhdGVzdC9Vc2VyR3VpZGUvYXdzLXJlc291cmNlLWNvZ25pdG8tdXNlcnBvb2wuaHRtbCNjZm4tY29nbml0by11c2VycG9vbC1hbGlhc2F0dHJpYnV0ZXNcbiAgICAgIC8vIG9mZmVyIHRvIHJlY3JlYXRlIHRoZSBzYW5kYm94IG9yIHJldmVydCB0aGUgY2hhbmdlXG4gICAgICBpZiAoXG4gICAgICAgIGVycm9yIGluc3RhbmNlb2YgQW1wbGlmeUVycm9yICYmXG4gICAgICAgIGVycm9yLm5hbWUgPT09ICdDRk5VcGRhdGVOb3RTdXBwb3J0ZWRFcnJvcidcbiAgICAgICkge1xuICAgICAgICBhd2FpdCB0aGlzLmhhbmRsZVVuc3VwcG9ydGVkRGVzdHJ1Y3RpdmVDaGFuZ2VzKG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgLy8gZWxzZSBkbyBub3QgcHJvcGFnYXRlIGFuZCBsZXQgdGhlIHNhbmRib3ggY29udGludWUgdG8gcnVuXG4gICAgfVxuICB9O1xuXG4gIHByaXZhdGUgcmVzZXQgPSBhc3luYyAob3B0aW9uczogU2FuZGJveE9wdGlvbnMpID0+IHtcbiAgICBhd2FpdCB0aGlzLmRlbGV0ZSh7IGlkZW50aWZpZXI6IG9wdGlvbnMuaWRlbnRpZmllciB9KTtcbiAgICBhd2FpdCB0aGlzLnN0YXJ0KG9wdGlvbnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBKdXN0IGEgc2hvcnRoYW5kIGNvbnNvbGUgbG9nIHRvIGluZGljYXRlIHdoZW5ldmVyIHdhdGNoZXIgaXMgZ29pbmcgaWRsZVxuICAgKi9cbiAgcHJpdmF0ZSBlbWl0V2F0Y2hpbmcgPSAoKSA9PiB7XG4gICAgdGhpcy5wcmludGVyLmxvZyhgW1NhbmRib3hdIFdhdGNoaW5nIGZvciBmaWxlIGNoYW5nZXMuLi5gKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVhZHMgYW5kIHBhcnNlcyAuZ2l0aWdub3JlIGZpbGUgYW5kIHJldHVybnMgdGhlIGxpc3Qgb2YgcGF0aHNcbiAgICovXG4gIHByaXZhdGUgZ2V0R2l0SWdub3JlZFBhdGhzID0gKCkgPT4ge1xuICAgIGNvbnN0IGdpdElnbm9yZUZpbGVQYXRoID0gcGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICcuZ2l0aWdub3JlJyk7XG4gICAgaWYgKGZzLmV4aXN0c1N5bmMoZ2l0SWdub3JlRmlsZVBhdGgpKSB7XG4gICAgICByZXR1cm4gcGFyc2VHaXRJZ25vcmVcbiAgICAgICAgLnBhcnNlKGdpdElnbm9yZUZpbGVQYXRoKVxuICAgICAgICAucGF0dGVybnMubWFwKChwYXR0ZXJuOiBzdHJpbmcpID0+XG4gICAgICAgICAgcGF0dGVybi5zdGFydHNXaXRoKCcvJykgPyBwYXR0ZXJuLnN1YnN0cmluZygxKSA6IHBhdHRlcm5cbiAgICAgICAgKVxuICAgICAgICAuZmlsdGVyKChwYXR0ZXJuOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBpZiAocGF0dGVybi5zdGFydHNXaXRoKCchJykpIHtcbiAgICAgICAgICAgIHRoaXMucHJpbnRlci5sb2coXG4gICAgICAgICAgICAgIGBbU2FuZGJveF0gUGF0dGVybiAke3BhdHRlcm59IGZvdW5kIGluIC5naXRpZ25vcmUuIFwiJHtwYXR0ZXJuLnN1YnN0cmluZyhcbiAgICAgICAgICAgICAgICAxXG4gICAgICAgICAgICAgICl9XCIgd2lsbCBub3QgYmUgd2F0Y2hlZCBpZiBvdGhlciBwYXR0ZXJucyBpbiAuZ2l0aWdub3JlIGFyZSBleGNsdWRpbmcgaXQuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIGdpdmVuIHJlZ2lvbiBoYXMgYmVlbiBib290c3RyYXBwZWQgd2l0aCA+PSBtaW4gdmVyc2lvbiB1c2luZyBDREsgYm9vdHN0cmFwIHZlcnNpb24gcGFyYW1ldGVyXG4gICAqIHN0b3JlZCBpbiBwYXJhbWV0ZXIgc3RvcmUuXG4gICAqIEByZXR1cm5zIEEgQm9vbGVhbiB0aGF0IHJlcHJlc2VudHMgaWYgcmVnaW9uIGhhcyBiZWVuIGJvb3RzdHJhcHBlZC5cbiAgICovXG4gIHByaXZhdGUgaXNCb290c3RyYXBwZWQgPSBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgUGFyYW1ldGVyOiBwYXJhbWV0ZXIgfSA9IGF3YWl0IHRoaXMuc3NtQ2xpZW50LnNlbmQoXG4gICAgICAgIG5ldyBHZXRQYXJhbWV0ZXJDb21tYW5kKHtcbiAgICAgICAgICBOYW1lOiBDREtfREVGQVVMVF9CT09UU1RSQVBfVkVSU0lPTl9QQVJBTUVURVJfTkFNRSxcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGJvb3RzdHJhcFZlcnNpb24gPSBwYXJhbWV0ZXI/LlZhbHVlO1xuICAgICAgaWYgKFxuICAgICAgICAhYm9vdHN0cmFwVmVyc2lvbiB8fFxuICAgICAgICBOdW1iZXIoYm9vdHN0cmFwVmVyc2lvbikgPCBDREtfTUlOX0JPT1RTVFJBUF9WRVJTSU9OXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBQYXJhbWV0ZXJOb3RGb3VuZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBJZiB3ZSBhcmUgdW5hYmxlIHRvIHJldHJpZXZlIGJvb3RzdHJhcCB2ZXJzaW9uIHBhcmFtZXRlciBkdWUgdG8gb3RoZXIgcmVhc29ucyhBY2Nlc3NEZW5pZWQpLCB3ZSBmYWlsIGZhc3QuXG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgcHJpbnRhYmxlIGVycm9yIG1lc3NhZ2UgZnJvbSB0aGUgdGhyb3duIGVycm9yXG4gICAqL1xuICBwcml2YXRlIGdldEVycm9yTWVzc2FnZSA9IChlcnJvcjogdW5rbm93bikgPT4ge1xuICAgIGxldCBtZXNzYWdlO1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICBtZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcblxuICAgICAgLy8gQWRkIHRoZSBkb3duc3RyZWFtIGV4Y2VwdGlvblxuICAgICAgaWYgKGVycm9yLmNhdXNlICYmIGVycm9yLmNhdXNlIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IuY2F1c2UubWVzc2FnZSkge1xuICAgICAgICBtZXNzYWdlID0gYCR7bWVzc2FnZX1cXG5DYXVzZWQgQnk6ICR7ZXJyb3IuY2F1c2UubWVzc2FnZX1cXG5gO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBBbXBsaWZ5RXJyb3IgJiYgZXJyb3IucmVzb2x1dGlvbikge1xuICAgICAgICBtZXNzYWdlID0gYCR7bWVzc2FnZX1cXG5SZXNvbHV0aW9uOiAke2Vycm9yLnJlc29sdXRpb259XFxuYDtcbiAgICAgIH1cbiAgICB9IGVsc2UgbWVzc2FnZSA9IFN0cmluZyhlcnJvcik7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH07XG5cbiAgcHJpdmF0ZSBoYW5kbGVVbnN1cHBvcnRlZERlc3RydWN0aXZlQ2hhbmdlcyA9IGFzeW5jIChcbiAgICBvcHRpb25zOiBTYW5kYm94T3B0aW9uc1xuICApID0+IHtcbiAgICB0aGlzLnByaW50ZXIucHJpbnQoXG4gICAgICBmb3JtYXQuZXJyb3IoXG4gICAgICAgICdbU2FuZGJveF0gV2UgY2Fubm90IGRlcGxveSB5b3VyIG5ldyBjaGFuZ2VzLiBZb3UgY2FuIGVpdGhlciByZXZlcnQgdGhlbSBvciByZWNyZWF0ZSB5b3VyIHNhbmRib3ggd2l0aCB0aGUgbmV3IGNoYW5nZXMgKGRlbGV0aW5nIGFsbCB1c2VyIGRhdGEpJ1xuICAgICAgKVxuICAgICk7XG4gICAgLy8gb2ZmZXIgdG8gcmVjcmVhdGUgdGhlIHNhbmRib3ggd2l0aCBuZXcgcHJvcGVydGllc1xuICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IEFtcGxpZnlQcm9tcHRlci55ZXNPck5vKHtcbiAgICAgIG1lc3NhZ2U6XG4gICAgICAgICdXb3VsZCB5b3UgbGlrZSB0byByZWNyZWF0ZSB5b3VyIHNhbmRib3ggKGRlbGV0aW5nIGFsbCB1c2VyIGRhdGEpPycsXG4gICAgICBkZWZhdWx0VmFsdWU6IGZhbHNlLFxuICAgIH0pO1xuICAgIGlmIChhbnN3ZXIpIHtcbiAgICAgIGF3YWl0IHRoaXMuc3RvcCgpO1xuICAgICAgYXdhaXQgdGhpcy5yZXNldChvcHRpb25zKTtcbiAgICB9XG4gICAgLy8gZWxzZSBsZXQgdGhlIHNhbmRib3ggY29udGludWUgc28gY3VzdG9tZXJzIGNhbiByZXZlcnQgdGhlaXIgY2hhbmdlc1xuICB9O1xuXG4gIHByaXZhdGUgcHJpbnRTYW5kYm94TmFtZUluZm8gPSBhc3luYyAoc2FuZGJveElkZW50aWZpZXI/OiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCBzYW5kYm94QmFja2VuZElkID0gYXdhaXQgdGhpcy5iYWNrZW5kSWRTYW5kYm94UmVzb2x2ZXIoXG4gICAgICBzYW5kYm94SWRlbnRpZmllclxuICAgICk7XG4gICAgY29uc3Qgc3RhY2tOYW1lID1cbiAgICAgIEJhY2tlbmRJZGVudGlmaWVyQ29udmVyc2lvbnMudG9TdGFja05hbWUoc2FuZGJveEJhY2tlbmRJZCk7XG4gICAgdGhpcy5wcmludGVyLmxvZyhcbiAgICAgIGZvcm1hdC5pbmRlbnQoZm9ybWF0LmhpZ2hsaWdodChmb3JtYXQuYm9sZCgnXFxuQW1wbGlmeSBTYW5kYm94XFxuJykpKVxuICAgICk7XG4gICAgdGhpcy5wcmludGVyLmxvZyhcbiAgICAgIGZvcm1hdC5pbmRlbnQoYCR7Zm9ybWF0LmJvbGQoJ0lkZW50aWZpZXI6Jyl9IFxcdCR7c2FuZGJveEJhY2tlbmRJZC5uYW1lfWApXG4gICAgKTtcbiAgICB0aGlzLnByaW50ZXIubG9nKGZvcm1hdC5pbmRlbnQoYCR7Zm9ybWF0LmJvbGQoJ1N0YWNrOicpfSBcXHQke3N0YWNrTmFtZX1gKSk7XG4gICAgaWYgKCFzYW5kYm94SWRlbnRpZmllcikge1xuICAgICAgdGhpcy5wcmludGVyLmxvZyhcbiAgICAgICAgYCR7Zm9ybWF0LmluZGVudChcbiAgICAgICAgICBmb3JtYXQuZGltKCdcXG5UbyBzcGVjaWZ5IGEgZGlmZmVyZW50IHNhbmRib3ggaWRlbnRpZmllciwgdXNlICcpXG4gICAgICAgICl9JHtmb3JtYXQuYm9sZCgnLS1pZGVudGlmaWVyJyl9YFxuICAgICAgKTtcbiAgICB9XG4gIH07XG59XG4iXX0=