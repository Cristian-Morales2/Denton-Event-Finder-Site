"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertAuthorizationModesToTransformerAuthConfig = exports.getAdditionalAuthenticationTypes = exports.validateAuthorizationModes = void 0;
const lodash_1 = require("lodash");
const aws_iam_1 = require("aws-cdk-lib/aws-iam");
/**
 * Validates authorization modes.
 *
 * Rules:
 * 1. Validates that deprecated settings ('iamConfig.authenticatedUserRole', 'iamConfig.unauthenticatedUserRole',
 *    'iamConfig.identityPoolId', 'iamConfig.allowListedRoles' and 'adminRoles') are mutually exclusive with new settings that
 *    replaced them ('iamConfig.enableIamAuthorizationMode' and any of 'authorizationModes.identityPoolConfig')
 * 2. If deprecated identity pool settings are used ('iamConfig.authenticatedUserRole', 'iamConfig.unauthenticatedUserRole',
 *    and 'iamConfig.identityPoolId') validate that all are provided.
 */
const validateAuthorizationModes = (authorizationModes) => {
    const hasAnyDeprecatedIdentityPoolSetting = authorizationModes.iamConfig?.authenticatedUserRole ||
        authorizationModes.iamConfig?.unauthenticatedUserRole ||
        authorizationModes.iamConfig?.identityPoolId;
    const hasAllDeprecatedIdentityPoolSettings = authorizationModes.iamConfig?.authenticatedUserRole &&
        authorizationModes.iamConfig?.unauthenticatedUserRole &&
        authorizationModes.iamConfig?.identityPoolId;
    const hasDeprecatedIamSettings = authorizationModes.iamConfig?.authenticatedUserRole ||
        authorizationModes.iamConfig?.unauthenticatedUserRole ||
        authorizationModes.iamConfig?.identityPoolId ||
        authorizationModes.iamConfig?.allowListedRoles ||
        authorizationModes.adminRoles;
    const hasUnDeprecatedIamSettings = typeof authorizationModes.iamConfig?.enableIamAuthorizationMode !== 'undefined' || authorizationModes.identityPoolConfig;
    if (hasDeprecatedIamSettings && hasUnDeprecatedIamSettings) {
        throw new Error('Invalid authorization modes configuration provided. ' +
            "Deprecated IAM configuration cannot be used with identity pool configuration or when 'enableIamAuthorizationMode' is specified.");
    }
    if (hasAnyDeprecatedIdentityPoolSetting && !hasAllDeprecatedIdentityPoolSettings) {
        throw new Error("'authorizationModes.iamConfig.authenticatedUserRole', 'authorizationModes.iamConfig.unauthenticatedUserRole' and" +
            " 'authorizationModes.iamConfig.identityPoolId' must be provided.");
    }
};
exports.validateAuthorizationModes = validateAuthorizationModes;
/**
 * Converts a single auth mode config into the amplify-internal representation.
 * @param authMode the auth mode to convert into the Appsync CDK representation.
 */
const convertAuthModeToAuthProvider = (authMode) => {
    const authenticationType = authMode.type;
    switch (authMode.type) {
        case 'API_KEY':
            return {
                authenticationType,
                apiKeyConfig: {
                    description: authMode.description,
                    apiKeyExpirationDays: authMode.expires.toDays(),
                },
            };
        case 'AWS_IAM':
            return { authenticationType };
        case 'AMAZON_COGNITO_USER_POOLS':
            return {
                authenticationType,
                userPoolConfig: {
                    userPoolId: authMode.userPool.userPoolId,
                },
            };
        case 'OPENID_CONNECT':
            return {
                authenticationType,
                openIDConnectConfig: {
                    name: authMode.oidcProviderName,
                    issuerUrl: authMode.oidcIssuerUrl,
                    clientId: authMode.clientId,
                    iatTTL: authMode.tokenExpiryFromIssue.toSeconds(),
                    authTTL: authMode.tokenExpiryFromAuth.toSeconds(),
                },
            };
        case 'AWS_LAMBDA':
            return {
                authenticationType,
                lambdaAuthorizerConfig: {
                    lambdaArn: authMode.function.functionArn,
                    lambdaFunction: authMode.function.functionName,
                    ttlSeconds: authMode.ttl.toSeconds(),
                },
            };
        default:
            throw new Error(`Unexpected AuthMode type ${authenticationType} encountered.`);
    }
};
/**
 * Given an appsync auth configuration, convert into appsync auth provider setup.
 * @param authModes the config to transform
 * @returns the appsync config object.
 */
const convertAuthConfigToAppSyncAuth = (authModes) => {
    // Convert auth modes into an array of appsync configs, and include the type so we can use that for switching and partitioning later.
    const authConfig = [
        authModes.apiKeyConfig ? { type: 'API_KEY', ...authModes.apiKeyConfig } : null,
        authModes.lambdaConfig ? { type: 'AWS_LAMBDA', ...authModes.lambdaConfig } : null,
        authModes.oidcConfig ? { type: 'OPENID_CONNECT', ...authModes.oidcConfig } : null,
        authModes.userPoolConfig ? { type: 'AMAZON_COGNITO_USER_POOLS', ...authModes.userPoolConfig } : null,
        authModes.iamConfig || authModes.identityPoolConfig ? { type: 'AWS_IAM' } : null,
    ].filter((mode) => mode);
    const authProviders = authConfig.map(convertAuthModeToAuthProvider);
    // Validate inputs make sense, needs at least one mode, and a default mode is required if there are multiple modes.
    if (authProviders.length === 0) {
        throw new Error('At least one auth config is required, but none were found.');
    }
    if (authProviders.length > 1 && !authModes.defaultAuthorizationMode) {
        throw new Error('A defaultAuthorizationMode is required if multiple authorization modes are configured.');
    }
    // Enable appsync to invoke a provided lambda authorizer function
    authModes.lambdaConfig?.function.addPermission('appsync-auth-invoke', {
        principal: new aws_iam_1.ServicePrincipal('appsync.amazonaws.com'),
        action: 'lambda:InvokeFunction',
    });
    // In the case of a single mode, defaultAuthorizationMode is not required, just use the provided value.
    if (authProviders.length === 1) {
        return {
            defaultAuthentication: authProviders[0],
            additionalAuthenticationProviders: [],
        };
    }
    // For multi-auth, partition into the defaultMode and non-default modes.
    return {
        defaultAuthentication: authProviders.filter((provider) => provider.authenticationType === authModes.defaultAuthorizationMode)[0],
        additionalAuthenticationProviders: authProviders.filter((provider) => provider.authenticationType !== authModes.defaultAuthorizationMode),
    };
};
/**
 * Transforms additionalAuthenticationTypes for storage in CFN output
 */
const getAdditionalAuthenticationTypes = (cfnGraphqlApi) => {
    if (!(0, lodash_1.isArray)(cfnGraphqlApi.additionalAuthenticationProviders)) {
        return undefined;
    }
    return cfnGraphqlApi.additionalAuthenticationProviders
        .map((additionalAuthenticationProvider) => additionalAuthenticationProvider.authenticationType)
        .join(',');
};
exports.getAdditionalAuthenticationTypes = getAdditionalAuthenticationTypes;
/**
 * Convert the list of auth modes into the necessary flags and params (effectively a reducer on the rule list)
 * @param authModes the list of auth modes configured on the API.
 * @returns the AuthConfig which the AuthTransformer needs as input.
 */
const convertAuthorizationModesToTransformerAuthConfig = (authModes) => ({
    authConfig: convertAuthConfigToAppSyncAuth(authModes),
    authSynthParameters: getSynthParameters(authModes),
});
exports.convertAuthorizationModesToTransformerAuthConfig = convertAuthorizationModesToTransformerAuthConfig;
/**
 * Merge iamConfig allowListedRoles with deprecated adminRoles property, converting to strings.
 * @param authModes the auth modes provided to the construct.
 * @returns the list of admin roles as strings to pass into the transformer
 */
const getAllowListedRoles = (authModes) => [...(authModes?.iamConfig?.allowListedRoles ?? []), ...(authModes.adminRoles ?? [])].map((roleOrRoleName) => {
    if (typeof roleOrRoleName === 'string' || roleOrRoleName instanceof String) {
        return roleOrRoleName;
    }
    return roleOrRoleName.roleName;
});
/**
 * Transform the authorization config into the transformer synth parameters pertaining to auth.
 * @param authModes the auth modes provided to the construct.
 * @returns a record of params to be consumed by the transformer.
 */
const getSynthParameters = (authModes) => ({
    adminRoles: getAllowListedRoles(authModes),
    identityPoolId: authModes.identityPoolConfig?.identityPoolId ?? authModes.iamConfig?.identityPoolId,
    enableIamAccess: authModes.iamConfig?.enableIamAuthorizationMode,
    ...(authModes.userPoolConfig ? { userPoolId: authModes.userPoolConfig.userPool.userPoolId } : {}),
    ...(authModes?.identityPoolConfig
        ? {
            authenticatedUserRoleName: authModes.identityPoolConfig.authenticatedUserRole.roleName,
            unauthenticatedUserRoleName: authModes.identityPoolConfig.unauthenticatedUserRole.roleName,
        }
        : {}),
    ...(authModes?.iamConfig && authModes?.iamConfig.authenticatedUserRole && authModes?.iamConfig.unauthenticatedUserRole
        ? {
            authenticatedUserRoleName: authModes.iamConfig.authenticatedUserRole?.roleName,
            unauthenticatedUserRoleName: authModes.iamConfig.unauthenticatedUserRole?.roleName,
        }
        : {}),
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0aG9yaXphdGlvbi1tb2Rlcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9pbnRlcm5hbC9hdXRob3JpemF0aW9uLW1vZGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUVBLG1DQUFpQztBQUNqQyxpREFBOEQ7QUFnQjlEOzs7Ozs7Ozs7R0FTRztBQUNJLE1BQU0sMEJBQTBCLEdBQUcsQ0FBQyxrQkFBc0MsRUFBUSxFQUFFO0lBQ3pGLE1BQU0sbUNBQW1DLEdBQ3ZDLGtCQUFrQixDQUFDLFNBQVMsRUFBRSxxQkFBcUI7UUFDbkQsa0JBQWtCLENBQUMsU0FBUyxFQUFFLHVCQUF1QjtRQUNyRCxrQkFBa0IsQ0FBQyxTQUFTLEVBQUUsY0FBYyxDQUFDO0lBQy9DLE1BQU0sb0NBQW9DLEdBQ3hDLGtCQUFrQixDQUFDLFNBQVMsRUFBRSxxQkFBcUI7UUFDbkQsa0JBQWtCLENBQUMsU0FBUyxFQUFFLHVCQUF1QjtRQUNyRCxrQkFBa0IsQ0FBQyxTQUFTLEVBQUUsY0FBYyxDQUFDO0lBQy9DLE1BQU0sd0JBQXdCLEdBQzVCLGtCQUFrQixDQUFDLFNBQVMsRUFBRSxxQkFBcUI7UUFDbkQsa0JBQWtCLENBQUMsU0FBUyxFQUFFLHVCQUF1QjtRQUNyRCxrQkFBa0IsQ0FBQyxTQUFTLEVBQUUsY0FBYztRQUM1QyxrQkFBa0IsQ0FBQyxTQUFTLEVBQUUsZ0JBQWdCO1FBQzlDLGtCQUFrQixDQUFDLFVBQVUsQ0FBQztJQUNoQyxNQUFNLDBCQUEwQixHQUM5QixPQUFPLGtCQUFrQixDQUFDLFNBQVMsRUFBRSwwQkFBMEIsS0FBSyxXQUFXLElBQUksa0JBQWtCLENBQUMsa0JBQWtCLENBQUM7SUFFM0gsSUFBSSx3QkFBd0IsSUFBSSwwQkFBMEIsRUFBRTtRQUMxRCxNQUFNLElBQUksS0FBSyxDQUNiLHNEQUFzRDtZQUNwRCxpSUFBaUksQ0FDcEksQ0FBQztLQUNIO0lBRUQsSUFBSSxtQ0FBbUMsSUFBSSxDQUFDLG9DQUFvQyxFQUFF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QUFDLGtCQUFrQixFQUFFLGNBQWMsSUFBSSxTQUFTLENBQUMsU0FBUyxFQUFFLGNBQWM7SUFDbkcsZUFBZSxFQUFFLFNBQVMsQ0FBQyxTQUFTLEVBQUUsMEJBQTBCO0lBQ2hFLEdBQUcsQ0FBQyxTQUFTLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxFQUFFLFVBQVUsRUFBRSxTQUFTLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO0lBQ2pHLEdBQUcsQ0FBQyxTQUFTLEVBQUUsa0JBQWtCO1FBQy9CLENBQUMsQ0FBQztZQUNFLHlCQUF5QixFQUFFLFNBQVMsQ0FBQyxrQkFBa0IsQ0FBQyxxQkFBcUIsQ0FBQyxRQUFRO1lBQ3RGLDJCQUEyQixFQUFFLFNBQVMsQ0FBQyxrQkFBa0IsQ0FBQyx1QkFBdUIsQ0FBQyxRQUFRO1NBQzNGO1FBQ0gsQ0FBQyxDQUFDLEVBQUUsQ0FBQztJQUNQLEdBQUcsQ0FBQyxTQUFTLEVBQUUsU0FBUyxJQUFJLFNBQVMsRUFBRSxTQUFTLENBQUMscUJBQXFCLElBQUksU0FBUyxFQUFFLFNBQVMsQ0FBQyx1QkFBdUI7UUFDcEgsQ0FBQyxDQUFDO1lBQ0UseUJBQXlCLEVBQUUsU0FBUyxDQUFDLFNBQVMsQ0FBQyxxQkFBcUIsRUFBRSxRQUFRO1lBQzlFLDJCQUEyQixFQUFFLFNBQVMsQ0FBQyxTQUFTLENBQUMsdUJBQXVCLEVBQUUsUUFBUTtTQUNuRjtRQUNILENBQUMsQ0FBQyxFQUFFLENBQUM7Q0FDUixDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBcHBTeW5jQXV0aENvbmZpZ3VyYXRpb24sIEFwcFN5bmNBdXRoQ29uZmlndXJhdGlvbkVudHJ5LCBTeW50aFBhcmFtZXRlcnMgfSBmcm9tICdAYXdzLWFtcGxpZnkvZ3JhcGhxbC10cmFuc2Zvcm1lci1pbnRlcmZhY2VzJztcbmltcG9ydCB7IENmbkdyYXBoUUxBcGkgfSBmcm9tICdhd3MtY2RrLWxpYi9hd3MtYXBwc3luYyc7XG5pbXBvcnQgeyBpc0FycmF5IH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IElSb2xlLCBTZXJ2aWNlUHJpbmNpcGFsIH0gZnJvbSAnYXdzLWNkay1saWIvYXdzLWlhbSc7XG5pbXBvcnQge1xuICBBdXRob3JpemF0aW9uTW9kZXMsXG4gIEFwaUtleUF1dGhvcml6YXRpb25Db25maWcsXG4gIExhbWJkYUF1dGhvcml6YXRpb25Db25maWcsXG4gIE9JRENBdXRob3JpemF0aW9uQ29uZmlnLFxuICBVc2VyUG9vbEF1dGhvcml6YXRpb25Db25maWcsXG59IGZyb20gJy4uL3R5cGVzJztcblxudHlwZSBBdXRob3JpemF0aW9uQ29uZmlnTW9kZSA9XG4gIHwgeyB0eXBlOiAnQVdTX0lBTScgfVxuICB8IChVc2VyUG9vbEF1dGhvcml6YXRpb25Db25maWcgJiB7IHR5cGU6ICdBTUFaT05fQ09HTklUT19VU0VSX1BPT0xTJyB9KVxuICB8IChPSURDQXV0aG9yaXphdGlvbkNvbmZpZyAmIHsgdHlwZTogJ09QRU5JRF9DT05ORUNUJyB9KVxuICB8IChBcGlLZXlBdXRob3JpemF0aW9uQ29uZmlnICYgeyB0eXBlOiAnQVBJX0tFWScgfSlcbiAgfCAoTGFtYmRhQXV0aG9yaXphdGlvbkNvbmZpZyAmIHsgdHlwZTogJ0FXU19MQU1CREEnIH0pO1xuXG4vKipcbiAqIFZhbGlkYXRlcyBhdXRob3JpemF0aW9uIG1vZGVzLlxuICpcbiAqIFJ1bGVzOlxuICogMS4gVmFsaWRhdGVzIHRoYXQgZGVwcmVjYXRlZCBzZXR0aW5ncyAoJ2lhbUNvbmZpZy5hdXRoZW50aWNhdGVkVXNlclJvbGUnLCAnaWFtQ29uZmlnLnVuYXV0aGVudGljYXRlZFVzZXJSb2xlJyxcbiAqICAgICdpYW1Db25maWcuaWRlbnRpdHlQb29sSWQnLCAnaWFtQ29uZmlnLmFsbG93TGlzdGVkUm9sZXMnIGFuZCAnYWRtaW5Sb2xlcycpIGFyZSBtdXR1YWxseSBleGNsdXNpdmUgd2l0aCBuZXcgc2V0dGluZ3MgdGhhdFxuICogICAgcmVwbGFjZWQgdGhlbSAoJ2lhbUNvbmZpZy5lbmFibGVJYW1BdXRob3JpemF0aW9uTW9kZScgYW5kIGFueSBvZiAnYXV0aG9yaXphdGlvbk1vZGVzLmlkZW50aXR5UG9vbENvbmZpZycpXG4gKiAyLiBJZiBkZXByZWNhdGVkIGlkZW50aXR5IHBvb2wgc2V0dGluZ3MgYXJlIHVzZWQgKCdpYW1Db25maWcuYXV0aGVudGljYXRlZFVzZXJSb2xlJywgJ2lhbUNvbmZpZy51bmF1dGhlbnRpY2F0ZWRVc2VyUm9sZScsXG4gKiAgICBhbmQgJ2lhbUNvbmZpZy5pZGVudGl0eVBvb2xJZCcpIHZhbGlkYXRlIHRoYXQgYWxsIGFyZSBwcm92aWRlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHZhbGlkYXRlQXV0aG9yaXphdGlvbk1vZGVzID0gKGF1dGhvcml6YXRpb25Nb2RlczogQXV0aG9yaXphdGlvbk1vZGVzKTogdm9pZCA9PiB7XG4gIGNvbnN0IGhhc0FueURlcHJlY2F0ZWRJZGVudGl0eVBvb2xTZXR0aW5nID1cbiAgICBhdXRob3JpemF0aW9uTW9kZXMuaWFtQ29uZmlnPy5hdXRoZW50aWNhdGVkVXNlclJvbGUgfHxcbiAgICBhdXRob3JpemF0aW9uTW9kZXMuaWFtQ29uZmlnPy51bmF1dGhlbnRpY2F0ZWRVc2VyUm9sZSB8fFxuICAgIGF1dGhvcml6YXRpb25Nb2Rlcy5pYW1Db25maWc/LmlkZW50aXR5UG9vbElkO1xuICBjb25zdCBoYXNBbGxEZXByZWNhdGVkSWRlbnRpdHlQb29sU2V0dGluZ3MgPVxuICAgIGF1dGhvcml6YXRpb25Nb2Rlcy5pYW1Db25maWc/LmF1dGhlbnRpY2F0ZWRVc2VyUm9sZSAmJlxuICAgIGF1dGhvcml6YXRpb25Nb2Rlcy5pYW1Db25maWc/LnVuYXV0aGVudGljYXRlZFVzZXJSb2xlICYmXG4gICAgYXV0aG9yaXphdGlvbk1vZGVzLmlhbUNvbmZpZz8uaWRlbnRpdHlQb29sSWQ7XG4gIGNvbnN0IGhhc0RlcHJlY2F0ZWRJYW1TZXR0aW5ncyA9XG4gICAgYXV0aG9yaXphdGlvbk1vZGVzLmlhbUNvbmZpZz8uYXV0aGVudGljYXRlZFVzZXJSb2xlIHx8XG4gICAgYXV0aG9yaXphdGlvbk1vZGVzLmlhbUNvbmZpZz8udW5hdXRoZW50aWNhdGVkVXNlclJvbGUgfHxcbiAgICBhdXRob3JpemF0aW9uTW9kZXMuaWFtQ29uZmlnPy5pZGVudGl0eVBvb2xJZCB8fFxuICAgIGF1dGhvcml6YXRpb25Nb2Rlcy5pYW1Db25maWc/LmFsbG93TGlzdGVkUm9sZXMgfHxcbiAgICBhdXRob3JpemF0aW9uTW9kZXMuYWRtaW5Sb2xlcztcbiAgY29uc3QgaGFzVW5EZXByZWNhdGVkSWFtU2V0dGluZ3MgPVxuICAgIHR5cGVvZiBhdXRob3JpemF0aW9uTW9kZXMuaWFtQ29uZmlnPy5lbmFibGVJYW1BdXRob3JpemF0aW9uTW9kZSAhPT0gJ3VuZGVmaW5lZCcgfHwgYXV0aG9yaXphdGlvbk1vZGVzLmlkZW50aXR5UG9vbENvbmZpZztcblxuICBpZiAoaGFzRGVwcmVjYXRlZElhbVNldHRpbmdzICYmIGhhc1VuRGVwcmVjYXRlZElhbVNldHRpbmdzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0ludmFsaWQgYXV0aG9yaXphdGlvbiBtb2RlcyBjb25maWd1cmF0aW9uIHByb3ZpZGVkLiAnICtcbiAgICAgICAgXCJEZXByZWNhdGVkIElBTSBjb25maWd1cmF0aW9uIGNhbm5vdCBiZSB1c2VkIHdpdGggaWRlbnRpdHkgcG9vbCBjb25maWd1cmF0aW9uIG9yIHdoZW4gJ2VuYWJsZUlhbUF1dGhvcml6YXRpb25Nb2RlJyBpcyBzcGVjaWZpZWQuXCIsXG4gICAgKTtcbiAgfVxuXG4gIGlmIChoYXNBbnlEZXByZWNhdGVkSWRlbnRpdHlQb29sU2V0dGluZyAmJiAhaGFzQWxsRGVwcmVjYXRlZElkZW50aXR5UG9vbFNldHRpbmdzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCInYXV0aG9yaXphdGlvbk1vZGVzLmlhbUNvbmZpZy5hdXRoZW50aWNhdGVkVXNlclJvbGUnLCAnYXV0aG9yaXphdGlvbk1vZGVzLmlhbUNvbmZpZy51bmF1dGhlbnRpY2F0ZWRVc2VyUm9sZScgYW5kXCIgK1xuICAgICAgICBcIiAnYXV0aG9yaXphdGlvbk1vZGVzLmlhbUNvbmZpZy5pZGVudGl0eVBvb2xJZCcgbXVzdCBiZSBwcm92aWRlZC5cIixcbiAgICApO1xuICB9XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgc2luZ2xlIGF1dGggbW9kZSBjb25maWcgaW50byB0aGUgYW1wbGlmeS1pbnRlcm5hbCByZXByZXNlbnRhdGlvbi5cbiAqIEBwYXJhbSBhdXRoTW9kZSB0aGUgYXV0aCBtb2RlIHRvIGNvbnZlcnQgaW50byB0aGUgQXBwc3luYyBDREsgcmVwcmVzZW50YXRpb24uXG4gKi9cbmNvbnN0IGNvbnZlcnRBdXRoTW9kZVRvQXV0aFByb3ZpZGVyID0gKGF1dGhNb2RlOiBBdXRob3JpemF0aW9uQ29uZmlnTW9kZSk6IEFwcFN5bmNBdXRoQ29uZmlndXJhdGlvbkVudHJ5ID0+IHtcbiAgY29uc3QgYXV0aGVudGljYXRpb25UeXBlID0gYXV0aE1vZGUudHlwZTtcbiAgc3dpdGNoIChhdXRoTW9kZS50eXBlKSB7XG4gICAgY2FzZSAnQVBJX0tFWSc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRoZW50aWNhdGlvblR5cGUsXG4gICAgICAgIGFwaUtleUNvbmZpZzoge1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiBhdXRoTW9kZS5kZXNjcmlwdGlvbixcbiAgICAgICAgICBhcGlLZXlFeHBpcmF0aW9uRGF5czogYXV0aE1vZGUuZXhwaXJlcy50b0RheXMoKSxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgY2FzZSAnQVdTX0lBTSc6XG4gICAgICByZXR1cm4geyBhdXRoZW50aWNhdGlvblR5cGUgfTtcbiAgICBjYXNlICdBTUFaT05fQ09HTklUT19VU0VSX1BPT0xTJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhlbnRpY2F0aW9uVHlwZSxcbiAgICAgICAgdXNlclBvb2xDb25maWc6IHtcbiAgICAgICAgICB1c2VyUG9vbElkOiBhdXRoTW9kZS51c2VyUG9vbC51c2VyUG9vbElkLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICBjYXNlICdPUEVOSURfQ09OTkVDVCc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRoZW50aWNhdGlvblR5cGUsXG4gICAgICAgIG9wZW5JRENvbm5lY3RDb25maWc6IHtcbiAgICAgICAgICBuYW1lOiBhdXRoTW9kZS5vaWRjUHJvdmlkZXJOYW1lLFxuICAgICAgICAgIGlzc3VlclVybDogYXV0aE1vZGUub2lkY0lzc3VlclVybCxcbiAgICAgICAgICBjbGllbnRJZDogYXV0aE1vZGUuY2xpZW50SWQsXG4gICAgICAgICAgaWF0VFRMOiBhdXRoTW9kZS50b2tlbkV4cGlyeUZyb21Jc3N1ZS50b1NlY29uZHMoKSxcbiAgICAgICAgICBhdXRoVFRMOiBhdXRoTW9kZS50b2tlbkV4cGlyeUZyb21BdXRoLnRvU2Vjb25kcygpLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICBjYXNlICdBV1NfTEFNQkRBJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhlbnRpY2F0aW9uVHlwZSxcbiAgICAgICAgbGFtYmRhQXV0aG9yaXplckNvbmZpZzoge1xuICAgICAgICAgIGxhbWJkYUFybjogYXV0aE1vZGUuZnVuY3Rpb24uZnVuY3Rpb25Bcm4sXG4gICAgICAgICAgbGFtYmRhRnVuY3Rpb246IGF1dGhNb2RlLmZ1bmN0aW9uLmZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICB0dGxTZWNvbmRzOiBhdXRoTW9kZS50dGwudG9TZWNvbmRzKCksXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgQXV0aE1vZGUgdHlwZSAke2F1dGhlbnRpY2F0aW9uVHlwZX0gZW5jb3VudGVyZWQuYCk7XG4gIH1cbn07XG5cbi8qKlxuICogR2l2ZW4gYW4gYXBwc3luYyBhdXRoIGNvbmZpZ3VyYXRpb24sIGNvbnZlcnQgaW50byBhcHBzeW5jIGF1dGggcHJvdmlkZXIgc2V0dXAuXG4gKiBAcGFyYW0gYXV0aE1vZGVzIHRoZSBjb25maWcgdG8gdHJhbnNmb3JtXG4gKiBAcmV0dXJucyB0aGUgYXBwc3luYyBjb25maWcgb2JqZWN0LlxuICovXG5jb25zdCBjb252ZXJ0QXV0aENvbmZpZ1RvQXBwU3luY0F1dGggPSAoYXV0aE1vZGVzOiBBdXRob3JpemF0aW9uTW9kZXMpOiBBcHBTeW5jQXV0aENvbmZpZ3VyYXRpb24gPT4ge1xuICAvLyBDb252ZXJ0IGF1dGggbW9kZXMgaW50byBhbiBhcnJheSBvZiBhcHBzeW5jIGNvbmZpZ3MsIGFuZCBpbmNsdWRlIHRoZSB0eXBlIHNvIHdlIGNhbiB1c2UgdGhhdCBmb3Igc3dpdGNoaW5nIGFuZCBwYXJ0aXRpb25pbmcgbGF0ZXIuXG4gIGNvbnN0IGF1dGhDb25maWcgPSBbXG4gICAgYXV0aE1vZGVzLmFwaUtleUNvbmZpZyA/IHsgdHlwZTogJ0FQSV9LRVknLCAuLi5hdXRoTW9kZXMuYXBpS2V5Q29uZmlnIH0gOiBudWxsLFxuICAgIGF1dGhNb2Rlcy5sYW1iZGFDb25maWcgPyB7IHR5cGU6ICdBV1NfTEFNQkRBJywgLi4uYXV0aE1vZGVzLmxhbWJkYUNvbmZpZyB9IDogbnVsbCxcbiAgICBhdXRoTW9kZXMub2lkY0NvbmZpZyA/IHsgdHlwZTogJ09QRU5JRF9DT05ORUNUJywgLi4uYXV0aE1vZGVzLm9pZGNDb25maWcgfSA6IG51bGwsXG4gICAgYXV0aE1vZGVzLnVzZXJQb29sQ29uZmlnID8geyB0eXBlOiAnQU1BWk9OX0NPR05JVE9fVVNFUl9QT09MUycsIC4uLmF1dGhNb2Rlcy51c2VyUG9vbENvbmZpZyB9IDogbnVsbCxcbiAgICBhdXRoTW9kZXMuaWFtQ29uZmlnIHx8IGF1dGhNb2Rlcy5pZGVudGl0eVBvb2xDb25maWcgPyB7IHR5cGU6ICdBV1NfSUFNJyB9IDogbnVsbCxcbiAgXS5maWx0ZXIoKG1vZGUpID0+IG1vZGUpIGFzIEF1dGhvcml6YXRpb25Db25maWdNb2RlW107XG4gIGNvbnN0IGF1dGhQcm92aWRlcnMgPSBhdXRoQ29uZmlnLm1hcChjb252ZXJ0QXV0aE1vZGVUb0F1dGhQcm92aWRlcik7XG5cbiAgLy8gVmFsaWRhdGUgaW5wdXRzIG1ha2Ugc2Vuc2UsIG5lZWRzIGF0IGxlYXN0IG9uZSBtb2RlLCBhbmQgYSBkZWZhdWx0IG1vZGUgaXMgcmVxdWlyZWQgaWYgdGhlcmUgYXJlIG11bHRpcGxlIG1vZGVzLlxuICBpZiAoYXV0aFByb3ZpZGVycy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0IGxlYXN0IG9uZSBhdXRoIGNvbmZpZyBpcyByZXF1aXJlZCwgYnV0IG5vbmUgd2VyZSBmb3VuZC4nKTtcbiAgfVxuICBpZiAoYXV0aFByb3ZpZGVycy5sZW5ndGggPiAxICYmICFhdXRoTW9kZXMuZGVmYXVsdEF1dGhvcml6YXRpb25Nb2RlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBIGRlZmF1bHRBdXRob3JpemF0aW9uTW9kZSBpcyByZXF1aXJlZCBpZiBtdWx0aXBsZSBhdXRob3JpemF0aW9uIG1vZGVzIGFyZSBjb25maWd1cmVkLicpO1xuICB9XG5cbiAgLy8gRW5hYmxlIGFwcHN5bmMgdG8gaW52b2tlIGEgcHJvdmlkZWQgbGFtYmRhIGF1dGhvcml6ZXIgZnVuY3Rpb25cbiAgYXV0aE1vZGVzLmxhbWJkYUNvbmZpZz8uZnVuY3Rpb24uYWRkUGVybWlzc2lvbignYXBwc3luYy1hdXRoLWludm9rZScsIHtcbiAgICBwcmluY2lwYWw6IG5ldyBTZXJ2aWNlUHJpbmNpcGFsKCdhcHBzeW5jLmFtYXpvbmF3cy5jb20nKSxcbiAgICBhY3Rpb246ICdsYW1iZGE6SW52b2tlRnVuY3Rpb24nLFxuICB9KTtcblxuICAvLyBJbiB0aGUgY2FzZSBvZiBhIHNpbmdsZSBtb2RlLCBkZWZhdWx0QXV0aG9yaXphdGlvbk1vZGUgaXMgbm90IHJlcXVpcmVkLCBqdXN0IHVzZSB0aGUgcHJvdmlkZWQgdmFsdWUuXG4gIGlmIChhdXRoUHJvdmlkZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB7XG4gICAgICBkZWZhdWx0QXV0aGVudGljYXRpb246IGF1dGhQcm92aWRlcnNbMF0sXG4gICAgICBhZGRpdGlvbmFsQXV0aGVudGljYXRpb25Qcm92aWRlcnM6IFtdLFxuICAgIH07XG4gIH1cblxuICAvLyBGb3IgbXVsdGktYXV0aCwgcGFydGl0aW9uIGludG8gdGhlIGRlZmF1bHRNb2RlIGFuZCBub24tZGVmYXVsdCBtb2Rlcy5cbiAgcmV0dXJuIHtcbiAgICBkZWZhdWx0QXV0aGVudGljYXRpb246IGF1dGhQcm92aWRlcnMuZmlsdGVyKChwcm92aWRlcikgPT4gcHJvdmlkZXIuYXV0aGVudGljYXRpb25UeXBlID09PSBhdXRoTW9kZXMuZGVmYXVsdEF1dGhvcml6YXRpb25Nb2RlKVswXSxcbiAgICBhZGRpdGlvbmFsQXV0aGVudGljYXRpb25Qcm92aWRlcnM6IGF1dGhQcm92aWRlcnMuZmlsdGVyKFxuICAgICAgKHByb3ZpZGVyKSA9PiBwcm92aWRlci5hdXRoZW50aWNhdGlvblR5cGUgIT09IGF1dGhNb2Rlcy5kZWZhdWx0QXV0aG9yaXphdGlvbk1vZGUsXG4gICAgKSxcbiAgfTtcbn07XG5cbnR5cGUgQXV0aFN5bnRoUGFyYW1ldGVycyA9IFBpY2s8XG4gIFN5bnRoUGFyYW1ldGVycyxcbiAgJ3VzZXJQb29sSWQnIHwgJ2F1dGhlbnRpY2F0ZWRVc2VyUm9sZU5hbWUnIHwgJ3VuYXV0aGVudGljYXRlZFVzZXJSb2xlTmFtZScgfCAnaWRlbnRpdHlQb29sSWQnIHwgJ2FkbWluUm9sZXMnIHwgJ2VuYWJsZUlhbUFjY2Vzcydcbj47XG5cbmludGVyZmFjZSBBdXRoQ29uZmlnIHtcbiAgLyoqXG4gICAqIHVzZWQgbWFpbmx5IGluIHRoZSBiZWZvcmUgc3RlcCB0byBwYXNzIHRoZSBhdXRoQ29uZmlnIGZyb20gdGhlIHRyYW5zZm9ybWVyIGNvcmUgZG93biB0byB0aGUgZGlyZWN0aXZlXG4gICAqL1xuICBhdXRoQ29uZmlnPzogQXBwU3luY0F1dGhDb25maWd1cmF0aW9uO1xuXG4gIC8qKlxuICAgKiBQYXJhbXMgdG8gaW5jbHVkZSB0aGUgdHJhbnNmb3JtZXIuXG4gICAqL1xuICBhdXRoU3ludGhQYXJhbWV0ZXJzOiBBdXRoU3ludGhQYXJhbWV0ZXJzO1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybXMgYWRkaXRpb25hbEF1dGhlbnRpY2F0aW9uVHlwZXMgZm9yIHN0b3JhZ2UgaW4gQ0ZOIG91dHB1dFxuICovXG5leHBvcnQgY29uc3QgZ2V0QWRkaXRpb25hbEF1dGhlbnRpY2F0aW9uVHlwZXMgPSAoY2ZuR3JhcGhxbEFwaTogQ2ZuR3JhcGhRTEFwaSk6IHN0cmluZyB8IHVuZGVmaW5lZCA9PiB7XG4gIGlmICghaXNBcnJheShjZm5HcmFwaHFsQXBpLmFkZGl0aW9uYWxBdXRoZW50aWNhdGlvblByb3ZpZGVycykpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIChjZm5HcmFwaHFsQXBpLmFkZGl0aW9uYWxBdXRoZW50aWNhdGlvblByb3ZpZGVycyBhcyBDZm5HcmFwaFFMQXBpLkFkZGl0aW9uYWxBdXRoZW50aWNhdGlvblByb3ZpZGVyUHJvcGVydHlbXSlcbiAgICAubWFwKFxuICAgICAgKGFkZGl0aW9uYWxBdXRoZW50aWNhdGlvblByb3ZpZGVyOiBDZm5HcmFwaFFMQXBpLkFkZGl0aW9uYWxBdXRoZW50aWNhdGlvblByb3ZpZGVyUHJvcGVydHkpID0+XG4gICAgICAgIGFkZGl0aW9uYWxBdXRoZW50aWNhdGlvblByb3ZpZGVyLmF1dGhlbnRpY2F0aW9uVHlwZSxcbiAgICApXG4gICAgLmpvaW4oJywnKTtcbn07XG5cbi8qKlxuICogQ29udmVydCB0aGUgbGlzdCBvZiBhdXRoIG1vZGVzIGludG8gdGhlIG5lY2Vzc2FyeSBmbGFncyBhbmQgcGFyYW1zIChlZmZlY3RpdmVseSBhIHJlZHVjZXIgb24gdGhlIHJ1bGUgbGlzdClcbiAqIEBwYXJhbSBhdXRoTW9kZXMgdGhlIGxpc3Qgb2YgYXV0aCBtb2RlcyBjb25maWd1cmVkIG9uIHRoZSBBUEkuXG4gKiBAcmV0dXJucyB0aGUgQXV0aENvbmZpZyB3aGljaCB0aGUgQXV0aFRyYW5zZm9ybWVyIG5lZWRzIGFzIGlucHV0LlxuICovXG5leHBvcnQgY29uc3QgY29udmVydEF1dGhvcml6YXRpb25Nb2Rlc1RvVHJhbnNmb3JtZXJBdXRoQ29uZmlnID0gKGF1dGhNb2RlczogQXV0aG9yaXphdGlvbk1vZGVzKTogQXV0aENvbmZpZyA9PiAoe1xuICBhdXRoQ29uZmlnOiBjb252ZXJ0QXV0aENvbmZpZ1RvQXBwU3luY0F1dGgoYXV0aE1vZGVzKSxcbiAgYXV0aFN5bnRoUGFyYW1ldGVyczogZ2V0U3ludGhQYXJhbWV0ZXJzKGF1dGhNb2RlcyksXG59KTtcblxuLyoqXG4gKiBNZXJnZSBpYW1Db25maWcgYWxsb3dMaXN0ZWRSb2xlcyB3aXRoIGRlcHJlY2F0ZWQgYWRtaW5Sb2xlcyBwcm9wZXJ0eSwgY29udmVydGluZyB0byBzdHJpbmdzLlxuICogQHBhcmFtIGF1dGhNb2RlcyB0aGUgYXV0aCBtb2RlcyBwcm92aWRlZCB0byB0aGUgY29uc3RydWN0LlxuICogQHJldHVybnMgdGhlIGxpc3Qgb2YgYWRtaW4gcm9sZXMgYXMgc3RyaW5ncyB0byBwYXNzIGludG8gdGhlIHRyYW5zZm9ybWVyXG4gKi9cbmNvbnN0IGdldEFsbG93TGlzdGVkUm9sZXMgPSAoYXV0aE1vZGVzOiBBdXRob3JpemF0aW9uTW9kZXMpOiBzdHJpbmdbXSA9PlxuICBbLi4uKGF1dGhNb2Rlcz8uaWFtQ29uZmlnPy5hbGxvd0xpc3RlZFJvbGVzID8/IFtdKSwgLi4uKGF1dGhNb2Rlcy5hZG1pblJvbGVzID8/IFtdKV0ubWFwKChyb2xlT3JSb2xlTmFtZTogSVJvbGUgfCBzdHJpbmcpID0+IHtcbiAgICBpZiAodHlwZW9mIHJvbGVPclJvbGVOYW1lID09PSAnc3RyaW5nJyB8fCByb2xlT3JSb2xlTmFtZSBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgcmV0dXJuIHJvbGVPclJvbGVOYW1lIGFzIHN0cmluZztcbiAgICB9XG4gICAgcmV0dXJuIHJvbGVPclJvbGVOYW1lLnJvbGVOYW1lO1xuICB9KTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIGF1dGhvcml6YXRpb24gY29uZmlnIGludG8gdGhlIHRyYW5zZm9ybWVyIHN5bnRoIHBhcmFtZXRlcnMgcGVydGFpbmluZyB0byBhdXRoLlxuICogQHBhcmFtIGF1dGhNb2RlcyB0aGUgYXV0aCBtb2RlcyBwcm92aWRlZCB0byB0aGUgY29uc3RydWN0LlxuICogQHJldHVybnMgYSByZWNvcmQgb2YgcGFyYW1zIHRvIGJlIGNvbnN1bWVkIGJ5IHRoZSB0cmFuc2Zvcm1lci5cbiAqL1xuY29uc3QgZ2V0U3ludGhQYXJhbWV0ZXJzID0gKGF1dGhNb2RlczogQXV0aG9yaXphdGlvbk1vZGVzKTogQXV0aFN5bnRoUGFyYW1ldGVycyA9PiAoe1xuICBhZG1pblJvbGVzOiBnZXRBbGxvd0xpc3RlZFJvbGVzKGF1dGhNb2RlcyksXG4gIGlkZW50aXR5UG9vbElkOiBhdXRoTW9kZXMuaWRlbnRpdHlQb29sQ29uZmlnPy5pZGVudGl0eVBvb2xJZCA/PyBhdXRoTW9kZXMuaWFtQ29uZmlnPy5pZGVudGl0eVBvb2xJZCxcbiAgZW5hYmxlSWFtQWNjZXNzOiBhdXRoTW9kZXMuaWFtQ29uZmlnPy5lbmFibGVJYW1BdXRob3JpemF0aW9uTW9kZSxcbiAgLi4uKGF1dGhNb2Rlcy51c2VyUG9vbENvbmZpZyA/IHsgdXNlclBvb2xJZDogYXV0aE1vZGVzLnVzZXJQb29sQ29uZmlnLnVzZXJQb29sLnVzZXJQb29sSWQgfSA6IHt9KSxcbiAgLi4uKGF1dGhNb2Rlcz8uaWRlbnRpdHlQb29sQ29uZmlnXG4gICAgPyB7XG4gICAgICAgIGF1dGhlbnRpY2F0ZWRVc2VyUm9sZU5hbWU6IGF1dGhNb2Rlcy5pZGVudGl0eVBvb2xDb25maWcuYXV0aGVudGljYXRlZFVzZXJSb2xlLnJvbGVOYW1lLFxuICAgICAgICB1bmF1dGhlbnRpY2F0ZWRVc2VyUm9sZU5hbWU6IGF1dGhNb2Rlcy5pZGVudGl0eVBvb2xDb25maWcudW5hdXRoZW50aWNhdGVkVXNlclJvbGUucm9sZU5hbWUsXG4gICAgICB9XG4gICAgOiB7fSksXG4gIC4uLihhdXRoTW9kZXM/LmlhbUNvbmZpZyAmJiBhdXRoTW9kZXM/LmlhbUNvbmZpZy5hdXRoZW50aWNhdGVkVXNlclJvbGUgJiYgYXV0aE1vZGVzPy5pYW1Db25maWcudW5hdXRoZW50aWNhdGVkVXNlclJvbGVcbiAgICA/IHtcbiAgICAgICAgYXV0aGVudGljYXRlZFVzZXJSb2xlTmFtZTogYXV0aE1vZGVzLmlhbUNvbmZpZy5hdXRoZW50aWNhdGVkVXNlclJvbGU/LnJvbGVOYW1lLFxuICAgICAgICB1bmF1dGhlbnRpY2F0ZWRVc2VyUm9sZU5hbWU6IGF1dGhNb2Rlcy5pYW1Db25maWcudW5hdXRoZW50aWNhdGVkVXNlclJvbGU/LnJvbGVOYW1lLFxuICAgICAgfVxuICAgIDoge30pLFxufSk7XG4iXX0=