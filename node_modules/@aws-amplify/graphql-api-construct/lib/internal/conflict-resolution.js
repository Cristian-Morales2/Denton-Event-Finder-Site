"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertToResolverConfig = void 0;
/**
 * Convert project conflict resolution config to transformer ResolverConfig object.
 * @param param0 input shape
 * @param param0.project the project level config
 * @param param0.models the model-specific override config
 * @returns the transformer representation
 */
const convertToResolverConfig = ({ project, models }) => ({
    project: project && convertToSyncConfig(project),
    models: models && Object.fromEntries(Object.entries(models).map(([modelName, strategy]) => [modelName, convertToSyncConfig(strategy)])),
});
exports.convertToResolverConfig = convertToResolverConfig;
/**
 * Convert from external to internal representation of conflict resolution config.
 * @param strategy the strategy to convert
 * @returns the converted strategy
 */
const convertToSyncConfig = (strategy) => {
    switch (strategy.handlerType) {
        case 'OPTIMISTIC_CONCURRENCY':
            return {
                ConflictHandler: "OPTIMISTIC_CONCURRENCY" /* ConflictHandlerType.OPTIMISTIC */,
                ConflictDetection: strategy.detectionType,
            };
        case 'AUTOMERGE':
            return {
                ConflictHandler: "AUTOMERGE" /* ConflictHandlerType.AUTOMERGE */,
                ConflictDetection: strategy.detectionType,
            };
        case 'LAMBDA':
            return {
                ConflictHandler: "LAMBDA" /* ConflictHandlerType.LAMBDA */,
                ConflictDetection: strategy.detectionType,
                LambdaConflictHandler: {
                    name: strategy.conflictHandler.functionName,
                    lambdaArn: strategy.conflictHandler.functionArn,
                },
            };
        default:
            throw new Error(`Encountered unexpected handlerType: ${strategy.handlerType}`);
    }
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29uZmxpY3QtcmVzb2x1dGlvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9pbnRlcm5hbC9jb25mbGljdC1yZXNvbHV0aW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUdBOzs7Ozs7R0FNRztBQUNJLE1BQU0sdUJBQXVCLEdBQUcsQ0FBQyxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQXNCLEVBQWtCLEVBQUUsQ0FBQyxDQUFDO0lBQ25HLE9BQU8sRUFBRSxPQUFPLElBQUksbUJBQW1CLENBQUMsT0FBTyxDQUFDO0lBQ2hELE1BQU0sRUFBRSxNQUFNLElBQUksTUFBTSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsU0FBUyxFQUFFLFFBQVEsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLFNBQVMsRUFBRSxtQkFBbUIsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7Q0FDeEksQ0FBQyxDQUFDO0FBSFUsUUFBQSx1QkFBdUIsMkJBR2pDO0FBRUg7Ozs7R0FJRztBQUNILE1BQU0sbUJBQW1CLEdBQUcsQ0FBQyxRQUFvQyxFQUFjLEVBQUU7SUFDL0UsUUFBUSxRQUFRLENBQUMsV0FBVyxFQUFFO1FBQzVCLEtBQUssd0JBQXdCO1lBQzNCLE9BQU87Z0JBQ0wsZUFBZSwrREFBZ0M7Z0JBQy9DLGlCQUFpQixFQUFFLFFBQVEsQ0FBQyxhQUFhO2FBQzFDLENBQUM7UUFDSixLQUFLLFdBQVc7WUFDZCxPQUFPO2dCQUNMLGVBQWUsaURBQStCO2dCQUM5QyxpQkFBaUIsRUFBRSxRQUFRLENBQUMsYUFBYTthQUMxQyxDQUFDO1FBQ0osS0FBSyxRQUFRO1lBQ1gsT0FBTztnQkFDTCxlQUFlLDJDQUE0QjtnQkFDM0MsaUJBQWlCLEVBQUUsUUFBUSxDQUFDLGFBQWE7Z0JBQ3pDLHFCQUFxQixFQUFFO29CQUNyQixJQUFJLEVBQUUsUUFBUSxDQUFDLGVBQWUsQ0FBQyxZQUFZO29CQUMzQyxTQUFTLEVBQUUsUUFBUSxDQUFDLGVBQWUsQ0FBQyxXQUFXO2lCQUNoRDthQUNGLENBQUM7UUFDSjtZQUNFLE1BQU0sSUFBSSxLQUFLLENBQUMsdUNBQXdDLFFBQWdCLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQztLQUMzRjtBQUNILENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJlc29sdmVyQ29uZmlnLCBTeW5jQ29uZmlnLCBDb25mbGljdEhhbmRsZXJUeXBlIH0gZnJvbSAnQGF3cy1hbXBsaWZ5L2dyYXBocWwtdHJhbnNmb3JtZXItY29yZSc7XG5pbXBvcnQgeyBDb25mbGljdFJlc29sdXRpb25TdHJhdGVneSwgQ29uZmxpY3RSZXNvbHV0aW9uIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG4vKipcbiAqIENvbnZlcnQgcHJvamVjdCBjb25mbGljdCByZXNvbHV0aW9uIGNvbmZpZyB0byB0cmFuc2Zvcm1lciBSZXNvbHZlckNvbmZpZyBvYmplY3QuXG4gKiBAcGFyYW0gcGFyYW0wIGlucHV0IHNoYXBlXG4gKiBAcGFyYW0gcGFyYW0wLnByb2plY3QgdGhlIHByb2plY3QgbGV2ZWwgY29uZmlnXG4gKiBAcGFyYW0gcGFyYW0wLm1vZGVscyB0aGUgbW9kZWwtc3BlY2lmaWMgb3ZlcnJpZGUgY29uZmlnXG4gKiBAcmV0dXJucyB0aGUgdHJhbnNmb3JtZXIgcmVwcmVzZW50YXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGNvbnZlcnRUb1Jlc29sdmVyQ29uZmlnID0gKHsgcHJvamVjdCwgbW9kZWxzIH06IENvbmZsaWN0UmVzb2x1dGlvbik6IFJlc29sdmVyQ29uZmlnID0+ICh7XG4gIHByb2plY3Q6IHByb2plY3QgJiYgY29udmVydFRvU3luY0NvbmZpZyhwcm9qZWN0KSxcbiAgbW9kZWxzOiBtb2RlbHMgJiYgT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKG1vZGVscykubWFwKChbbW9kZWxOYW1lLCBzdHJhdGVneV0pID0+IFttb2RlbE5hbWUsIGNvbnZlcnRUb1N5bmNDb25maWcoc3RyYXRlZ3kpXSkpLFxufSk7XG5cbi8qKlxuICogQ29udmVydCBmcm9tIGV4dGVybmFsIHRvIGludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIGNvbmZsaWN0IHJlc29sdXRpb24gY29uZmlnLlxuICogQHBhcmFtIHN0cmF0ZWd5IHRoZSBzdHJhdGVneSB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB0aGUgY29udmVydGVkIHN0cmF0ZWd5XG4gKi9cbmNvbnN0IGNvbnZlcnRUb1N5bmNDb25maWcgPSAoc3RyYXRlZ3k6IENvbmZsaWN0UmVzb2x1dGlvblN0cmF0ZWd5KTogU3luY0NvbmZpZyA9PiB7XG4gIHN3aXRjaCAoc3RyYXRlZ3kuaGFuZGxlclR5cGUpIHtcbiAgICBjYXNlICdPUFRJTUlTVElDX0NPTkNVUlJFTkNZJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIENvbmZsaWN0SGFuZGxlcjogQ29uZmxpY3RIYW5kbGVyVHlwZS5PUFRJTUlTVElDLFxuICAgICAgICBDb25mbGljdERldGVjdGlvbjogc3RyYXRlZ3kuZGV0ZWN0aW9uVHlwZSxcbiAgICAgIH07XG4gICAgY2FzZSAnQVVUT01FUkdFJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIENvbmZsaWN0SGFuZGxlcjogQ29uZmxpY3RIYW5kbGVyVHlwZS5BVVRPTUVSR0UsXG4gICAgICAgIENvbmZsaWN0RGV0ZWN0aW9uOiBzdHJhdGVneS5kZXRlY3Rpb25UeXBlLFxuICAgICAgfTtcbiAgICBjYXNlICdMQU1CREEnOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgQ29uZmxpY3RIYW5kbGVyOiBDb25mbGljdEhhbmRsZXJUeXBlLkxBTUJEQSxcbiAgICAgICAgQ29uZmxpY3REZXRlY3Rpb246IHN0cmF0ZWd5LmRldGVjdGlvblR5cGUsXG4gICAgICAgIExhbWJkYUNvbmZsaWN0SGFuZGxlcjoge1xuICAgICAgICAgIG5hbWU6IHN0cmF0ZWd5LmNvbmZsaWN0SGFuZGxlci5mdW5jdGlvbk5hbWUsXG4gICAgICAgICAgbGFtYmRhQXJuOiBzdHJhdGVneS5jb25mbGljdEhhbmRsZXIuZnVuY3Rpb25Bcm4sXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVuY291bnRlcmVkIHVuZXhwZWN0ZWQgaGFuZGxlclR5cGU6ICR7KHN0cmF0ZWd5IGFzIGFueSkuaGFuZGxlclR5cGV9YCk7XG4gIH1cbn07XG4iXX0=