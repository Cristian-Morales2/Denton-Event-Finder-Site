"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateDataSourceStrategy = exports.schemaByMergingDefinitions = exports.getDataSourceStrategiesProvider = exports.constructCustomSqlDataSourceStrategies = void 0;
const graphql_1 = require("graphql");
const graphql_transformer_core_1 = require("@aws-amplify/graphql-transformer-core");
const graphql_transformer_interfaces_1 = require("@aws-amplify/graphql-transformer-interfaces");
const aws_cdk_lib_1 = require("aws-cdk-lib");
/**
 * Creates an interface flavor of customSqlDataSourceStrategies from a factory method's schema and data source. Internally, this function
 * scans the fields of `Query` and `Mutation` looking for fields annotated with the `@sql` directive and designates the specified
 * dataSourceStrategy to fulfill those custom queries.
 *
 * Note that we do not scan for `Subscription` fields: `@sql` directives are not allowed on those, and it wouldn't make sense to do so
 * anyway, since subscriptions are processed from an incoming Mutation, not as the result of a direct datasource access.
 */
const constructCustomSqlDataSourceStrategies = (schema, dataSourceStrategy) => {
    if (!(0, graphql_transformer_core_1.isSqlStrategy)(dataSourceStrategy)) {
        return [];
    }
    const parsedSchema = (0, graphql_1.parse)(schema);
    const queryNode = parsedSchema.definitions.find(graphql_transformer_core_1.isQueryNode);
    const mutationNode = parsedSchema.definitions.find(graphql_transformer_core_1.isMutationNode);
    if (!queryNode && !mutationNode) {
        return [];
    }
    const customSqlDataSourceStrategies = [];
    if (queryNode) {
        const fields = (0, graphql_transformer_core_1.fieldsWithSqlDirective)(queryNode);
        for (const field of fields) {
            customSqlDataSourceStrategies.push({
                typeName: 'Query',
                fieldName: field.name.value,
                strategy: dataSourceStrategy,
            });
        }
    }
    if (mutationNode) {
        const fields = (0, graphql_transformer_core_1.fieldsWithSqlDirective)(mutationNode);
        for (const field of fields) {
            customSqlDataSourceStrategies.push({
                typeName: 'Mutation',
                fieldName: field.name.value,
                strategy: dataSourceStrategy,
            });
        }
    }
    return customSqlDataSourceStrategies;
};
exports.constructCustomSqlDataSourceStrategies = constructCustomSqlDataSourceStrategies;
/**
 * Extracts the data source provider from the definition. This jumps through some hoops to avoid changing the public interface. If we decide
 * to change the public interface to simplify the structure, then this process gets a lot simpler.
 */
const getDataSourceStrategiesProvider = (definition) => {
    const provider = {
        // We can directly use the interface strategies, even though the SQL strategies have the customSqlStatements field that is unused by the
        // transformer flavor of this type
        dataSourceStrategies: definition.dataSourceStrategies,
        sqlDirectiveDataSourceStrategies: [],
    };
    // We'll collect all the custom SQL statements from the definition into a single map, and use that to make our
    // SqlDirectiveDataSourceStrategies
    const customSqlStatements = {};
    const constructSqlStrategies = definition.customSqlDataSourceStrategies ?? [];
    // Note that we're relying on the `customSqlStatements` object reference to stay the same throughout this loop. Don't reassign it, or the
    // collected sqlDirectiveStrategies will break
    constructSqlStrategies.forEach((sqlStrategy) => {
        if (sqlStrategy.strategy.customSqlStatements) {
            Object.assign(customSqlStatements, sqlStrategy.strategy.customSqlStatements);
        }
        provider.sqlDirectiveDataSourceStrategies.push({
            typeName: sqlStrategy.typeName,
            fieldName: sqlStrategy.fieldName,
            strategy: sqlStrategy.strategy,
            customSqlStatements,
        });
    });
    return provider;
};
exports.getDataSourceStrategiesProvider = getDataSourceStrategiesProvider;
/**
 * Creates a new schema by merging the individual schemas contained in the definitions, combining fields of the Query and Mutation types in
 * individual definitions into a single combined definition. Adding directives to `Query` and `Mutation` types participating in a
 * combination is not supported (the behavior is undefined whether those directives are migrated).
 */
const schemaByMergingDefinitions = (definitions) => {
    const schema = definitions.map((def) => def.schema).join('\n');
    const parsedSchema = (0, graphql_1.parse)(schema);
    // We store the Query & Mutation definitions separately. Since the interfaces are readonly, we'll have to re-compose the types after we've
    // collected all the fields
    const queryAndMutationDefinitions = {};
    // Throws if the field has already been encountered
    const validateField = (typeName, fieldName) => {
        const fields = queryAndMutationDefinitions[typeName]?.fields;
        if (!fields) {
            return;
        }
        if (fields.find((field) => field.name.value === fieldName)) {
            throw new Error(`The custom ${typeName} field '${fieldName}' was found in multiple definitions, but a field name cannot be shared between definitions.`);
        }
    };
    // Transform the schema by reducing Mutation & Query types:
    // - Collect Mutation and Query definitions
    // - Alter the parsed schema by filtering out Mutation & Query types
    // - Add the combined Mutation & Query definitions to the filtered schema
    parsedSchema.definitions.filter(graphql_transformer_core_1.isBuiltInGraphqlNode).forEach((def) => {
        const typeName = def.name.value;
        if (!queryAndMutationDefinitions[typeName]) {
            queryAndMutationDefinitions[typeName] = {
                node: def,
                // `ObjectTypeDefinitionNode.fields` is a ReadonlyArray; so we have to create a new mutable array to collect all the fields
                fields: [...(def.fields ?? [])],
            };
            return;
        }
        (def.fields ?? []).forEach((field) => {
            validateField(typeName, field.name.value);
        });
        queryAndMutationDefinitions[typeName].fields = [...queryAndMutationDefinitions[typeName].fields, ...(def.fields ?? [])];
    });
    // Gather the collected Query & Mutation fields into <=2 new definitions
    const combinedDefinitions = Object.values(queryAndMutationDefinitions)
        .sort((a, b) => a.node.name.value.localeCompare(b.node.name.value))
        .reduce((acc, cur) => {
        const definitionNode = {
            ...cur.node,
            fields: cur.fields,
        };
        return [...acc, definitionNode];
    }, []);
    // Filter out the old Query & Mutation definitions
    const filteredDefinitions = parsedSchema.definitions.filter((def) => !(0, graphql_transformer_core_1.isBuiltInGraphqlNode)(def));
    // Compose the new schema by appending the collected definitions to the filtered definitions. This means that every query will be
    // rewritten such that the Mutation and Query types appear at the end of the schema.
    const newSchema = {
        ...parsedSchema,
        definitions: [...filteredDefinitions, ...combinedDefinitions],
    };
    const combinedSchemaString = (0, graphql_1.print)(newSchema);
    return combinedSchemaString;
};
exports.schemaByMergingDefinitions = schemaByMergingDefinitions;
/*
 * Validates the user input for the dataSourceStrategy. This is a no-op for DynamoDB strategies for now.
 * @param strategy user provided model data source strategy
 * @returns validates and throws an error if the strategy is invalid
 */
const validateDataSourceStrategy = (strategy) => {
    if (!(0, graphql_transformer_core_1.isSqlStrategy)(strategy)) {
        return;
    }
    const dbConnectionConfig = strategy.dbConnectionConfig;
    if ((0, graphql_transformer_interfaces_1.isSqlModelDataSourceSsmDbConnectionConfig)(dbConnectionConfig) ||
        (0, graphql_transformer_interfaces_1.isSqlModelDataSourceSsmDbConnectionStringConfig)(dbConnectionConfig)) {
        const ssmPaths = Object.values(dbConnectionConfig).filter((value) => typeof value === 'string');
        if ((0, graphql_transformer_interfaces_1.isSqlModelDataSourceSsmDbConnectionStringConfig)(dbConnectionConfig)) {
            const hasMultipleSSMPaths = Array.isArray(dbConnectionConfig?.connectionUriSsmPath);
            if (hasMultipleSSMPaths) {
                if (dbConnectionConfig?.connectionUriSsmPath?.length < 1) {
                    throw new Error(`Invalid data source strategy "${strategy.name}". connectionUriSsmPath must be a string or non-empty array.`);
                }
                ssmPaths.push(...dbConnectionConfig.connectionUriSsmPath);
            }
        }
        const invalidSSMPaths = ssmPaths.filter((value) => !isValidSSMPath(value));
        if (invalidSSMPaths.length > 0) {
            throw new Error(`Invalid data source strategy "${strategy.name}". Following SSM paths must start with '/' in dbConnectionConfig: ${invalidSSMPaths.join(', ')}.`);
        }
    }
    else if ((0, graphql_transformer_interfaces_1.isSqlModelDataSourceSecretsManagerDbConnectionConfig)(dbConnectionConfig)) {
        if (!aws_cdk_lib_1.Token.isUnresolved(dbConnectionConfig.secretArn)) {
            try {
                const arnComponents = aws_cdk_lib_1.Arn.split(dbConnectionConfig.secretArn, aws_cdk_lib_1.ArnFormat.COLON_RESOURCE_NAME);
                if (arnComponents.service !== 'secretsmanager' || arnComponents.resource !== 'secret') {
                    // error message does not matter because it inside try/catch
                    throw new Error();
                }
            }
            catch {
                throw new Error(`Invalid data source strategy "${strategy.name}". The value of secretArn is not a valid Secrets Manager ARN.`);
            }
        }
        if (dbConnectionConfig.keyArn && !aws_cdk_lib_1.Token.isUnresolved(dbConnectionConfig.keyArn)) {
            try {
                const arnComponents = aws_cdk_lib_1.Arn.split(dbConnectionConfig.keyArn, aws_cdk_lib_1.ArnFormat.SLASH_RESOURCE_NAME);
                if (arnComponents.service !== 'kms' || arnComponents.resource !== 'key') {
                    // error message does not matter because it inside try/catch
                    throw new Error();
                }
            }
            catch {
                throw new Error(`Invalid data source strategy "${strategy.name}". The value of keyArn is not a valid KMS ARN.`);
            }
        }
    }
    else {
        throw new Error(`Invalid data source strategy "${strategy.name}". dbConnectionConfig does not include SSM paths or Secret ARN.`);
    }
};
exports.validateDataSourceStrategy = validateDataSourceStrategy;
const isValidSSMPath = (path) => {
    return path.startsWith('/');
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YS1zb3VyY2UtY29uZmlnLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2ludGVybmFsL2RhdGEtc291cmNlLWNvbmZpZy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSxxQ0FBbUk7QUFDbkksb0ZBTStDO0FBQy9DLGdHQUtxRDtBQUNyRCw2Q0FBb0Q7QUFPcEQ7Ozs7Ozs7R0FPRztBQUNJLE1BQU0sc0NBQXNDLEdBQUcsQ0FDcEQsTUFBYyxFQUNkLGtCQUFvRCxFQUNaLEVBQUU7SUFDMUMsSUFBSSxDQUFDLElBQUEsd0NBQWEsRUFBQyxrQkFBa0IsQ0FBQyxFQUFFO1FBQ3RDLE9BQU8sRUFBRSxDQUFDO0tBQ1g7SUFFRCxNQUFNLFlBQVksR0FBRyxJQUFBLGVBQUssRUFBQyxNQUFNLENBQUMsQ0FBQztJQUVuQyxNQUFNLFNBQVMsR0FBRyxZQUFZLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxzQ0FBVyxDQUFDLENBQUM7SUFDN0QsTUFBTSxZQUFZLEdBQUcsWUFBWSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMseUNBQWMsQ0FBQyxDQUFDO0lBQ25FLElBQUksQ0FBQyxTQUFTLElBQUksQ0FBQyxZQUFZLEVBQUU7UUFDL0IsT0FBTyxFQUFFLENBQUM7S0FDWDtJQUVELE1BQU0sNkJBQTZCLEdBQTJDLEVBQUUsQ0FBQztJQUVqRixJQUFJLFNBQVMsRUFBRTtRQUNiLE1BQU0sTUFBTSxHQUFHLElBQUEsaURBQXNCLEVBQUMsU0FBUyxDQUFDLENBQUM7UUFDakQsS0FBSyxNQUFNLEtBQUssSUFBSSxNQUFNLEVBQUU7WUFDMUIsNkJBQTZCLENBQUMsSUFBSSxDQUFDO2dCQUNqQyxRQUFRLEVBQUUsT0FBTztnQkFDakIsU0FBUyxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSztnQkFDM0IsUUFBUSxFQUFFLGtCQUFrQjthQUM3QixDQUFDLENBQUM7U0FDSjtLQUNGO0lBRUQsSUFBSSxZQUFZLEVBQUU7UUFDaEIsTUFBTSxNQUFNLEdBQUcsSUFBQSxpREFBc0IsRUFBQyxZQUFZLENBQUMsQ0FBQztRQUNwRCxLQUFLLE1BQU0sS0FBSyxJQUFJLE1BQU0sRUFBRTtZQUMxQiw2QkFBNkIsQ0FBQyxJQUFJLENBQUM7Z0JBQ2pDLFFBQVEsRUFBRSxVQUFVO2dCQUNwQixTQUFTLEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLO2dCQUMzQixRQUFRLEVBQUUsa0JBQWtCO2FBQzdCLENBQUMsQ0FBQztTQUNKO0tBQ0Y7SUFFRCxPQUFPLDZCQUE2QixDQUFDO0FBQ3ZDLENBQUMsQ0FBQztBQXpDVyxRQUFBLHNDQUFzQywwQ0F5Q2pEO0FBRUY7OztHQUdHO0FBQ0ksTUFBTSwrQkFBK0IsR0FBRyxDQUFDLFVBQXFDLEVBQWdDLEVBQUU7SUFDckgsTUFBTSxRQUFRLEdBQWlDO1FBQzdDLHdJQUF3STtRQUN4SSxrQ0FBa0M7UUFDbEMsb0JBQW9CLEVBQUUsVUFBVSxDQUFDLG9CQUFvQjtRQUNyRCxnQ0FBZ0MsRUFBRSxFQUFFO0tBQ3JDLENBQUM7SUFFRiw4R0FBOEc7SUFDOUcsbUNBQW1DO0lBQ25DLE1BQU0sbUJBQW1CLEdBQTJCLEVBQUUsQ0FBQztJQUV2RCxNQUFNLHNCQUFzQixHQUFHLFVBQVUsQ0FBQyw2QkFBNkIsSUFBSSxFQUFFLENBQUM7SUFFOUUseUlBQXlJO0lBQ3pJLDhDQUE4QztJQUM5QyxzQkFBc0IsQ0FBQyxPQUFPLENBQUMsQ0FBQyxXQUFXLEVBQUUsRUFBRTtRQUM3QyxJQUFJLFdBQVcsQ0FBQyxRQUFRLENBQUMsbUJBQW1CLEVBQUU7WUFDNUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxtQkFBbUIsRUFBRSxXQUFXLENBQUMsUUFBUSxDQUFDLG1CQUFtQixDQUFDLENBQUM7U0FDOUU7UUFFRCxRQUFRLENBQUMsZ0NBQWlDLENBQUMsSUFBSSxDQUFDO1lBQzlDLFFBQVEsRUFBRSxXQUFXLENBQUMsUUFBUTtZQUM5QixTQUFTLEVBQUUsV0FBVyxDQUFDLFNBQVM7WUFDaEMsUUFBUSxFQUFFLFdBQVcsQ0FBQyxRQUFRO1lBQzlCLG1CQUFtQjtTQUNwQixDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztJQUVILE9BQU8sUUFBUSxDQUFDO0FBQ2xCLENBQUMsQ0FBQztBQTlCVyxRQUFBLCtCQUErQixtQ0E4QjFDO0FBRUY7Ozs7R0FJRztBQUNJLE1BQU0sMEJBQTBCLEdBQUcsQ0FBQyxXQUF3QyxFQUFVLEVBQUU7SUFDN0YsTUFBTSxNQUFNLEdBQUcsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUMvRCxNQUFNLFlBQVksR0FBRyxJQUFBLGVBQUssRUFBQyxNQUFNLENBQUMsQ0FBQztJQUVuQywwSUFBMEk7SUFDMUksMkJBQTJCO0lBQzNCLE1BQU0sMkJBQTJCLEdBTTdCLEVBQUUsQ0FBQztJQUVQLG1EQUFtRDtJQUNuRCxNQUFNLGFBQWEsR0FBRyxDQUFDLFFBQWdCLEVBQUUsU0FBaUIsRUFBUSxFQUFFO1FBQ2xFLE1BQU0sTUFBTSxHQUFHLDJCQUEyQixDQUFDLFFBQVEsQ0FBQyxFQUFFLE1BQU0sQ0FBQztRQUM3RCxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ1gsT0FBTztTQUNSO1FBQ0QsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssS0FBSyxTQUFTLENBQUMsRUFBRTtZQUMxRCxNQUFNLElBQUksS0FBSyxDQUNiLGNBQWMsUUFBUSxXQUFXLFNBQVMsNkZBQTZGLENBQ3hJLENBQUM7U0FDSDtJQUNILENBQUMsQ0FBQztJQUVGLDJEQUEyRDtJQUMzRCwyQ0FBMkM7SUFDM0Msb0VBQW9FO0lBQ3BFLHlFQUF5RTtJQUN6RSxZQUFZLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQywrQ0FBb0IsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFO1FBQ3BFLE1BQU0sUUFBUSxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDO1FBQ2hDLElBQUksQ0FBQywyQkFBMkIsQ0FBQyxRQUFRLENBQUMsRUFBRTtZQUMxQywyQkFBMkIsQ0FBQyxRQUFRLENBQUMsR0FBRztnQkFDdEMsSUFBSSxFQUFFLEdBQUc7Z0JBQ1QsMkhBQTJIO2dCQUMzSCxNQUFNLEVBQUUsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsQ0FBQzthQUNoQyxDQUFDO1lBQ0YsT0FBTztTQUNSO1FBRUQsQ0FBQyxHQUFHLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFO1lBQ25DLGFBQWEsQ0FBQyxRQUFRLEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUM1QyxDQUFDLENBQUMsQ0FBQztRQUVILDJCQUEyQixDQUFDLFFBQVEsQ0FBQyxDQUFDLE1BQU0sR0FBRyxDQUFDLEdBQUcsMkJBQTJCLENBQUMsUUFBUSxDQUFDLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDMUgsQ0FBQyxDQUFDLENBQUM7SUFFSCx3RUFBd0U7SUFDeEUsTUFBTSxtQkFBbUIsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLDJCQUEyQixDQUFDO1NBQ25FLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDbEUsTUFBTSxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxFQUFFO1FBQ25CLE1BQU0sY0FBYyxHQUFHO1lBQ3JCLEdBQUcsR0FBRyxDQUFDLElBQUk7WUFDWCxNQUFNLEVBQUUsR0FBRyxDQUFDLE1BQU07U0FDbkIsQ0FBQztRQUNGLE9BQU8sQ0FBQyxHQUFHLEdBQUcsRUFBRSxjQUFjLENBQUMsQ0FBQztJQUNsQyxDQUFDLEVBQUUsRUFBc0IsQ0FBQyxDQUFDO0lBRTdCLGtEQUFrRDtJQUNsRCxNQUFNLG1CQUFtQixHQUFHLFlBQVksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDLElBQUEsK0NBQW9CLEVBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUVqRyxpSUFBaUk7SUFDakksb0ZBQW9GO0lBQ3BGLE1BQU0sU0FBUyxHQUFHO1FBQ2hCLEdBQUcsWUFBWTtRQUNmLFdBQVcsRUFBRSxDQUFDLEdBQUcsbUJBQW1CLEVBQUUsR0FBRyxtQkFBbUIsQ0FBQztLQUM5RCxDQUFDO0lBRUYsTUFBTSxvQkFBb0IsR0FBRyxJQUFBLGVBQUssRUFBQyxTQUFTLENBQUMsQ0FBQztJQUM5QyxPQUFPLG9CQUFvQixDQUFDO0FBQzlCLENBQUMsQ0FBQztBQXhFVyxRQUFBLDBCQUEwQiw4QkF3RXJDO0FBRUY7Ozs7R0FJRztBQUNJLE1BQU0sMEJBQTBCLEdBQUcsQ0FBQyxRQUEwQyxFQUFRLEVBQUU7SUFDN0YsSUFBSSxDQUFDLElBQUEsd0NBQWEsRUFBQyxRQUFRLENBQUMsRUFBRTtRQUM1QixPQUFPO0tBQ1I7SUFFRCxNQUFNLGtCQUFrQixHQUFHLFFBQVEsQ0FBQyxrQkFBa0IsQ0FBQztJQUN2RCxJQUNFLElBQUEsMEVBQXlDLEVBQUMsa0JBQWtCLENBQUM7UUFDN0QsSUFBQSxnRkFBK0MsRUFBQyxrQkFBa0IsQ0FBQyxFQUNuRTtRQUNBLE1BQU0sUUFBUSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLE9BQU8sS0FBSyxLQUFLLFFBQVEsQ0FBQyxDQUFDO1FBQ2hHLElBQUksSUFBQSxnRkFBK0MsRUFBQyxrQkFBa0IsQ0FBQyxFQUFFO1lBQ3ZFLE1BQU0sbUJBQW1CLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxrQkFBa0IsRUFBRSxvQkFBb0IsQ0FBQyxDQUFDO1lBQ3BGLElBQUksbUJBQW1CLEVBQUU7Z0JBQ3ZCLElBQUksa0JBQWtCLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxHQUFHLENBQUMsRUFBRTtvQkFDeEQsTUFBTSxJQUFJLEtBQUssQ0FBQyxpQ0FBaUMsUUFBUSxDQUFDLElBQUksOERBQThELENBQUMsQ0FBQztpQkFDL0g7Z0JBQ0QsUUFBUSxDQUFDLElBQUksQ0FBQyxHQUFHLGtCQUFrQixDQUFDLG9CQUFvQixDQUFDLENBQUM7YUFDM0Q7U0FDRjtRQUVELE1BQU0sZUFBZSxHQUFHLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDM0UsSUFBSSxlQUFlLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUM5QixNQUFNLElBQUksS0FBSyxDQUNiLGlDQUNFLFFBQVEsQ0FBQyxJQUNYLHFFQUFxRSxlQUFlLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQ25HLENBQUM7U0FDSDtLQUNGO1NBQU0sSUFBSSxJQUFBLHFGQUFvRCxFQUFDLGtCQUFrQixDQUFDLEVBQUU7UUFDbkYsSUFBSSxDQUFDLG1CQUFLLENBQUMsWUFBWSxDQUFDLGtCQUFrQixDQUFDLFNBQVMsQ0FBQyxFQUFFO1lBQ3JELElBQUk7Z0JBQ0YsTUFBTSxhQUFhLEdBQUcsaUJBQUcsQ0FBQyxLQUFLLENBQUMsa0JBQWtCLENBQUMsU0FBUyxFQUFFLHVCQUFTLENBQUMsbUJBQW1CLENBQUMsQ0FBQztnQkFDN0YsSUFBSSxhQUFhLENBQUMsT0FBTyxLQUFLLGdCQUFnQixJQUFJLGFBQWEsQ0FBQyxRQUFRLEtBQUssUUFBUSxFQUFFO29CQUNyRiw0REFBNEQ7b0JBQzVELE1BQU0sSUFBSSxLQUFLLEVBQUUsQ0FBQztpQkFDbkI7YUFDRjtZQUFDLE1BQU07Z0JBQ04sTUFBTSxJQUFJLEtBQUssQ0FBQyxpQ0FBaUMsUUFBUSxDQUFDLElBQUksK0RBQStELENBQUMsQ0FBQzthQUNoSTtTQUNGO1FBRUQsSUFBSSxrQkFBa0IsQ0FBQyxNQUFNLElBQUksQ0FBQyxtQkFBSyxDQUFDLFlBQVksQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsRUFBRTtZQUMvRSxJQUFJO2dCQUNGLE1BQU0sYUFBYSxHQUFHLGlCQUFHLENBQUMsS0FBSyxDQUFDLGtCQUFrQixDQUFDLE1BQU0sRUFBRSx1QkFBUyxDQUFDLG1CQUFtQixDQUFDLENBQUM7Z0JBQzFGLElBQUksYUFBYSxDQUFDLE9BQU8sS0FBSyxLQUFLLElBQUksYUFBYSxDQUFDLFFBQVEsS0FBSyxLQUFLLEVBQUU7b0JBQ3ZFLDREQUE0RDtvQkFDNUQsTUFBTSxJQUFJLEtBQUssRUFBRSxDQUFDO2lCQUNuQjthQUNGO1lBQUMsTUFBTTtnQkFDTixNQUFNLElBQUksS0FBSyxDQUFDLGlDQUFpQyxRQUFRLENBQUMsSUFBSSxnREFBZ0QsQ0FBQyxDQUFDO2FBQ2pIO1NBQ0Y7S0FDRjtTQUFNO1FBQ0wsTUFBTSxJQUFJLEtBQUssQ0FBQyxpQ0FBaUMsUUFBUSxDQUFDLElBQUksaUVBQWlFLENBQUMsQ0FBQztLQUNsSTtBQUNILENBQUMsQ0FBQztBQXhEVyxRQUFBLDBCQUEwQiw4QkF3RHJDO0FBRUYsTUFBTSxjQUFjLEdBQUcsQ0FBQyxJQUFZLEVBQVcsRUFBRTtJQUMvQyxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDOUIsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGVmaW5pdGlvbk5vZGUsIEZpZWxkRGVmaW5pdGlvbk5vZGUsIEludGVyZmFjZVR5cGVEZWZpbml0aW9uTm9kZSwgT2JqZWN0VHlwZURlZmluaXRpb25Ob2RlLCBwYXJzZSwgcHJpbnQgfSBmcm9tICdncmFwaHFsJztcbmltcG9ydCB7XG4gIGlzQnVpbHRJbkdyYXBocWxOb2RlLFxuICBpc1NxbFN0cmF0ZWd5LFxuICBpc1F1ZXJ5Tm9kZSxcbiAgaXNNdXRhdGlvbk5vZGUsXG4gIGZpZWxkc1dpdGhTcWxEaXJlY3RpdmUsXG59IGZyb20gJ0Bhd3MtYW1wbGlmeS9ncmFwaHFsLXRyYW5zZm9ybWVyLWNvcmUnO1xuaW1wb3J0IHtcbiAgRGF0YVNvdXJjZVN0cmF0ZWdpZXNQcm92aWRlcixcbiAgaXNTcWxNb2RlbERhdGFTb3VyY2VTc21EYkNvbm5lY3Rpb25Db25maWcsXG4gIGlzU3FsTW9kZWxEYXRhU291cmNlU2VjcmV0c01hbmFnZXJEYkNvbm5lY3Rpb25Db25maWcsXG4gIGlzU3FsTW9kZWxEYXRhU291cmNlU3NtRGJDb25uZWN0aW9uU3RyaW5nQ29uZmlnLFxufSBmcm9tICdAYXdzLWFtcGxpZnkvZ3JhcGhxbC10cmFuc2Zvcm1lci1pbnRlcmZhY2VzJztcbmltcG9ydCB7IFRva2VuLCBBcm4sIEFybkZvcm1hdCB9IGZyb20gJ2F3cy1jZGstbGliJztcbmltcG9ydCB7XG4gIEN1c3RvbVNxbERhdGFTb3VyY2VTdHJhdGVneSBhcyBDb25zdHJ1Y3RDdXN0b21TcWxEYXRhU291cmNlU3RyYXRlZ3ksXG4gIE1vZGVsRGF0YVNvdXJjZVN0cmF0ZWd5IGFzIENvbnN0cnVjdE1vZGVsRGF0YVNvdXJjZVN0cmF0ZWd5LFxufSBmcm9tICcuLi9tb2RlbC1kYXRhc291cmNlLXN0cmF0ZWd5LXR5cGVzJztcbmltcG9ydCB7IElBbXBsaWZ5R3JhcGhxbERlZmluaXRpb24gfSBmcm9tICcuLi90eXBlcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBpbnRlcmZhY2UgZmxhdm9yIG9mIGN1c3RvbVNxbERhdGFTb3VyY2VTdHJhdGVnaWVzIGZyb20gYSBmYWN0b3J5IG1ldGhvZCdzIHNjaGVtYSBhbmQgZGF0YSBzb3VyY2UuIEludGVybmFsbHksIHRoaXMgZnVuY3Rpb25cbiAqIHNjYW5zIHRoZSBmaWVsZHMgb2YgYFF1ZXJ5YCBhbmQgYE11dGF0aW9uYCBsb29raW5nIGZvciBmaWVsZHMgYW5ub3RhdGVkIHdpdGggdGhlIGBAc3FsYCBkaXJlY3RpdmUgYW5kIGRlc2lnbmF0ZXMgdGhlIHNwZWNpZmllZFxuICogZGF0YVNvdXJjZVN0cmF0ZWd5IHRvIGZ1bGZpbGwgdGhvc2UgY3VzdG9tIHF1ZXJpZXMuXG4gKlxuICogTm90ZSB0aGF0IHdlIGRvIG5vdCBzY2FuIGZvciBgU3Vic2NyaXB0aW9uYCBmaWVsZHM6IGBAc3FsYCBkaXJlY3RpdmVzIGFyZSBub3QgYWxsb3dlZCBvbiB0aG9zZSwgYW5kIGl0IHdvdWxkbid0IG1ha2Ugc2Vuc2UgdG8gZG8gc29cbiAqIGFueXdheSwgc2luY2Ugc3Vic2NyaXB0aW9ucyBhcmUgcHJvY2Vzc2VkIGZyb20gYW4gaW5jb21pbmcgTXV0YXRpb24sIG5vdCBhcyB0aGUgcmVzdWx0IG9mIGEgZGlyZWN0IGRhdGFzb3VyY2UgYWNjZXNzLlxuICovXG5leHBvcnQgY29uc3QgY29uc3RydWN0Q3VzdG9tU3FsRGF0YVNvdXJjZVN0cmF0ZWdpZXMgPSAoXG4gIHNjaGVtYTogc3RyaW5nLFxuICBkYXRhU291cmNlU3RyYXRlZ3k6IENvbnN0cnVjdE1vZGVsRGF0YVNvdXJjZVN0cmF0ZWd5LFxuKTogQ29uc3RydWN0Q3VzdG9tU3FsRGF0YVNvdXJjZVN0cmF0ZWd5W10gPT4ge1xuICBpZiAoIWlzU3FsU3RyYXRlZ3koZGF0YVNvdXJjZVN0cmF0ZWd5KSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGNvbnN0IHBhcnNlZFNjaGVtYSA9IHBhcnNlKHNjaGVtYSk7XG5cbiAgY29uc3QgcXVlcnlOb2RlID0gcGFyc2VkU2NoZW1hLmRlZmluaXRpb25zLmZpbmQoaXNRdWVyeU5vZGUpO1xuICBjb25zdCBtdXRhdGlvbk5vZGUgPSBwYXJzZWRTY2hlbWEuZGVmaW5pdGlvbnMuZmluZChpc011dGF0aW9uTm9kZSk7XG4gIGlmICghcXVlcnlOb2RlICYmICFtdXRhdGlvbk5vZGUpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCBjdXN0b21TcWxEYXRhU291cmNlU3RyYXRlZ2llczogQ29uc3RydWN0Q3VzdG9tU3FsRGF0YVNvdXJjZVN0cmF0ZWd5W10gPSBbXTtcblxuICBpZiAocXVlcnlOb2RlKSB7XG4gICAgY29uc3QgZmllbGRzID0gZmllbGRzV2l0aFNxbERpcmVjdGl2ZShxdWVyeU5vZGUpO1xuICAgIGZvciAoY29uc3QgZmllbGQgb2YgZmllbGRzKSB7XG4gICAgICBjdXN0b21TcWxEYXRhU291cmNlU3RyYXRlZ2llcy5wdXNoKHtcbiAgICAgICAgdHlwZU5hbWU6ICdRdWVyeScsXG4gICAgICAgIGZpZWxkTmFtZTogZmllbGQubmFtZS52YWx1ZSxcbiAgICAgICAgc3RyYXRlZ3k6IGRhdGFTb3VyY2VTdHJhdGVneSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtdXRhdGlvbk5vZGUpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBmaWVsZHNXaXRoU3FsRGlyZWN0aXZlKG11dGF0aW9uTm9kZSk7XG4gICAgZm9yIChjb25zdCBmaWVsZCBvZiBmaWVsZHMpIHtcbiAgICAgIGN1c3RvbVNxbERhdGFTb3VyY2VTdHJhdGVnaWVzLnB1c2goe1xuICAgICAgICB0eXBlTmFtZTogJ011dGF0aW9uJyxcbiAgICAgICAgZmllbGROYW1lOiBmaWVsZC5uYW1lLnZhbHVlLFxuICAgICAgICBzdHJhdGVneTogZGF0YVNvdXJjZVN0cmF0ZWd5LFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGN1c3RvbVNxbERhdGFTb3VyY2VTdHJhdGVnaWVzO1xufTtcblxuLyoqXG4gKiBFeHRyYWN0cyB0aGUgZGF0YSBzb3VyY2UgcHJvdmlkZXIgZnJvbSB0aGUgZGVmaW5pdGlvbi4gVGhpcyBqdW1wcyB0aHJvdWdoIHNvbWUgaG9vcHMgdG8gYXZvaWQgY2hhbmdpbmcgdGhlIHB1YmxpYyBpbnRlcmZhY2UuIElmIHdlIGRlY2lkZVxuICogdG8gY2hhbmdlIHRoZSBwdWJsaWMgaW50ZXJmYWNlIHRvIHNpbXBsaWZ5IHRoZSBzdHJ1Y3R1cmUsIHRoZW4gdGhpcyBwcm9jZXNzIGdldHMgYSBsb3Qgc2ltcGxlci5cbiAqL1xuZXhwb3J0IGNvbnN0IGdldERhdGFTb3VyY2VTdHJhdGVnaWVzUHJvdmlkZXIgPSAoZGVmaW5pdGlvbjogSUFtcGxpZnlHcmFwaHFsRGVmaW5pdGlvbik6IERhdGFTb3VyY2VTdHJhdGVnaWVzUHJvdmlkZXIgPT4ge1xuICBjb25zdCBwcm92aWRlcjogRGF0YVNvdXJjZVN0cmF0ZWdpZXNQcm92aWRlciA9IHtcbiAgICAvLyBXZSBjYW4gZGlyZWN0bHkgdXNlIHRoZSBpbnRlcmZhY2Ugc3RyYXRlZ2llcywgZXZlbiB0aG91Z2ggdGhlIFNRTCBzdHJhdGVnaWVzIGhhdmUgdGhlIGN1c3RvbVNxbFN0YXRlbWVudHMgZmllbGQgdGhhdCBpcyB1bnVzZWQgYnkgdGhlXG4gICAgLy8gdHJhbnNmb3JtZXIgZmxhdm9yIG9mIHRoaXMgdHlwZVxuICAgIGRhdGFTb3VyY2VTdHJhdGVnaWVzOiBkZWZpbml0aW9uLmRhdGFTb3VyY2VTdHJhdGVnaWVzLFxuICAgIHNxbERpcmVjdGl2ZURhdGFTb3VyY2VTdHJhdGVnaWVzOiBbXSxcbiAgfTtcblxuICAvLyBXZSdsbCBjb2xsZWN0IGFsbCB0aGUgY3VzdG9tIFNRTCBzdGF0ZW1lbnRzIGZyb20gdGhlIGRlZmluaXRpb24gaW50byBhIHNpbmdsZSBtYXAsIGFuZCB1c2UgdGhhdCB0byBtYWtlIG91clxuICAvLyBTcWxEaXJlY3RpdmVEYXRhU291cmNlU3RyYXRlZ2llc1xuICBjb25zdCBjdXN0b21TcWxTdGF0ZW1lbnRzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG5cbiAgY29uc3QgY29uc3RydWN0U3FsU3RyYXRlZ2llcyA9IGRlZmluaXRpb24uY3VzdG9tU3FsRGF0YVNvdXJjZVN0cmF0ZWdpZXMgPz8gW107XG5cbiAgLy8gTm90ZSB0aGF0IHdlJ3JlIHJlbHlpbmcgb24gdGhlIGBjdXN0b21TcWxTdGF0ZW1lbnRzYCBvYmplY3QgcmVmZXJlbmNlIHRvIHN0YXkgdGhlIHNhbWUgdGhyb3VnaG91dCB0aGlzIGxvb3AuIERvbid0IHJlYXNzaWduIGl0LCBvciB0aGVcbiAgLy8gY29sbGVjdGVkIHNxbERpcmVjdGl2ZVN0cmF0ZWdpZXMgd2lsbCBicmVha1xuICBjb25zdHJ1Y3RTcWxTdHJhdGVnaWVzLmZvckVhY2goKHNxbFN0cmF0ZWd5KSA9PiB7XG4gICAgaWYgKHNxbFN0cmF0ZWd5LnN0cmF0ZWd5LmN1c3RvbVNxbFN0YXRlbWVudHMpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oY3VzdG9tU3FsU3RhdGVtZW50cywgc3FsU3RyYXRlZ3kuc3RyYXRlZ3kuY3VzdG9tU3FsU3RhdGVtZW50cyk7XG4gICAgfVxuXG4gICAgcHJvdmlkZXIuc3FsRGlyZWN0aXZlRGF0YVNvdXJjZVN0cmF0ZWdpZXMhLnB1c2goe1xuICAgICAgdHlwZU5hbWU6IHNxbFN0cmF0ZWd5LnR5cGVOYW1lLFxuICAgICAgZmllbGROYW1lOiBzcWxTdHJhdGVneS5maWVsZE5hbWUsXG4gICAgICBzdHJhdGVneTogc3FsU3RyYXRlZ3kuc3RyYXRlZ3ksXG4gICAgICBjdXN0b21TcWxTdGF0ZW1lbnRzLFxuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gcHJvdmlkZXI7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgc2NoZW1hIGJ5IG1lcmdpbmcgdGhlIGluZGl2aWR1YWwgc2NoZW1hcyBjb250YWluZWQgaW4gdGhlIGRlZmluaXRpb25zLCBjb21iaW5pbmcgZmllbGRzIG9mIHRoZSBRdWVyeSBhbmQgTXV0YXRpb24gdHlwZXMgaW5cbiAqIGluZGl2aWR1YWwgZGVmaW5pdGlvbnMgaW50byBhIHNpbmdsZSBjb21iaW5lZCBkZWZpbml0aW9uLiBBZGRpbmcgZGlyZWN0aXZlcyB0byBgUXVlcnlgIGFuZCBgTXV0YXRpb25gIHR5cGVzIHBhcnRpY2lwYXRpbmcgaW4gYVxuICogY29tYmluYXRpb24gaXMgbm90IHN1cHBvcnRlZCAodGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZCB3aGV0aGVyIHRob3NlIGRpcmVjdGl2ZXMgYXJlIG1pZ3JhdGVkKS5cbiAqL1xuZXhwb3J0IGNvbnN0IHNjaGVtYUJ5TWVyZ2luZ0RlZmluaXRpb25zID0gKGRlZmluaXRpb25zOiBJQW1wbGlmeUdyYXBocWxEZWZpbml0aW9uW10pOiBzdHJpbmcgPT4ge1xuICBjb25zdCBzY2hlbWEgPSBkZWZpbml0aW9ucy5tYXAoKGRlZikgPT4gZGVmLnNjaGVtYSkuam9pbignXFxuJyk7XG4gIGNvbnN0IHBhcnNlZFNjaGVtYSA9IHBhcnNlKHNjaGVtYSk7XG5cbiAgLy8gV2Ugc3RvcmUgdGhlIFF1ZXJ5ICYgTXV0YXRpb24gZGVmaW5pdGlvbnMgc2VwYXJhdGVseS4gU2luY2UgdGhlIGludGVyZmFjZXMgYXJlIHJlYWRvbmx5LCB3ZSdsbCBoYXZlIHRvIHJlLWNvbXBvc2UgdGhlIHR5cGVzIGFmdGVyIHdlJ3ZlXG4gIC8vIGNvbGxlY3RlZCBhbGwgdGhlIGZpZWxkc1xuICBjb25zdCBxdWVyeUFuZE11dGF0aW9uRGVmaW5pdGlvbnM6IFJlY29yZDxcbiAgICBzdHJpbmcsXG4gICAge1xuICAgICAgbm9kZTogT2JqZWN0VHlwZURlZmluaXRpb25Ob2RlIHwgSW50ZXJmYWNlVHlwZURlZmluaXRpb25Ob2RlO1xuICAgICAgZmllbGRzOiBGaWVsZERlZmluaXRpb25Ob2RlW107XG4gICAgfVxuICA+ID0ge307XG5cbiAgLy8gVGhyb3dzIGlmIHRoZSBmaWVsZCBoYXMgYWxyZWFkeSBiZWVuIGVuY291bnRlcmVkXG4gIGNvbnN0IHZhbGlkYXRlRmllbGQgPSAodHlwZU5hbWU6IHN0cmluZywgZmllbGROYW1lOiBzdHJpbmcpOiB2b2lkID0+IHtcbiAgICBjb25zdCBmaWVsZHMgPSBxdWVyeUFuZE11dGF0aW9uRGVmaW5pdGlvbnNbdHlwZU5hbWVdPy5maWVsZHM7XG4gICAgaWYgKCFmaWVsZHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGZpZWxkcy5maW5kKChmaWVsZCkgPT4gZmllbGQubmFtZS52YWx1ZSA9PT0gZmllbGROYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVGhlIGN1c3RvbSAke3R5cGVOYW1lfSBmaWVsZCAnJHtmaWVsZE5hbWV9JyB3YXMgZm91bmQgaW4gbXVsdGlwbGUgZGVmaW5pdGlvbnMsIGJ1dCBhIGZpZWxkIG5hbWUgY2Fubm90IGJlIHNoYXJlZCBiZXR3ZWVuIGRlZmluaXRpb25zLmAsXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICAvLyBUcmFuc2Zvcm0gdGhlIHNjaGVtYSBieSByZWR1Y2luZyBNdXRhdGlvbiAmIFF1ZXJ5IHR5cGVzOlxuICAvLyAtIENvbGxlY3QgTXV0YXRpb24gYW5kIFF1ZXJ5IGRlZmluaXRpb25zXG4gIC8vIC0gQWx0ZXIgdGhlIHBhcnNlZCBzY2hlbWEgYnkgZmlsdGVyaW5nIG91dCBNdXRhdGlvbiAmIFF1ZXJ5IHR5cGVzXG4gIC8vIC0gQWRkIHRoZSBjb21iaW5lZCBNdXRhdGlvbiAmIFF1ZXJ5IGRlZmluaXRpb25zIHRvIHRoZSBmaWx0ZXJlZCBzY2hlbWFcbiAgcGFyc2VkU2NoZW1hLmRlZmluaXRpb25zLmZpbHRlcihpc0J1aWx0SW5HcmFwaHFsTm9kZSkuZm9yRWFjaCgoZGVmKSA9PiB7XG4gICAgY29uc3QgdHlwZU5hbWUgPSBkZWYubmFtZS52YWx1ZTtcbiAgICBpZiAoIXF1ZXJ5QW5kTXV0YXRpb25EZWZpbml0aW9uc1t0eXBlTmFtZV0pIHtcbiAgICAgIHF1ZXJ5QW5kTXV0YXRpb25EZWZpbml0aW9uc1t0eXBlTmFtZV0gPSB7XG4gICAgICAgIG5vZGU6IGRlZixcbiAgICAgICAgLy8gYE9iamVjdFR5cGVEZWZpbml0aW9uTm9kZS5maWVsZHNgIGlzIGEgUmVhZG9ubHlBcnJheTsgc28gd2UgaGF2ZSB0byBjcmVhdGUgYSBuZXcgbXV0YWJsZSBhcnJheSB0byBjb2xsZWN0IGFsbCB0aGUgZmllbGRzXG4gICAgICAgIGZpZWxkczogWy4uLihkZWYuZmllbGRzID8/IFtdKV0sXG4gICAgICB9O1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIChkZWYuZmllbGRzID8/IFtdKS5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgICAgdmFsaWRhdGVGaWVsZCh0eXBlTmFtZSwgZmllbGQubmFtZS52YWx1ZSk7XG4gICAgfSk7XG5cbiAgICBxdWVyeUFuZE11dGF0aW9uRGVmaW5pdGlvbnNbdHlwZU5hbWVdLmZpZWxkcyA9IFsuLi5xdWVyeUFuZE11dGF0aW9uRGVmaW5pdGlvbnNbdHlwZU5hbWVdLmZpZWxkcywgLi4uKGRlZi5maWVsZHMgPz8gW10pXTtcbiAgfSk7XG5cbiAgLy8gR2F0aGVyIHRoZSBjb2xsZWN0ZWQgUXVlcnkgJiBNdXRhdGlvbiBmaWVsZHMgaW50byA8PTIgbmV3IGRlZmluaXRpb25zXG4gIGNvbnN0IGNvbWJpbmVkRGVmaW5pdGlvbnMgPSBPYmplY3QudmFsdWVzKHF1ZXJ5QW5kTXV0YXRpb25EZWZpbml0aW9ucylcbiAgICAuc29ydCgoYSwgYikgPT4gYS5ub2RlLm5hbWUudmFsdWUubG9jYWxlQ29tcGFyZShiLm5vZGUubmFtZS52YWx1ZSkpXG4gICAgLnJlZHVjZSgoYWNjLCBjdXIpID0+IHtcbiAgICAgIGNvbnN0IGRlZmluaXRpb25Ob2RlID0ge1xuICAgICAgICAuLi5jdXIubm9kZSxcbiAgICAgICAgZmllbGRzOiBjdXIuZmllbGRzLFxuICAgICAgfTtcbiAgICAgIHJldHVybiBbLi4uYWNjLCBkZWZpbml0aW9uTm9kZV07XG4gICAgfSwgW10gYXMgRGVmaW5pdGlvbk5vZGVbXSk7XG5cbiAgLy8gRmlsdGVyIG91dCB0aGUgb2xkIFF1ZXJ5ICYgTXV0YXRpb24gZGVmaW5pdGlvbnNcbiAgY29uc3QgZmlsdGVyZWREZWZpbml0aW9ucyA9IHBhcnNlZFNjaGVtYS5kZWZpbml0aW9ucy5maWx0ZXIoKGRlZikgPT4gIWlzQnVpbHRJbkdyYXBocWxOb2RlKGRlZikpO1xuXG4gIC8vIENvbXBvc2UgdGhlIG5ldyBzY2hlbWEgYnkgYXBwZW5kaW5nIHRoZSBjb2xsZWN0ZWQgZGVmaW5pdGlvbnMgdG8gdGhlIGZpbHRlcmVkIGRlZmluaXRpb25zLiBUaGlzIG1lYW5zIHRoYXQgZXZlcnkgcXVlcnkgd2lsbCBiZVxuICAvLyByZXdyaXR0ZW4gc3VjaCB0aGF0IHRoZSBNdXRhdGlvbiBhbmQgUXVlcnkgdHlwZXMgYXBwZWFyIGF0IHRoZSBlbmQgb2YgdGhlIHNjaGVtYS5cbiAgY29uc3QgbmV3U2NoZW1hID0ge1xuICAgIC4uLnBhcnNlZFNjaGVtYSxcbiAgICBkZWZpbml0aW9uczogWy4uLmZpbHRlcmVkRGVmaW5pdGlvbnMsIC4uLmNvbWJpbmVkRGVmaW5pdGlvbnNdLFxuICB9O1xuXG4gIGNvbnN0IGNvbWJpbmVkU2NoZW1hU3RyaW5nID0gcHJpbnQobmV3U2NoZW1hKTtcbiAgcmV0dXJuIGNvbWJpbmVkU2NoZW1hU3RyaW5nO1xufTtcblxuLypcbiAqIFZhbGlkYXRlcyB0aGUgdXNlciBpbnB1dCBmb3IgdGhlIGRhdGFTb3VyY2VTdHJhdGVneS4gVGhpcyBpcyBhIG5vLW9wIGZvciBEeW5hbW9EQiBzdHJhdGVnaWVzIGZvciBub3cuXG4gKiBAcGFyYW0gc3RyYXRlZ3kgdXNlciBwcm92aWRlZCBtb2RlbCBkYXRhIHNvdXJjZSBzdHJhdGVneVxuICogQHJldHVybnMgdmFsaWRhdGVzIGFuZCB0aHJvd3MgYW4gZXJyb3IgaWYgdGhlIHN0cmF0ZWd5IGlzIGludmFsaWRcbiAqL1xuZXhwb3J0IGNvbnN0IHZhbGlkYXRlRGF0YVNvdXJjZVN0cmF0ZWd5ID0gKHN0cmF0ZWd5OiBDb25zdHJ1Y3RNb2RlbERhdGFTb3VyY2VTdHJhdGVneSk6IHZvaWQgPT4ge1xuICBpZiAoIWlzU3FsU3RyYXRlZ3koc3RyYXRlZ3kpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgZGJDb25uZWN0aW9uQ29uZmlnID0gc3RyYXRlZ3kuZGJDb25uZWN0aW9uQ29uZmlnO1xuICBpZiAoXG4gICAgaXNTcWxNb2RlbERhdGFTb3VyY2VTc21EYkNvbm5lY3Rpb25Db25maWcoZGJDb25uZWN0aW9uQ29uZmlnKSB8fFxuICAgIGlzU3FsTW9kZWxEYXRhU291cmNlU3NtRGJDb25uZWN0aW9uU3RyaW5nQ29uZmlnKGRiQ29ubmVjdGlvbkNvbmZpZylcbiAgKSB7XG4gICAgY29uc3Qgc3NtUGF0aHMgPSBPYmplY3QudmFsdWVzKGRiQ29ubmVjdGlvbkNvbmZpZykuZmlsdGVyKCh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyk7XG4gICAgaWYgKGlzU3FsTW9kZWxEYXRhU291cmNlU3NtRGJDb25uZWN0aW9uU3RyaW5nQ29uZmlnKGRiQ29ubmVjdGlvbkNvbmZpZykpIHtcbiAgICAgIGNvbnN0IGhhc011bHRpcGxlU1NNUGF0aHMgPSBBcnJheS5pc0FycmF5KGRiQ29ubmVjdGlvbkNvbmZpZz8uY29ubmVjdGlvblVyaVNzbVBhdGgpO1xuICAgICAgaWYgKGhhc011bHRpcGxlU1NNUGF0aHMpIHtcbiAgICAgICAgaWYgKGRiQ29ubmVjdGlvbkNvbmZpZz8uY29ubmVjdGlvblVyaVNzbVBhdGg/Lmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZGF0YSBzb3VyY2Ugc3RyYXRlZ3kgXCIke3N0cmF0ZWd5Lm5hbWV9XCIuIGNvbm5lY3Rpb25VcmlTc21QYXRoIG11c3QgYmUgYSBzdHJpbmcgb3Igbm9uLWVtcHR5IGFycmF5LmApO1xuICAgICAgICB9XG4gICAgICAgIHNzbVBhdGhzLnB1c2goLi4uZGJDb25uZWN0aW9uQ29uZmlnLmNvbm5lY3Rpb25VcmlTc21QYXRoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBpbnZhbGlkU1NNUGF0aHMgPSBzc21QYXRocy5maWx0ZXIoKHZhbHVlKSA9PiAhaXNWYWxpZFNTTVBhdGgodmFsdWUpKTtcbiAgICBpZiAoaW52YWxpZFNTTVBhdGhzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEludmFsaWQgZGF0YSBzb3VyY2Ugc3RyYXRlZ3kgXCIke1xuICAgICAgICAgIHN0cmF0ZWd5Lm5hbWVcbiAgICAgICAgfVwiLiBGb2xsb3dpbmcgU1NNIHBhdGhzIG11c3Qgc3RhcnQgd2l0aCAnLycgaW4gZGJDb25uZWN0aW9uQ29uZmlnOiAke2ludmFsaWRTU01QYXRocy5qb2luKCcsICcpfS5gLFxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNTcWxNb2RlbERhdGFTb3VyY2VTZWNyZXRzTWFuYWdlckRiQ29ubmVjdGlvbkNvbmZpZyhkYkNvbm5lY3Rpb25Db25maWcpKSB7XG4gICAgaWYgKCFUb2tlbi5pc1VucmVzb2x2ZWQoZGJDb25uZWN0aW9uQ29uZmlnLnNlY3JldEFybikpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGFybkNvbXBvbmVudHMgPSBBcm4uc3BsaXQoZGJDb25uZWN0aW9uQ29uZmlnLnNlY3JldEFybiwgQXJuRm9ybWF0LkNPTE9OX1JFU09VUkNFX05BTUUpO1xuICAgICAgICBpZiAoYXJuQ29tcG9uZW50cy5zZXJ2aWNlICE9PSAnc2VjcmV0c21hbmFnZXInIHx8IGFybkNvbXBvbmVudHMucmVzb3VyY2UgIT09ICdzZWNyZXQnKSB7XG4gICAgICAgICAgLy8gZXJyb3IgbWVzc2FnZSBkb2VzIG5vdCBtYXR0ZXIgYmVjYXVzZSBpdCBpbnNpZGUgdHJ5L2NhdGNoXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZGF0YSBzb3VyY2Ugc3RyYXRlZ3kgXCIke3N0cmF0ZWd5Lm5hbWV9XCIuIFRoZSB2YWx1ZSBvZiBzZWNyZXRBcm4gaXMgbm90IGEgdmFsaWQgU2VjcmV0cyBNYW5hZ2VyIEFSTi5gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGJDb25uZWN0aW9uQ29uZmlnLmtleUFybiAmJiAhVG9rZW4uaXNVbnJlc29sdmVkKGRiQ29ubmVjdGlvbkNvbmZpZy5rZXlBcm4pKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBhcm5Db21wb25lbnRzID0gQXJuLnNwbGl0KGRiQ29ubmVjdGlvbkNvbmZpZy5rZXlBcm4sIEFybkZvcm1hdC5TTEFTSF9SRVNPVVJDRV9OQU1FKTtcbiAgICAgICAgaWYgKGFybkNvbXBvbmVudHMuc2VydmljZSAhPT0gJ2ttcycgfHwgYXJuQ29tcG9uZW50cy5yZXNvdXJjZSAhPT0gJ2tleScpIHtcbiAgICAgICAgICAvLyBlcnJvciBtZXNzYWdlIGRvZXMgbm90IG1hdHRlciBiZWNhdXNlIGl0IGluc2lkZSB0cnkvY2F0Y2hcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkYXRhIHNvdXJjZSBzdHJhdGVneSBcIiR7c3RyYXRlZ3kubmFtZX1cIi4gVGhlIHZhbHVlIG9mIGtleUFybiBpcyBub3QgYSB2YWxpZCBLTVMgQVJOLmApO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZGF0YSBzb3VyY2Ugc3RyYXRlZ3kgXCIke3N0cmF0ZWd5Lm5hbWV9XCIuIGRiQ29ubmVjdGlvbkNvbmZpZyBkb2VzIG5vdCBpbmNsdWRlIFNTTSBwYXRocyBvciBTZWNyZXQgQVJOLmApO1xuICB9XG59O1xuXG5jb25zdCBpc1ZhbGlkU1NNUGF0aCA9IChwYXRoOiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgcmV0dXJuIHBhdGguc3RhcnRzV2l0aCgnLycpO1xufTtcbiJdfQ==