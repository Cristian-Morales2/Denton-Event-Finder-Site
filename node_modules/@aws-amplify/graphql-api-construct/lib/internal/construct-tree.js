"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.walkAndProcessNodes = exports.getStackForScope = void 0;
/**
 * Given a scope, search up for the parent stack. This should be the nearest stack object.
 * @param scope the scope to search up against.
 * @returns the stack, if one can be found, else throws an error.
 */
const getStackForScope = (scope, getRootStack = false) => {
    const stacksInHierarchy = scope.node.scopes.filter((parentScope) => 'templateOptions' in parentScope);
    if (stacksInHierarchy.length === 0) {
        throw new Error('No Stack Found in Construct Scope');
    }
    const stacks = getRootStack ? stacksInHierarchy : stacksInHierarchy.reverse();
    return stacks[0];
};
exports.getStackForScope = getStackForScope;
/**
 * Utility to iteratively walk the construct tree starting at a particular node, executing a node processor at each step.
 * @param currentScope the scope to process.
 * @param processNode the fn to invoke on walk.
 */
const walkAndProcessNodes = (currentScope, processNode) => {
    processNode(currentScope);
    currentScope.node.children.forEach((child) => (0, exports.walkAndProcessNodes)(child, processNode));
};
exports.walkAndProcessNodes = walkAndProcessNodes;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29uc3RydWN0LXRyZWUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvaW50ZXJuYWwvY29uc3RydWN0LXRyZWUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBR0E7Ozs7R0FJRztBQUNJLE1BQU0sZ0JBQWdCLEdBQUcsQ0FBQyxLQUFnQixFQUFFLFlBQVksR0FBRyxLQUFLLEVBQVMsRUFBRTtJQUNoRixNQUFNLGlCQUFpQixHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLFdBQVcsRUFBRSxFQUFFLENBQUMsaUJBQWlCLElBQUksV0FBVyxDQUFDLENBQUM7SUFDdEcsSUFBSSxpQkFBaUIsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1FBQ2xDLE1BQU0sSUFBSSxLQUFLLENBQUMsbUNBQW1DLENBQUMsQ0FBQztLQUN0RDtJQUNELE1BQU0sTUFBTSxHQUFHLFlBQVksQ0FBQyxDQUFDLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLGlCQUFpQixDQUFDLE9BQU8sRUFBRSxDQUFDO0lBQzlFLE9BQU8sTUFBTSxDQUFDLENBQUMsQ0FBVSxDQUFDO0FBQzVCLENBQUMsQ0FBQztBQVBXLFFBQUEsZ0JBQWdCLG9CQU8zQjtBQUVGOzs7O0dBSUc7QUFDSSxNQUFNLG1CQUFtQixHQUFHLENBQUMsWUFBdUIsRUFBRSxXQUF1QyxFQUFRLEVBQUU7SUFDNUcsV0FBVyxDQUFDLFlBQVksQ0FBQyxDQUFDO0lBQzFCLFlBQVksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsSUFBQSwyQkFBbUIsRUFBQyxLQUFLLEVBQUUsV0FBVyxDQUFDLENBQUMsQ0FBQztBQUN6RixDQUFDLENBQUM7QUFIVyxRQUFBLG1CQUFtQix1QkFHOUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTdGFjayB9IGZyb20gJ2F3cy1jZGstbGliJztcbmltcG9ydCB7IENvbnN0cnVjdCB9IGZyb20gJ2NvbnN0cnVjdHMnO1xuXG4vKipcbiAqIEdpdmVuIGEgc2NvcGUsIHNlYXJjaCB1cCBmb3IgdGhlIHBhcmVudCBzdGFjay4gVGhpcyBzaG91bGQgYmUgdGhlIG5lYXJlc3Qgc3RhY2sgb2JqZWN0LlxuICogQHBhcmFtIHNjb3BlIHRoZSBzY29wZSB0byBzZWFyY2ggdXAgYWdhaW5zdC5cbiAqIEByZXR1cm5zIHRoZSBzdGFjaywgaWYgb25lIGNhbiBiZSBmb3VuZCwgZWxzZSB0aHJvd3MgYW4gZXJyb3IuXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRTdGFja0ZvclNjb3BlID0gKHNjb3BlOiBDb25zdHJ1Y3QsIGdldFJvb3RTdGFjayA9IGZhbHNlKTogU3RhY2sgPT4ge1xuICBjb25zdCBzdGFja3NJbkhpZXJhcmNoeSA9IHNjb3BlLm5vZGUuc2NvcGVzLmZpbHRlcigocGFyZW50U2NvcGUpID0+ICd0ZW1wbGF0ZU9wdGlvbnMnIGluIHBhcmVudFNjb3BlKTtcbiAgaWYgKHN0YWNrc0luSGllcmFyY2h5Lmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gU3RhY2sgRm91bmQgaW4gQ29uc3RydWN0IFNjb3BlJyk7XG4gIH1cbiAgY29uc3Qgc3RhY2tzID0gZ2V0Um9vdFN0YWNrID8gc3RhY2tzSW5IaWVyYXJjaHkgOiBzdGFja3NJbkhpZXJhcmNoeS5yZXZlcnNlKCk7XG4gIHJldHVybiBzdGFja3NbMF0gYXMgU3RhY2s7XG59O1xuXG4vKipcbiAqIFV0aWxpdHkgdG8gaXRlcmF0aXZlbHkgd2FsayB0aGUgY29uc3RydWN0IHRyZWUgc3RhcnRpbmcgYXQgYSBwYXJ0aWN1bGFyIG5vZGUsIGV4ZWN1dGluZyBhIG5vZGUgcHJvY2Vzc29yIGF0IGVhY2ggc3RlcC5cbiAqIEBwYXJhbSBjdXJyZW50U2NvcGUgdGhlIHNjb3BlIHRvIHByb2Nlc3MuXG4gKiBAcGFyYW0gcHJvY2Vzc05vZGUgdGhlIGZuIHRvIGludm9rZSBvbiB3YWxrLlxuICovXG5leHBvcnQgY29uc3Qgd2Fsa0FuZFByb2Nlc3NOb2RlcyA9IChjdXJyZW50U2NvcGU6IENvbnN0cnVjdCwgcHJvY2Vzc05vZGU6IChzY29wZTogQ29uc3RydWN0KSA9PiB2b2lkKTogdm9pZCA9PiB7XG4gIHByb2Nlc3NOb2RlKGN1cnJlbnRTY29wZSk7XG4gIGN1cnJlbnRTY29wZS5ub2RlLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB3YWxrQW5kUHJvY2Vzc05vZGVzKGNoaWxkLCBwcm9jZXNzTm9kZSkpO1xufTtcbiJdfQ==