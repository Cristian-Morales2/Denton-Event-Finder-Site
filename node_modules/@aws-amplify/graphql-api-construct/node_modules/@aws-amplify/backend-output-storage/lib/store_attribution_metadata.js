"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AttributionMetadataStorage = void 0;
const _os = __importStar(require("os"));
const platform_core_1 = require("@aws-amplify/platform-core");
const _fs = __importStar(require("fs"));
/**
 * Stores BI metrics information in stack descriptions
 */
class AttributionMetadataStorage {
    fs;
    os;
    /**
     * Constructor with props for injecting test mocks
     */
    constructor(fs = _fs, os = _os) {
        this.fs = fs;
        this.os = os;
    }
    /**
     * Stores an attribution metadata string in the stack description of the provided stack
     * Does nothing if the stack already has a non-empty description
     */
    storeAttributionMetadata = (stack, stackType, libraryPackageJsonAbsolutePath, additionalMetadata = {}) => {
        if (typeof stack.templateOptions.description === 'string' &&
            stack.templateOptions.description.length > 0) {
            // don't overwrite an existing description
            return;
        }
        stack.templateOptions.description = JSON.stringify(this.getAttributionMetadata(stack, stackType, libraryPackageJsonAbsolutePath, additionalMetadata));
    };
    getAttributionMetadata = (stack, stackType, libraryPackageJsonAbsolutePath, additionalMetadata) => ({
        createdOn: this.getPlatform(),
        createdBy: this.getDeploymentEngineType(stack),
        createdWith: this.getLibraryVersion(libraryPackageJsonAbsolutePath),
        stackType: stackType,
        metadata: additionalMetadata,
    });
    getLibraryVersion = (absolutePackageJsonPath) => {
        if (!this.fs.existsSync(absolutePackageJsonPath)) {
            throw new Error(`Could not find ${absolutePackageJsonPath} to load library version from`);
        }
        const packageJsonContents = JSON.parse(
        // we have to use sync fs methods here because this is part of cdk synth
        this.fs.readFileSync(absolutePackageJsonPath, 'utf-8'));
        const libraryVersion = packageJsonContents.version;
        if (typeof libraryVersion !== 'string') {
            throw new Error(`Could not parse library version from ${absolutePackageJsonPath}`);
        }
        return libraryVersion;
    };
    getDeploymentEngineType = (stack) => {
        const deploymentType = stack.node.tryGetContext(platform_core_1.CDKContextKey.DEPLOYMENT_TYPE);
        if (deploymentType === undefined) {
            // if no deployment type context value is set, assume the construct is being used in a native CDK project
            return 'AmplifyCDK';
        }
        switch (deploymentType) {
            case 'branch':
                return 'AmplifyPipelineDeploy';
            case 'sandbox':
                return 'AmplifySandbox';
            default:
                throw new Error(`Unknown ${platform_core_1.CDKContextKey.DEPLOYMENT_TYPE} CDK context value "${deploymentType}"`);
        }
    };
    getPlatform = () => {
        switch (this.os.platform()) {
            case 'darwin':
                return 'Mac';
            case 'win32':
                return 'Windows';
            case 'linux':
                return 'Linux';
            default:
                return 'Other';
        }
    };
}
exports.AttributionMetadataStorage = AttributionMetadataStorage;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RvcmVfYXR0cmlidXRpb25fbWV0YWRhdGEuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvc3RvcmVfYXR0cmlidXRpb25fbWV0YWRhdGEudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQSx3Q0FBMEI7QUFDMUIsOERBQTJEO0FBQzNELHdDQUEwQjtBQUcxQjs7R0FFRztBQUNILE1BQWEsMEJBQTBCO0lBS2xCO0lBQ0E7SUFMbkI7O09BRUc7SUFDSCxZQUNtQixLQUFpQixHQUFHLEVBQ3BCLEtBQWlCLEdBQUc7UUFEcEIsT0FBRSxHQUFGLEVBQUUsQ0FBa0I7UUFDcEIsT0FBRSxHQUFGLEVBQUUsQ0FBa0I7SUFDcEMsQ0FBQztJQUVKOzs7T0FHRztJQUNILHdCQUF3QixHQUFHLENBQ3pCLEtBQVksRUFDWixTQUFpQixFQUNqQiw4QkFBc0MsRUFDdEMscUJBQTZDLEVBQUUsRUFDekMsRUFBRTtRQUNSLElBQ0UsT0FBTyxLQUFLLENBQUMsZUFBZSxDQUFDLFdBQVcsS0FBSyxRQUFRO1lBQ3JELEtBQUssQ0FBQyxlQUFlLENBQUMsV0FBVyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQzVDO1lBQ0EsMENBQTBDO1lBQzFDLE9BQU87U0FDUjtRQUNELEtBQUssQ0FBQyxlQUFlLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQ2hELElBQUksQ0FBQyxzQkFBc0IsQ0FDekIsS0FBSyxFQUNMLFNBQVMsRUFDVCw4QkFBOEIsRUFDOUIsa0JBQWtCLENBQ25CLENBQ0YsQ0FBQztJQUNKLENBQUMsQ0FBQztJQUVNLHNCQUFzQixHQUFHLENBQy9CLEtBQVksRUFDWixTQUFpQixFQUNqQiw4QkFBc0MsRUFDdEMsa0JBQTBDLEVBQ3JCLEVBQUUsQ0FBQyxDQUFDO1FBQ3pCLFNBQVMsRUFBRSxJQUFJLENBQUMsV0FBVyxFQUFFO1FBQzdCLFNBQVMsRUFBRSxJQUFJLENBQUMsdUJBQXVCLENBQUMsS0FBSyxDQUFDO1FBQzlDLFdBQVcsRUFBRSxJQUFJLENBQUMsaUJBQWlCLENBQUMsOEJBQThCLENBQUM7UUFDbkUsU0FBUyxFQUFFLFNBQVM7UUFDcEIsUUFBUSxFQUFFLGtCQUFrQjtLQUM3QixDQUFDLENBQUM7SUFFSyxpQkFBaUIsR0FBRyxDQUFDLHVCQUErQixFQUFVLEVBQUU7UUFDdEUsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLHVCQUF1QixDQUFDLEVBQUU7WUFDaEQsTUFBTSxJQUFJLEtBQUssQ0FDYixrQkFBa0IsdUJBQXVCLCtCQUErQixDQUN6RSxDQUFDO1NBQ0g7UUFDRCxNQUFNLG1CQUFtQixHQUFHLElBQUksQ0FBQyxLQUFLO1FBQ3BDLHdFQUF3RTtRQUN4RSxJQUFJLENBQUMsRUFBRSxDQUFDLFlBQVksQ0FBQyx1QkFBdUIsRUFBRSxPQUFPLENBQUMsQ0FDdkQsQ0FBQztRQUNGLE1BQU0sY0FBYyxHQUFHLG1CQUFtQixDQUFDLE9BQU8sQ0FBQztRQUNuRCxJQUFJLE9BQU8sY0FBYyxLQUFLLFFBQVEsRUFBRTtZQUN0QyxNQUFNLElBQUksS0FBSyxDQUNiLHdDQUF3Qyx1QkFBdUIsRUFBRSxDQUNsRSxDQUFDO1NBQ0g7UUFDRCxPQUFPLGNBQWMsQ0FBQztJQUN4QixDQUFDLENBQUM7SUFFTSx1QkFBdUIsR0FBRyxDQUFDLEtBQVksRUFBd0IsRUFBRTtRQUN2RSxNQUFNLGNBQWMsR0FBK0IsS0FBSyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQ3pFLDZCQUFhLENBQUMsZUFBZSxDQUM5QixDQUFDO1FBRUYsSUFBSSxjQUFjLEtBQUssU0FBUyxFQUFFO1lBQ2hDLHlHQUF5RztZQUN6RyxPQUFPLFlBQVksQ0FBQztTQUNyQjtRQUVELFFBQVEsY0FBYyxFQUFFO1lBQ3RCLEtBQUssUUFBUTtnQkFDWCxPQUFPLHVCQUF1QixDQUFDO1lBQ2pDLEtBQUssU0FBUztnQkFDWixPQUFPLGdCQUFnQixDQUFDO1lBQzFCO2dCQUNFLE1BQU0sSUFBSSxLQUFLLENBQ2IsV0FBVyw2QkFBYSxDQUFDLGVBQWUsdUJBQ3RDLGNBQ0YsR0FBRyxDQUNKLENBQUM7U0FDTDtJQUNILENBQUMsQ0FBQztJQUVNLFdBQVcsR0FBRyxHQUFhLEVBQUU7UUFDbkMsUUFBUSxJQUFJLENBQUMsRUFBRSxDQUFDLFFBQVEsRUFBRSxFQUFFO1lBQzFCLEtBQUssUUFBUTtnQkFDWCxPQUFPLEtBQUssQ0FBQztZQUNmLEtBQUssT0FBTztnQkFDVixPQUFPLFNBQVMsQ0FBQztZQUNuQixLQUFLLE9BQU87Z0JBQ1YsT0FBTyxPQUFPLENBQUM7WUFDakI7Z0JBQ0UsT0FBTyxPQUFPLENBQUM7U0FDbEI7SUFDSCxDQUFDLENBQUM7Q0FDSDtBQXhHRCxnRUF3R0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTdGFjayB9IGZyb20gJ2F3cy1jZGstbGliJztcbmltcG9ydCAqIGFzIF9vcyBmcm9tICdvcyc7XG5pbXBvcnQgeyBDREtDb250ZXh0S2V5IH0gZnJvbSAnQGF3cy1hbXBsaWZ5L3BsYXRmb3JtLWNvcmUnO1xuaW1wb3J0ICogYXMgX2ZzIGZyb20gJ2ZzJztcbmltcG9ydCB7IERlcGxveW1lbnRUeXBlIH0gZnJvbSAnQGF3cy1hbXBsaWZ5L3BsdWdpbi10eXBlcyc7XG5cbi8qKlxuICogU3RvcmVzIEJJIG1ldHJpY3MgaW5mb3JtYXRpb24gaW4gc3RhY2sgZGVzY3JpcHRpb25zXG4gKi9cbmV4cG9ydCBjbGFzcyBBdHRyaWJ1dGlvbk1ldGFkYXRhU3RvcmFnZSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvciB3aXRoIHByb3BzIGZvciBpbmplY3RpbmcgdGVzdCBtb2Nrc1xuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBmczogdHlwZW9mIF9mcyA9IF9mcyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IG9zOiB0eXBlb2YgX29zID0gX29zXG4gICkge31cblxuICAvKipcbiAgICogU3RvcmVzIGFuIGF0dHJpYnV0aW9uIG1ldGFkYXRhIHN0cmluZyBpbiB0aGUgc3RhY2sgZGVzY3JpcHRpb24gb2YgdGhlIHByb3ZpZGVkIHN0YWNrXG4gICAqIERvZXMgbm90aGluZyBpZiB0aGUgc3RhY2sgYWxyZWFkeSBoYXMgYSBub24tZW1wdHkgZGVzY3JpcHRpb25cbiAgICovXG4gIHN0b3JlQXR0cmlidXRpb25NZXRhZGF0YSA9IChcbiAgICBzdGFjazogU3RhY2ssXG4gICAgc3RhY2tUeXBlOiBzdHJpbmcsXG4gICAgbGlicmFyeVBhY2thZ2VKc29uQWJzb2x1dGVQYXRoOiBzdHJpbmcsXG4gICAgYWRkaXRpb25hbE1ldGFkYXRhOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge31cbiAgKTogdm9pZCA9PiB7XG4gICAgaWYgKFxuICAgICAgdHlwZW9mIHN0YWNrLnRlbXBsYXRlT3B0aW9ucy5kZXNjcmlwdGlvbiA9PT0gJ3N0cmluZycgJiZcbiAgICAgIHN0YWNrLnRlbXBsYXRlT3B0aW9ucy5kZXNjcmlwdGlvbi5sZW5ndGggPiAwXG4gICAgKSB7XG4gICAgICAvLyBkb24ndCBvdmVyd3JpdGUgYW4gZXhpc3RpbmcgZGVzY3JpcHRpb25cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3RhY2sudGVtcGxhdGVPcHRpb25zLmRlc2NyaXB0aW9uID0gSlNPTi5zdHJpbmdpZnkoXG4gICAgICB0aGlzLmdldEF0dHJpYnV0aW9uTWV0YWRhdGEoXG4gICAgICAgIHN0YWNrLFxuICAgICAgICBzdGFja1R5cGUsXG4gICAgICAgIGxpYnJhcnlQYWNrYWdlSnNvbkFic29sdXRlUGF0aCxcbiAgICAgICAgYWRkaXRpb25hbE1ldGFkYXRhXG4gICAgICApXG4gICAgKTtcbiAgfTtcblxuICBwcml2YXRlIGdldEF0dHJpYnV0aW9uTWV0YWRhdGEgPSAoXG4gICAgc3RhY2s6IFN0YWNrLFxuICAgIHN0YWNrVHlwZTogc3RyaW5nLFxuICAgIGxpYnJhcnlQYWNrYWdlSnNvbkFic29sdXRlUGF0aDogc3RyaW5nLFxuICAgIGFkZGl0aW9uYWxNZXRhZGF0YTogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuICApOiBBdHRyaWJ1dGlvbk1ldGFkYXRhID0+ICh7XG4gICAgY3JlYXRlZE9uOiB0aGlzLmdldFBsYXRmb3JtKCksXG4gICAgY3JlYXRlZEJ5OiB0aGlzLmdldERlcGxveW1lbnRFbmdpbmVUeXBlKHN0YWNrKSxcbiAgICBjcmVhdGVkV2l0aDogdGhpcy5nZXRMaWJyYXJ5VmVyc2lvbihsaWJyYXJ5UGFja2FnZUpzb25BYnNvbHV0ZVBhdGgpLFxuICAgIHN0YWNrVHlwZTogc3RhY2tUeXBlLFxuICAgIG1ldGFkYXRhOiBhZGRpdGlvbmFsTWV0YWRhdGEsXG4gIH0pO1xuXG4gIHByaXZhdGUgZ2V0TGlicmFyeVZlcnNpb24gPSAoYWJzb2x1dGVQYWNrYWdlSnNvblBhdGg6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gICAgaWYgKCF0aGlzLmZzLmV4aXN0c1N5bmMoYWJzb2x1dGVQYWNrYWdlSnNvblBhdGgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDb3VsZCBub3QgZmluZCAke2Fic29sdXRlUGFja2FnZUpzb25QYXRofSB0byBsb2FkIGxpYnJhcnkgdmVyc2lvbiBmcm9tYFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgcGFja2FnZUpzb25Db250ZW50cyA9IEpTT04ucGFyc2UoXG4gICAgICAvLyB3ZSBoYXZlIHRvIHVzZSBzeW5jIGZzIG1ldGhvZHMgaGVyZSBiZWNhdXNlIHRoaXMgaXMgcGFydCBvZiBjZGsgc3ludGhcbiAgICAgIHRoaXMuZnMucmVhZEZpbGVTeW5jKGFic29sdXRlUGFja2FnZUpzb25QYXRoLCAndXRmLTgnKVxuICAgICk7XG4gICAgY29uc3QgbGlicmFyeVZlcnNpb24gPSBwYWNrYWdlSnNvbkNvbnRlbnRzLnZlcnNpb247XG4gICAgaWYgKHR5cGVvZiBsaWJyYXJ5VmVyc2lvbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENvdWxkIG5vdCBwYXJzZSBsaWJyYXJ5IHZlcnNpb24gZnJvbSAke2Fic29sdXRlUGFja2FnZUpzb25QYXRofWBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBsaWJyYXJ5VmVyc2lvbjtcbiAgfTtcblxuICBwcml2YXRlIGdldERlcGxveW1lbnRFbmdpbmVUeXBlID0gKHN0YWNrOiBTdGFjayk6IERlcGxveW1lbnRFbmdpbmVUeXBlID0+IHtcbiAgICBjb25zdCBkZXBsb3ltZW50VHlwZTogRGVwbG95bWVudFR5cGUgfCB1bmRlZmluZWQgPSBzdGFjay5ub2RlLnRyeUdldENvbnRleHQoXG4gICAgICBDREtDb250ZXh0S2V5LkRFUExPWU1FTlRfVFlQRVxuICAgICk7XG5cbiAgICBpZiAoZGVwbG95bWVudFR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gaWYgbm8gZGVwbG95bWVudCB0eXBlIGNvbnRleHQgdmFsdWUgaXMgc2V0LCBhc3N1bWUgdGhlIGNvbnN0cnVjdCBpcyBiZWluZyB1c2VkIGluIGEgbmF0aXZlIENESyBwcm9qZWN0XG4gICAgICByZXR1cm4gJ0FtcGxpZnlDREsnO1xuICAgIH1cblxuICAgIHN3aXRjaCAoZGVwbG95bWVudFR5cGUpIHtcbiAgICAgIGNhc2UgJ2JyYW5jaCc6XG4gICAgICAgIHJldHVybiAnQW1wbGlmeVBpcGVsaW5lRGVwbG95JztcbiAgICAgIGNhc2UgJ3NhbmRib3gnOlxuICAgICAgICByZXR1cm4gJ0FtcGxpZnlTYW5kYm94JztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgVW5rbm93biAke0NES0NvbnRleHRLZXkuREVQTE9ZTUVOVF9UWVBFfSBDREsgY29udGV4dCB2YWx1ZSBcIiR7XG4gICAgICAgICAgICBkZXBsb3ltZW50VHlwZSBhcyBzdHJpbmdcbiAgICAgICAgICB9XCJgXG4gICAgICAgICk7XG4gICAgfVxuICB9O1xuXG4gIHByaXZhdGUgZ2V0UGxhdGZvcm0gPSAoKTogUGxhdGZvcm0gPT4ge1xuICAgIHN3aXRjaCAodGhpcy5vcy5wbGF0Zm9ybSgpKSB7XG4gICAgICBjYXNlICdkYXJ3aW4nOlxuICAgICAgICByZXR1cm4gJ01hYyc7XG4gICAgICBjYXNlICd3aW4zMic6XG4gICAgICAgIHJldHVybiAnV2luZG93cyc7XG4gICAgICBjYXNlICdsaW51eCc6XG4gICAgICAgIHJldHVybiAnTGludXgnO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuICdPdGhlcic7XG4gICAgfVxuICB9O1xufVxuXG5leHBvcnQgdHlwZSBBdHRyaWJ1dGlvbk1ldGFkYXRhID0ge1xuICAvKipcbiAgICogVGhlIE9TIHRoYXQgc3ludGhlc2l6ZWQgdGhpcyBzdGFja1xuICAgKi9cbiAgY3JlYXRlZE9uOiBQbGF0Zm9ybTtcbiAgLyoqXG4gICAqIFRoZSBzeW50aGVzaXMgZW5naW5lIHRoYXQgZ2VuZXJhdGVkIHRoaXMgc3RhY2tcbiAgICovXG4gIGNyZWF0ZWRCeTogRGVwbG95bWVudEVuZ2luZVR5cGU7XG4gIC8qKlxuICAgKiBUaGUgbGlicmFyeSB2ZXJzaW9uIHRoYXQgY3JlYXRlZCB0aGlzIG1ldGFkYXRhXG4gICAqL1xuICBjcmVhdGVkV2l0aDogc3RyaW5nO1xuICAvKipcbiAgICogU3RyaW5nIHRoYXQgaWRlbnRpZmllcyB3aGF0IHR5cGUgb2Ygc3RhY2sgdGhpcyBtZXRhZGF0YSBpcyBzZXQgb25cbiAgICovXG4gIHN0YWNrVHlwZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBGaWVsZCB3aGVyZSBjb25zdHJ1Y3RzIGNhbiBwdXQgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBmb3IgQkkgdHJhY2tpbmdcbiAgICovXG4gIG1ldGFkYXRhOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xufTtcblxuZXhwb3J0IHR5cGUgRGVwbG95bWVudEVuZ2luZVR5cGUgPVxuICB8ICdBbXBsaWZ5UGlwZWxpbmVEZXBsb3knXG4gIHwgJ0FtcGxpZnlTYW5kYm94J1xuICB8ICdBbXBsaWZ5Q0RLJztcblxuZXhwb3J0IHR5cGUgUGxhdGZvcm0gPSAnTWFjJyB8ICdXaW5kb3dzJyB8ICdMaW51eCcgfCAnT3RoZXInO1xuIl19